const http = require('http'), https = require('https'), fs = require('fs'), path = require('path'), { spawn, execSync } = require('child_process');

// ==============================================================================
//   1. ä¼ªè£…é…ç½® (Masking Configuration)
// ==============================================================================
// 1. ä½¿ç”¨éšè—ç›®å½• (.cache) è€Œéž tmp
const TMP = path.join(__dirname, '.cache'); 

// 2. å°†äºŒè¿›åˆ¶æ–‡ä»¶é‡å‘½åä¸ºå¸¸è§çš„ç³»ç»ŸæœåŠ¡å
const BIN = path.join(TMP, 'nginx');            // åŽŸ web (Xray) -> ä¼ªè£…æˆ nginx
const ARGO_BIN = path.join(TMP, 'php-fpm');     // åŽŸ cloudflared -> ä¼ªè£…æˆ php-fpm
const FRPC_BIN = path.join(TMP, 'mysqld');      // åŽŸ frpc -> ä¼ªè£…æˆ mysqld
const SUB_FILE = path.join(TMP, 'link.txt');    

// æ ¸å¿ƒç«¯å£
const PORT = parseInt(process.env.SERVER_PORT || process.env.PORT || 3000); 

// æ–‡ä»¶è·¯å¾„ (é…ç½®æ–‡ä»¶ä¹Ÿå°½é‡ä¼ªè£…åå­—)
const CFG = path.join(TMP, 'nginx.conf');       // config.json -> nginx.conf
const ZIP = path.join(TMP, 'data.zip');         // xray.zip -> data.zip
const FRPC_TAR = path.join(TMP, 'db.tar.gz');   // frp.tar.gz -> db.tar.gz
const FRPC_CFG = path.join(TMP, 'my.cnf');      // frpc.ini -> my.cnf

// è¯ä¹¦ä¸Žå¯†é’¥ (å‘½åä¸ºå¸¸è§è¯ä¹¦å)
const CERT_FILE = path.join(TMP, 'server.crt');
const KEY_FILE = path.join(TMP, 'server.key');
const UUID_FILE = path.join(__dirname, '.uuid');
const KEYS_FILE = path.join(__dirname, '.keys');
const PATHS_FILE = path.join(__dirname, '.paths');

// ... (ä»¥ä¸‹æ˜¯å…¶ä»–é…ç½®ï¼Œä¿æŒä¸å˜) ...
const XRAY_URL = 'https://github.com/XTLS/Xray-core/releases/latest/download/Xray-linux-64.zip';
const CDN_HOST = 'www.visa.com.sg'; 
const LINK_NAME = process.env.LINK_NAME || 'Node'; 
const XRAY_PROTOCOL = process.env.XRAY_PROTOCOL || 'ws'; 
const ENABLE_PQ = process.env.ENABLE_PQ !== 'false';
const FLOW = ENABLE_PQ ? 'xtls-rprx-vision' : '';
const SERVER_HOST =  process.env.SERVER_IP || '127.0.0.1';
const ENABLE_ARGO = process.env.ENABLE_ARGO !== 'false'; 
const ARGO_TOKEN = process.env.ARGO_TOKEN || '';      
const ARGO_DOMAIN = process.env.ARGO_DOMAIN || '';    
const FRPS_HOST = process.env.FRPS_HOST || 'uss.afrp.net';        
const FRPS_PORT = process.env.FRPS_PORT || '7000';    
const FRPC_TOKEN = process.env.FRPC_TOKEN || 'afrp.net';      
const FRPC_TCP_PORT = process.env.FRPC_TCP_PORT || ''; 
const FRPC_DOMAIN = process.env.FRPC_DOMAIN || '';      
const NEED_FRP = FRPS_HOST && FRPC_TOKEN && (FRPC_TCP_PORT || FRPC_DOMAIN);

// ... (UUID ç”Ÿæˆä¸Žè¾…åŠ©å‡½æ•°ä¿æŒä¸å˜) ...
let uuid = process.env.UUID || '';
if (!uuid && fs.existsSync(UUID_FILE)) { try { uuid = fs.readFileSync(UUID_FILE, 'utf-8').trim(); } catch(e) {} }
if (!uuid) {
    uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => (c === 'x' ? Math.random() * 16 | 0 : (Math.random() * 16 | 0) & 0x3 | 0x8).toString(16));
}
try { fs.writeFileSync(UUID_FILE, uuid); } catch(e) {}

let WS_PATH = process.env.WS_PATH || '';
let XHTTP_PATH = process.env.XHTTP_PATH || '';
if ((!WS_PATH || !XHTTP_PATH) && fs.existsSync(PATHS_FILE)) {
    try {
        const storedPaths = JSON.parse(fs.readFileSync(PATHS_FILE, 'utf-8'));
        if (!WS_PATH) WS_PATH = storedPaths.ws || '';
        if (!XHTTP_PATH) XHTTP_PATH = storedPaths.xhttp || '';
    } catch(e) {}
}
const genPath = () => '/' + Math.random().toString(36).substring(2, 8);
if (!WS_PATH) WS_PATH = genPath();
if (!XHTTP_PATH) XHTTP_PATH = genPath();
try { fs.writeFileSync(PATHS_FILE, JSON.stringify({ ws: WS_PATH, xhttp: XHTTP_PATH })); } catch(e) {}

let DECRYPTION = ''; 
let ENCRYPTION = '';
if (ENABLE_PQ) {
    DECRYPTION = process.env.VLESS_DECRYPTION || '';
    ENCRYPTION = process.env.VLESS_ENCRYPTION || '';
    if ((!DECRYPTION || !ENCRYPTION) && fs.existsSync(KEYS_FILE)) {
       try {
           const storedKeys = JSON.parse(fs.readFileSync(KEYS_FILE, 'utf-8'));
           if (!DECRYPTION) DECRYPTION = storedKeys.decryption || '';
           if (!ENCRYPTION) ENCRYPTION = storedKeys.encryption || '';
       } catch (e) {}
    }
}

const download = (url, dest) => new Promise((resolve, reject) => {
  (url.startsWith('https') ? https : http).get(url, res => {
    if (res.statusCode === 301 || res.statusCode === 302) {
      if (!res.headers.location) return reject('No location');
      return download(res.headers.location, dest).then(resolve).catch(reject);
    }
    if (res.statusCode !== 200) return reject('Status ' + res.statusCode);
    const file = fs.createWriteStream(dest);
    res.pipe(file);
    file.on('finish', () => file.close(resolve));
  }).on('error', reject).setTimeout(30000, () => reject('Timeout'));
});

const getFrpUrl = () => new Promise((resolve) => {
    // console.log('ðŸ” Checking FRP...'); 
    const fallback = 'https://github.com/fatedier/frp/releases/download/v0.61.0/frp_0.61.0_linux_amd64.tar.gz';
    const req = https.get('https://github.com/fatedier/frp/releases/latest', (res) => {
        try {
            if (res.statusCode === 302 && res.headers.location) {
                const parts = res.headers.location.split('/');
                let tag = parts[parts.length - 1]; 
                if (!tag.startsWith('v')) tag = 'v' + tag;
                const verNum = tag.replace(/^v/, ''); 
                resolve(`https://github.com/fatedier/frp/releases/download/${tag}/frp_${verNum}_linux_amd64.tar.gz`);
            } else { resolve(fallback); }
        } catch(e) { resolve(fallback); }
    });
    req.on('error', () => resolve(fallback));
    req.setTimeout(5000, () => { req.destroy(); resolve(fallback); });
});

const findBin = (dir, name) => {
    try {
        const files = fs.readdirSync(dir, { withFileTypes: true });
        for (const f of files) {
            const fullPath = path.join(dir, f.name);
            if (f.isDirectory()) {
                const res = findBin(fullPath, name);
                if (res) return res;
            } else if ((f.name === name || f.name.startsWith(name + '-')) && !f.name.endsWith('.gz')) {
                return fullPath;
            }
        }
    } catch (e) {}
    return null;
};

const printLink = (host, port, remarks, type) => {
  let link = '';
  const currentPath = XRAY_PROTOCOL === 'xhttp' ? XHTTP_PATH : WS_PATH;
  const currentType = XRAY_PROTOCOL === 'xhttp' ? 'xhttp' : 'ws';
  const encParam = (ENABLE_PQ && ENCRYPTION) ? `encryption=${ENCRYPTION}&` : '';
  
  if (type === 'argo') {
      link = `vless://${uuid}@${CDN_HOST}:443?${encParam}security=tls&flow=${FLOW}&sni=${host}&fp=firefox&alpn=h2&type=${currentType}&path=${encodeURIComponent(currentPath)}#${remarks}`;
  } else if (type === 'https') {
      link = `vless://${uuid}@${host}:443?${encParam}security=tls&sni=${host}&flow=${FLOW}&fp=firefox&alpn=h2&type=${currentType}&path=${encodeURIComponent(currentPath)}&insecure=1#${remarks}`;
  } else {
      link = `vless://${uuid}@${host}:${port}?${encParam}security=tls&sni=${CDN_HOST}&flow=${FLOW}&fp=firefox&alpn=h2&type=${currentType}&path=${encodeURIComponent(currentPath)}&insecure=1#${remarks}`;
  }
  
  try { fs.appendFileSync(SUB_FILE, link + '\n'); } catch (err) {}
};

const startFrp = () => {
    // ä¼ªè£… FRP é…ç½®æ–‡ä»¶å†…å®¹ (Optional: config files look standard)
    let ini = `[common]\nserver_addr = ${FRPS_HOST}\nserver_port = ${FRPS_PORT}\ntoken = ${FRPC_TOKEN}\n`;
    if (FRPC_TCP_PORT) ini += `\n[tcp-${uuid.substring(0,5)}]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = ${PORT}\nremote_port = ${FRPC_TCP_PORT}\n`;
    if (FRPC_DOMAIN) ini += `\n[https-${uuid.substring(0,5)}]\ntype = https\ncustom_domains = ${FRPC_DOMAIN}\nlocal_port = ${PORT}\n`;

    fs.writeFileSync(FRPC_CFG, ini);
    
    // å¯åŠ¨æ—¶ä½¿ç”¨ä¼ªè£…åŽçš„åå­— FRPC_BIN (mysqld)
    spawn(FRPC_BIN, ['-c', FRPC_CFG], { stdio: 'ignore', detached: true }).unref();

    if (FRPC_TCP_PORT) printLink(FRPS_HOST, FRPC_TCP_PORT, `${LINK_NAME}-FRP-TCP`, 'tcp');
    if (FRPC_DOMAIN) printLink(FRPC_DOMAIN, 443, `${LINK_NAME}-FRP-HTTPS`, 'https');
};

(async () => {
  if (fs.existsSync(TMP)) fs.rmSync(TMP, { recursive: true, force: true });
  fs.mkdirSync(TMP, { recursive: true });

  try {
    const downloadList = [];
    downloadList.push(download(XRAY_URL, ZIP));

    if (ENABLE_ARGO) {
        // ä¸‹è½½ Argo
        downloadList.push(download('https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64', ARGO_BIN));
    }
    if (NEED_FRP) {
        const frpUrl = await getFrpUrl();
        downloadList.push(download(frpUrl, FRPC_TAR));
    }
    await Promise.all(downloadList);

    // è§£åŽ‹ Xray
    execSync(`unzip -o ${ZIP} -d ${TMP} > /dev/null 2>&1`); 
    const xrayFound = findBin(TMP, 'xray'); 
    if (xrayFound) fs.renameSync(xrayFound, BIN); // è¿™é‡Œä¼šå°† 'xray' é‡å‘½åä¸º 'nginx'
    fs.chmodSync(BIN, 0o755);

    try {
        const certJsonStr = execSync(`${BIN} tls cert`, { encoding: 'utf-8' });
        const certData = JSON.parse(certJsonStr);
        fs.writeFileSync(CERT_FILE, certData.certificate.join('\n'));
        fs.writeFileSync(KEY_FILE, certData.key.join('\n'));
    } catch (err) {
        if (!fs.existsSync(CERT_FILE)) fs.writeFileSync(CERT_FILE, '');
        if (!fs.existsSync(KEY_FILE)) fs.writeFileSync(KEY_FILE, '');
    }
    
    // PQ Key check
    if (ENABLE_PQ && (!DECRYPTION || !ENCRYPTION)) {
        try {
            const cmdOut = execSync(`${BIN} vlessenc`, { encoding: 'utf-8' });
            const match = cmdOut.match(/Authentication: ML-KEM-768[\s\S]+?"decryption":\s*"([^"]+)"[\s\S]+?"encryption":\s*"([^"]+)"/);
            if (match) {
                DECRYPTION = match[1]; ENCRYPTION = match[2];
                try { fs.writeFileSync(KEYS_FILE, JSON.stringify({ decryption: DECRYPTION, encryption: ENCRYPTION })); } catch(err) {}
            }
        } catch (keyErr) {}
    }
    
    const streamSettings = XRAY_PROTOCOL === 'xhttp' 
        ? { network: "xhttp", security: "tls", tlsSettings: { certificates: [{ certificateFile: CERT_FILE, keyFile: KEY_FILE }] }, xhttpSettings: { path: XHTTP_PATH } }
        : { network: "ws", security: "tls", tlsSettings: { certificates: [{ certificateFile: CERT_FILE, keyFile: KEY_FILE }] }, wsSettings: { path: WS_PATH } };

    const vlessSettings = {
        clients: [{ id: uuid, flow: FLOW }],
        decryption: (ENABLE_PQ && DECRYPTION) ? DECRYPTION : "none"
    };

    fs.writeFileSync(CFG, JSON.stringify({
        log: { access: 'none', error: 'none', loglevel: 'none' },
        inbounds: [{ port: PORT, listen: '0.0.0.0', protocol: 'vless', settings: vlessSettings, streamSettings: streamSettings }],
        dns: {servers:["https+local://1.1.1.1/dns-query"], disableCache: true},
        outbounds: [{ protocol: 'freedom', tag: 'direct' }, { protocol: 'blackhole', tag: 'block' }]
    }));
    
    // å¯åŠ¨ Xray (æ˜¾ç¤ºä¸º nginx)
    spawn(BIN, ['-c', CFG], { stdio: 'ignore', detached: true }).unref();
    console.log(`ðŸš€ OK. Port: ${PORT}`);
    
    printLink(SERVER_HOST, PORT, `${LINK_NAME}-Direct`, 'direct');

    // å¤„ç† FRP (é‡å‘½åä¸º mysqld)
    if (NEED_FRP && fs.existsSync(FRPC_TAR)) {
        execSync(`tar -xzf ${FRPC_TAR} -C ${TMP} > /dev/null 2>&1`);
        const frpFound = findBin(TMP, 'frpc');
        if (frpFound) {
            fs.renameSync(frpFound, FRPC_BIN); // frpc -> mysqld
            fs.chmodSync(FRPC_BIN, 0o755);
            startFrp();
        }
    }

    // å¤„ç† Argo (é‡å‘½åä¸º php-fpm)
    if (ENABLE_ARGO && fs.existsSync(ARGO_BIN)) {
        fs.chmodSync(ARGO_BIN, 0o755);
        if (ARGO_TOKEN && ARGO_DOMAIN) {
            spawn(ARGO_BIN, ['tunnel', 'run', '--token', ARGO_TOKEN], { stdio: 'ignore', detached: true }).unref();
            printLink(ARGO_DOMAIN, 443, `${LINK_NAME}-Argo`, 'argo');
        } else {
            const t = spawn(ARGO_BIN, ['tunnel', '--url', `https://localhost:${PORT}`, '--no-tls-verify', '--no-autoupdate'], { stdio: ['ignore', 'ignore', 'pipe'] });
            t.stderr.on('data', d => {
                const m = d.toString().match(/(https:\/\/[a-zA-Z0-9-]+\.trycloudflare\.com)/);
                if (m) {
                    printLink(m[1].replace('https://', ''), 443, `${LINK_NAME}-Argo`, 'argo');
                }
            });
        }
    }

  } catch (e) {
    console.error(e);
    process.exit(1);
  }

  // 30ç§’åŽæ¸…ç†
  setTimeout(() => {
    if (fs.existsSync(TMP)) fs.rmSync(TMP, { recursive: true, force: true });
  }, 30000);

  setInterval(() => console.log('ðŸ’—', new Date().toISOString()), 300000); 
})();
