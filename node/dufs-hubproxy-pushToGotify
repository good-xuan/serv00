const http = require('http');
const https = require('https');
const fs = require('fs');
const path = require('path');
const { spawn, execSync } = require('child_process');
const { URL } = require('url'); // ç”¨äºè§£æ Gotify URL

// ==============================================================================
//   1. ç›®å½•ä¸æ–‡ä»¶è·¯å¾„é…ç½® (Paths & Files)
// ==============================================================================
const ROOT_DIR = __dirname;
const TEMP_DIR = path.join(ROOT_DIR, 'tmp');
const SHARE_DIR = path.join(ROOT_DIR, 'share');

// å¯æ‰§è¡Œæ–‡ä»¶è·¯å¾„ (Executables)
const DUFS_EXEC = path.join(TEMP_DIR, 'dufs');
const HUBPROXY_EXEC = path.join(TEMP_DIR, 'hub_app'); // æ”¹åä»¥é¿å…ä¸è§£å‹ç›®å½•å†²çª
const CLOUDFLARED_EXEC = path.join(TEMP_DIR, 'cloudflared');

// å‹ç¼©åŒ…è·¯å¾„ (Archives)
const DUFS_ARCHIVE = path.join(TEMP_DIR, 'dufs.tar.gz');
const HUBPROXY_ARCHIVE = path.join(TEMP_DIR, 'hub.tar.gz');

// ==============================================================================
//   2. æœåŠ¡ç«¯å£é…ç½® (Port Configuration)
// ==============================================================================
// ä¸»ç«¯å£ï¼šåˆ†é…ç»™ Dufs (æ–‡ä»¶æœåŠ¡)
const DUFS_PORT = parseInt(process.env.SERVER_PORT || process.env.PORT || 3000);

// å‰¯ç«¯å£ï¼šåˆ†é…ç»™ HubProxy (é¿å…å†²çªï¼Œåç§» +2)
const HUBPROXY_PORT = DUFS_PORT + 2;

// ==============================================================================
//   3. å¤–éƒ¨èµ„æºé“¾æ¥ (External URLs)
// ==============================================================================
const CLOUDFLARED_URL = 'https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64';

// ==============================================================================
//   4. åŠŸèƒ½å¼€å…³ä¸éš§é“é…ç½® (Toggles & Tunnel Config)
// ==============================================================================
// æ€»å¼€å…³ (âš ï¸ ç¡¬ç¼–ç ä¸º true)
const IS_CLOUDFLARED_ENABLED = true;

// Dufs éš§é“é…ç½® (å¯¹åº”åŸ Argo2) (âš ï¸ ç¡¬ç¼–ç ä¸º true)
const IS_DUFS_TUNNEL_ENABLED = true;
const DUFS_TUNNEL_TOKEN = process.env.ARGO2_TOKEN || '';
const DUFS_TUNNEL_DOMAIN = process.env.ARGO2_DOMAIN || '';

// HubProxy éš§é“é…ç½® (å¯¹åº”åŸ Argo3) (âš ï¸ ç¡¬ç¼–ç ä¸º true)
const IS_HUBPROXY_TUNNEL_ENABLED = true; 
const HUBPROXY_TUNNEL_TOKEN = process.env.ARGO3_TOKEN || '';
const HUBPROXY_TUNNEL_DOMAIN = process.env.ARGO3_DOMAIN || '';

// Gotify æ¨é€é…ç½® (âš ï¸ ç¡¬ç¼–ç ä¸º true)
const IS_GOTIFY_ENABLED = true; 
const GOTIFY_URL = 'https://gotify.uptk.netlib.re/'; 
const GOTIFY_TOKEN = 'AjYE_NvX42Q38Af';
const GOTIFY_PRIORITY = parseInt(process.env.GOTIFY_PRIORITY || 5); // é»˜è®¤ä¼˜å…ˆçº§ 5

// ==============================================================================
//   5. åˆå§‹åŒ–ç¯å¢ƒ (Initialization)
// ==============================================================================
if (!fs.existsSync(SHARE_DIR)) {
    try { fs.mkdirSync(SHARE_DIR); } catch (e) {}
}

// ==============================================================================
//   6. å·¥å…·å‡½æ•° (Helper Functions)
// ==============================================================================

/**
 * ä¸‹è½½æ–‡ä»¶
 */
const downloadResource = (url, destination) => new Promise((resolve, reject) => {
    const protocol = url.startsWith('https') ? https : http;
    protocol.get(url, res => {
        if (res.statusCode === 301 || res.statusCode === 302) {
            if (!res.headers.location) return reject('No redirect location found');
            return downloadResource(res.headers.location, destination).then(resolve).catch(reject);
        }
        if (res.statusCode !== 200) return reject(`Download failed. Status: ${res.statusCode}`);
        
        const fileStream = fs.createWriteStream(destination);
        res.pipe(fileStream);
        fileStream.on('finish', () => fileStream.close(resolve));
    }).on('error', reject).setTimeout(30000, () => reject('Download timeout'));
});

/**
 * è·å– Dufs æœ€æ–°ä¸‹è½½é“¾æ¥
 */
const fetchDufsLatestUrl = () => new Promise((resolve) => {
    https.get('https://github.com/sigoden/dufs/releases/latest', (res) => {
        try {
            const location = res.headers.location;
            const versionTag = location ? path.basename(location) : 'v0.43.0';
            const versionNum = versionTag.replace('v', '');
            resolve(`https://github.com/sigoden/dufs/releases/download/${versionTag}/dufs-v${versionNum}-x86_64-unknown-linux-musl.tar.gz`);
        } catch (e) {
            resolve('https://github.com/sigoden/dufs/releases/download/v0.43.0/dufs-v0.43.0-x86_64-unknown-linux-musl.tar.gz');
        }
    }).on('error', () => resolve('https://github.com/sigoden/dufs/releases/download/v0.43.0/dufs-v0.43.0-x86_64-unknown-linux-musl.tar.gz'));
});

/**
 * è·å– HubProxy æœ€æ–°ä¸‹è½½é“¾æ¥
 */
const fetchHubProxyUrl = () => new Promise((resolve) => {
    console.log('ğŸ” Checking HubProxy version...');
    const fallbackUrl = 'https://github.com/sky22333/hubproxy/releases/download/v1.1.9/hubproxy-v1.1.9-linux-amd64.tar.gz';
    
    const req = https.get('https://github.com/sky22333/hubproxy/releases/latest', (res) => {
        try {
            if (res.statusCode === 200 || res.statusCode === 302) {
                const location = res.headers.location;
                if (location) {
                    const tag = path.basename(location);
                    resolve(`https://github.com/sky22333/hubproxy/releases/download/${tag}/hubproxy-${tag}-linux-amd64.tar.gz`);
                } else {
                    resolve(fallbackUrl);
                }
            } else {
                resolve(fallbackUrl);
            }
        } catch (e) {
            resolve(fallbackUrl);
        }
    });
    
    req.on('error', () => resolve(fallbackUrl));
    req.setTimeout(5000, () => {
        req.destroy();
        resolve(fallbackUrl);
    });
});

/**
 * é€’å½’æŸ¥æ‰¾å¯æ‰§è¡Œæ–‡ä»¶ (å¤„ç†è§£å‹åç›®å½•ç»“æ„ä¸ç¡®å®šçš„é—®é¢˜)
 */
const findExecutable = (dir, filename) => {
    try {
        const files = fs.readdirSync(dir, { withFileTypes: true });
        for (const file of files) {
            const fullPath = path.join(dir, file.name);
            if (file.isDirectory()) {
                const result = findExecutable(fullPath, filename);
                if (result) return result;
            } else {
                // åŒ¹é…æ–‡ä»¶åï¼Œæ’é™¤å‹ç¼©åŒ…
                if ((file.name === filename || file.name.startsWith(filename + '-')) && 
                    !file.name.endsWith('.gz') && 
                    !file.name.endsWith('.zip')) {
                    return fullPath;
                }
            }
        }
    } catch (e) {}
    return null;
};

/**
 * æ¨é€çŠ¶æ€åˆ° Gotify (ä½¿ç”¨ JSON Bodyï¼ŒToken åœ¨ URL ä¸­ï¼Œæœ€å¯é çš„æ–¹å¼)
 */
const pushToGotify = (title, dufsUrl, hubUrl) => new Promise((resolve, reject) => {
    // æ£€æŸ¥ Gotify æ‰€éœ€çš„é…ç½®é¡¹ (è™½ç„¶ IS_GOTIFY_ENABLED ä¸º trueï¼Œä½† URL å’Œ TOKEN å¿…é¡»å­˜åœ¨)
    if (!GOTIFY_URL || !GOTIFY_TOKEN) {
        console.log('âš ï¸ Gotify is enabled but GOTIFY_URL or GOTIFY_TOKEN is missing. Skipping.');
        return resolve();
    }

    // æ„é€ æ¶ˆæ¯ä½“
    const message = [
        "ğŸš€ æœåŠ¡å¯åŠ¨æˆåŠŸï¼",
        `\n[Dufs æ–‡ä»¶æœåŠ¡]`,
        `æœ¬åœ°: http://localhost:${DUFS_PORT}`,
        // æ³¨æ„ï¼šç”±äº IS_DUFS_TUNNEL_ENABLED ä¸º trueï¼Œè¿™é‡Œ Public URL ä»…å–å†³äºæ˜¯å¦è·å–åˆ°
        `å…¬ç½‘: ${dufsUrl || 'N/A (æ­£åœ¨åˆå§‹åŒ–/æœªè·å–)'}`,
        `\n[HubProxy é•œåƒ]`,
        `æœ¬åœ°: http://localhost:${HUBPROXY_PORT}`,
        // æ³¨æ„ï¼šç”±äº IS_HUBPROXY_TUNNEL_ENABLED ä¸º trueï¼Œè¿™é‡Œ Public URL ä»…å–å†³äºæ˜¯å¦è·å–åˆ°
        `å…¬ç½‘: ${hubUrl || 'N/A (æ­£åœ¨åˆå§‹åŒ–/æœªè·å–)'}`,
        `\nâ° Time: ${new Date().toLocaleString()}`
    ].join('\n');

    try {
        const url = new URL(GOTIFY_URL);
        const gotifyHost = url.hostname;
        const gotifyPort = url.port || (url.protocol === 'https:' ? 443 : 80);
        const gotifyProtocol = url.protocol.startsWith('https') ? https : http;
        
        // ç¡®ä¿è·¯å¾„ä»¥ /message ç»“å°¾
        const gotifyPath = url.pathname.replace(/\/$/, '') + '/message';
        
        // JSON Payload
        const postData = JSON.stringify({
            title: title,
            message: message,
            priority: GOTIFY_PRIORITY
        });

        // å‘èµ·è¯·æ±‚ (ä½¿ç”¨ JSON Content-Type)
        const req = gotifyProtocol.request({
            hostname: gotifyHost,
            port: gotifyPort,
            // å…³é”®ï¼šToken åœ¨ URL æŸ¥è¯¢å‚æ•°ä¸­
            path: `${gotifyPath}?token=${GOTIFY_TOKEN}`, 
            method: 'POST',
            headers: {
                'Content-Type': 'application/json', // <--- ä½¿ç”¨ JSON æ ¼å¼
                'Content-Length': Buffer.byteLength(postData)
            }
        }, res => {
            if (res.statusCode >= 200 && res.statusCode < 300) {
                console.log('âœ… Gotify notification sent (JSON Body).');
                resolve();
            } else {
                let responseBody = '';
                res.on('data', chunk => responseBody += chunk);
                res.on('end', () => {
                    console.error(`âŒ Gotify failed. Status: ${res.statusCode}. Response: ${responseBody}`);
                    resolve(); 
                });
            }
        });

        req.on('error', (e) => {
            console.error(`âŒ Gotify connection error: ${e.message}`);
            resolve();
        });
        
        req.write(postData);
        req.end();

    } catch (e) {
        console.error('âŒ Gotify URL/Token configuration error:', e.message);
        resolve(); // å¿½ç•¥ Gotify é”™è¯¯ï¼Œä¸å½±å“ä¸»æœåŠ¡å¯åŠ¨
    }
});


// ==============================================================================
//   7. ä¸»ç¨‹åºé€»è¾‘ (Main Execution)
// ==============================================================================

(async () => {
    // ç”¨äºå­˜å‚¨ç”Ÿæˆçš„å…¬ç½‘åœ°å€ (å†…å­˜å­˜å‚¨ï¼Œä¸æŒä¹…åŒ–)
    let dufsPublicUrl = '';
    let hubProxyPublicUrl = '';

    // æ¸…ç†ä¸´æ—¶ç›®å½•
    if (fs.existsSync(TEMP_DIR)) fs.rmSync(TEMP_DIR, { recursive: true, force: true });
    fs.mkdirSync(TEMP_DIR, { recursive: true });

    try {
        console.log('â³ Initializing services...');

        // --- 1. ä¸‹è½½é˜¶æ®µ (Downloading) ---
        const dufsDownloadUrl = await fetchDufsLatestUrl();
        let hubProxyDownloadUrl;
        try {
            hubProxyDownloadUrl = await fetchHubProxyUrl();
        } catch (e) {
            hubProxyDownloadUrl = 'https://github.com/sky22333/hubproxy/releases/download/v1.1.9/hubproxy-v1.1.9-linux-amd64.tar.gz';
        }

        const tasks = [
            downloadResource(dufsDownloadUrl, DUFS_ARCHIVE),
            downloadResource(hubProxyDownloadUrl, HUBPROXY_ARCHIVE)
        ];

        // åªæœ‰åœ¨ IS_CLOUDFLARED_ENABLED ä¸º true æ—¶æ‰ä¸‹è½½ï¼Œä½†ç°åœ¨å®ƒè¢«ç¡¬ç¼–ç ä¸º true
        if (IS_CLOUDFLARED_ENABLED) { 
            tasks.push(downloadResource(CLOUDFLARED_URL, CLOUDFLARED_EXEC));
        }

        await Promise.all(tasks);

        // --- 2. è§£å‹ä¸å®‰è£…é˜¶æ®µ (Extraction & Installation) ---
        
        // å®‰è£… Dufs
        console.log(`ğŸ“¦ Installing Dufs...`);
        execSync(`tar -xzf ${DUFS_ARCHIVE} -C ${TEMP_DIR}`);
        const dufsFoundPath = findExecutable(TEMP_DIR, 'dufs');
        if (dufsFoundPath && dufsFoundPath !== DUFS_EXEC) {
            fs.renameSync(dufsFoundPath, DUFS_EXEC);
        }
        fs.chmodSync(DUFS_EXEC, 0o755);

        // å®‰è£… HubProxy
        console.log(`ğŸ“¦ Installing HubProxy...`);
        execSync(`tar -xzf ${HUBPROXY_ARCHIVE} -C ${TEMP_DIR}`);
        const hubFoundPath = findExecutable(TEMP_DIR, 'hubproxy');
        if (hubFoundPath) {
            if (hubFoundPath !== HUBPROXY_EXEC) {
                fs.renameSync(hubFoundPath, HUBPROXY_EXEC);
            }
            fs.chmodSync(HUBPROXY_EXEC, 0o755);
        } else {
            console.warn('âš ï¸ HubProxy binary not found.');
        }

        // è®¾ç½® Cloudflared æƒé™
        if (IS_CLOUDFLARED_ENABLED && fs.existsSync(CLOUDFLARED_EXEC)) {
            fs.chmodSync(CLOUDFLARED_EXEC, 0o755);
        }

        // --- 3. å¯åŠ¨æœåŠ¡é˜¶æ®µ (Starting Services) ---

        // å¯åŠ¨ Dufs (ä¸»æœåŠ¡)
        console.log(`ğŸ“‚ Starting Dufs on port ${DUFS_PORT}...`);
        spawn(DUFS_EXEC, [SHARE_DIR, '-p', String(DUFS_PORT), '-A', '--bind', '0.0.0.0'], {
            stdio: 'inherit',
            detached: true
        }).unref();

        // å¯åŠ¨ HubProxy (å‰¯æœåŠ¡)
        if (fs.existsSync(HUBPROXY_EXEC)) {
            console.log(`ğŸ³ Starting HubProxy on port ${HUBPROXY_PORT}...`);
            spawn(HUBPROXY_EXEC, ['--addr', `:${HUBPROXY_PORT}`], {
                stdio: 'ignore',
                detached: true,
                // å…³é”®: è¦†ç›–ç¯å¢ƒå˜é‡ï¼Œé˜²æ­¢ HubProxy è¯»å–ç³»ç»Ÿçš„ PORT å¯¼è‡´å†²çª
                env: { 
                    ...process.env, 
                    PORT: String(HUBPROXY_PORT), 
                    SERVER_PORT: String(HUBPROXY_PORT) 
                }
            }).unref();
        }

        // --- 4. å¯åŠ¨éš§é“é˜¶æ®µ (Starting Tunnels) ---
        // IS_CLOUDFLARED_ENABLED ç°åœ¨æ˜¯ç¡¬ç¼–ç çš„ true
        if (IS_CLOUDFLARED_ENABLED && fs.existsSync(CLOUDFLARED_EXEC)) {
            
            // Dufs éš§é“ (IS_DUFS_TUNNEL_ENABLED ç°åœ¨æ˜¯ç¡¬ç¼–ç çš„ true)
            if (IS_DUFS_TUNNEL_ENABLED) {
                if (DUFS_TUNNEL_TOKEN && DUFS_TUNNEL_DOMAIN) {
                    // å›ºå®šéš§é“
                    dufsPublicUrl = `https://${DUFS_TUNNEL_DOMAIN}`;
                    
                    spawn(CLOUDFLARED_EXEC, ['tunnel', 'run', '--token', DUFS_TUNNEL_TOKEN], { 
                        stdio: 'ignore', detached: true 
                    }).unref();
                    
                    console.log(`ğŸ”— Dufs Tunnel (Fixed): ${dufsPublicUrl}`);
                } else {
                    // ä¸´æ—¶éš§é“ (TryCloudflare)
                    const tunnel = spawn(CLOUDFLARED_EXEC, [
                        'tunnel', '--url', `http://localhost:${DUFS_PORT}`, 
                        '--no-autoupdate'
                    ], { stdio: ['ignore', 'ignore', 'pipe'] });

                    tunnel.stderr.on('data', d => {
                        const match = d.toString().match(/(https:\/\/[a-zA-Z0-9-]+\.trycloudflare\.com)/);
                        if (match) {
                            dufsPublicUrl = match[1];
                            console.log(`ğŸ”— Dufs Tunnel (Temp): ${dufsPublicUrl}`);
                        }
                    });
                }
            }

            // HubProxy éš§é“ (IS_HUBPROXY_TUNNEL_ENABLED ç°åœ¨æ˜¯ç¡¬ç¼–ç çš„ true)
            if (IS_HUBPROXY_TUNNEL_ENABLED) {
                if (HUBPROXY_TUNNEL_TOKEN && HUBPROXY_TUNNEL_DOMAIN) {
                    // å›ºå®šéš§é“
                    hubProxyPublicUrl = `https://${HUBPROXY_TUNNEL_DOMAIN}`;

                    spawn(CLOUDFLARED_EXEC, ['tunnel', 'run', '--token', HUBPROXY_TUNNEL_TOKEN], { 
                        stdio: 'ignore', detached: true 
                    }).unref();

                    console.log(`ğŸ”— HubProxy Tunnel (Fixed): ${hubProxyPublicUrl}`);
                } else {
                    // ä¸´æ—¶éš§é“
                    const tunnel = spawn(CLOUDFLARED_EXEC, [
                        'tunnel', '--url', `http://localhost:${HUBPROXY_PORT}`, 
                        '--no-autoupdate'
                    ], { stdio: ['ignore', 'ignore', 'pipe'] });

                    tunnel.stderr.on('data', d => {
                        const match = d.toString().match(/(https:\/\/[a-zA-Z0-9-]+\.trycloudflare\.com)/);
                        if (match) {
                            hubProxyPublicUrl = match[1];
                            console.log(`ğŸ”— HubProxy Tunnel (Temp): ${hubProxyPublicUrl}`);
                        }
                    });
                }
            }
        }

    } catch (e) {
        console.error('âŒ Critical Error:', e);
        process.exit(1);
    }

    // --- çŠ¶æ€æ‰“å°å‡½æ•° ---
    const printServiceStatus = () => {
        // ç‰©ç†æ¸…å±
        process.stdout.write('\033c');
        
        console.log(`\n========================================`);
        console.log(`   ğŸš€ SERVICE RUNNING STATUS`);
        console.log(`   â° Time: ${new Date().toLocaleString()}`);
        console.log(`========================================`);
        
        console.log(`\nğŸ“‚ [Dufs File Manager]`);
        console.log(`   â–º Local: http://localhost:${DUFS_PORT}`);
        if (IS_DUFS_TUNNEL_ENABLED && dufsPublicUrl) {
            console.log(`   â–º Public: ${dufsPublicUrl}`);
        } else if (IS_DUFS_TUNNEL_ENABLED) {
            console.log(`   â–º Public: (Initializing...)`);
        }

        console.log(`\nğŸ³ [HubProxy Docker Mirror]`);
        console.log(`   â–º Local: http://localhost:${HUBPROXY_PORT}`);
        if (IS_HUBPROXY_TUNNEL_ENABLED && hubProxyPublicUrl) {
            console.log(`   â–º Public: ${hubProxyPublicUrl}`);
        } else if (IS_HUBPROXY_TUNNEL_ENABLED) {
            console.log(`   â–º Public: (Initializing...)`);
        }
        console.log(`\n========================================\n`);
    };

    // --- 5. å¯åŠ¨ååˆæ¬¡æ±‡æ€» (ä¿®æ”¹ä¸º async) ---
    setTimeout(async () => {
        // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
        if (fs.existsSync(TEMP_DIR)) fs.rmSync(TEMP_DIR, { recursive: true, force: true });
        
        printServiceStatus();

        // æ–°å¢: æ¨é€ Gotify é€šçŸ¥ (IS_GOTIFY_ENABLED ç°åœ¨æ˜¯ç¡¬ç¼–ç çš„ true)
        if (IS_GOTIFY_ENABLED) {
            try {
                await pushToGotify('Service Status Report', dufsPublicUrl, hubProxyPublicUrl);
            } catch (e) {
                // pushToGotifyå†…éƒ¨å·²å¤„ç†é”™è¯¯æ‰“å°ï¼Œè¿™é‡Œä»…æ•è·
            }
        }

    }, 30000);

    // --- 6. å®šæ—¶ä»»åŠ¡ ---
    
    // æ¯ 1 å°æ—¶æ¸…å±å¹¶æ˜¾ç¤ºçŠ¶æ€ (3600000 ms)
    setInterval(printServiceStatus, 3600000);

    // æ¯ 5 åˆ†é’Ÿç®€å•å¿ƒè·³ (ä¸æ›¿ä»£çŠ¶æ€æ¿ï¼Œåªæ˜¯ä¸ºäº†ä¿æ´»æ—¥å¿—)
    setInterval(() => console.log('ğŸ’— Keep alive', new Date().toISOString()), 300000);

})();
// END OF FILE
