const http = require('http');
const https = require('https');
const fs = require('fs');
const path = require('path');
const { spawn } = require('child_process');
const { URL } = require('url');

// ==============================================================================
//   1. ç›®å½•ä¸Žæ–‡ä»¶è·¯å¾„é…ç½® (Paths & Files)
// ==============================================================================
const ROOT_DIR = __dirname;
const TEMP_DIR = path.join(ROOT_DIR, 'tmp');
const SHARE_DIR = path.join(ROOT_DIR, 'share');

// å¯æ‰§è¡Œæ–‡ä»¶è·¯å¾„ (Executables)
const DUFS_EXEC = path.join(TEMP_DIR, 'dufs');
const HUBPROXY_EXEC = path.join(TEMP_DIR, 'hub_app');
const CLOUDFLARED_EXEC = path.join(TEMP_DIR, 'cloudflared');

// åŽ‹ç¼©åŒ…è·¯å¾„ (Archives)
const DUFS_ARCHIVE = path.join(TEMP_DIR, 'dufs.tar.gz');
const HUBPROXY_ARCHIVE = path.join(TEMP_DIR, 'hub.tar.gz');

// ==============================================================================
//   2. æœåŠ¡ç«¯å£é…ç½® (Port Configuration)
// ==============================================================================
// Dufs ç«¯å£ (è¯»å–çŽ¯å¢ƒå˜é‡æˆ–é»˜è®¤ 3000)
const DUFS_PORT = parseInt(process.env.SERVER_PORT || process.env.PORT || 3000); 
// HubProxy ç«¯å£ (Dufs ç«¯å£ + 2)
const HUBPROXY_PORT = DUFS_PORT + 2; 

// ==============================================================================
//   3. å¤–éƒ¨èµ„æºé“¾æŽ¥ (External URLs)
// ==============================================================================
const CLOUDFLARED_URL = 'https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64';

// ==============================================================================
//   4. åŠŸèƒ½å¼€å…³ä¸Žéš§é“é…ç½® (Hardcoded Toggles & Config)
// ==============================================================================
// âš ï¸ æ‰€æœ‰åŠŸèƒ½å¼€å…³ç¡¬ç¼–ç ä¸º true
const IS_CLOUDFLARED_ENABLED = true;
const IS_DUFS_TUNNEL_ENABLED = true;
const IS_HUBPROXY_TUNNEL_ENABLED = true;
const IS_GOTIFY_ENABLED = true;

// éš§é“å’Œé€šçŸ¥é…ç½® (ç¡¬ç¼–ç ä¸ºç©ºæˆ–å ä½ç¬¦ï¼Œåªä¼šå¯ç”¨ä¸´æ—¶ Argo éš§é“)
const DUFS_TUNNEL_TOKEN = '';
const DUFS_TUNNEL_DOMAIN = '';
const HUBPROXY_TUNNEL_TOKEN = '';
const HUBPROXY_TUNNEL_DOMAIN = '';
const GOTIFY_URL = 'https://gotify.uptk.netlib.re/'; // è¯·æ›¿æ¢ä¸ºä½ çš„ Gotify åœ°å€
const GOTIFY_TOKEN = 'An7sTEqqrRdXYwn'; // è¯·æ›¿æ¢ä¸ºä½ çš„ Gotify Token
const GOTIFY_PRIORITY = 5;

// ==============================================================================
//   5. åˆå§‹åŒ–çŽ¯å¢ƒ (Initialization)
// ==============================================================================
if (!fs.existsSync(SHARE_DIR)) { try { fs.mkdirSync(SHARE_DIR, { recursive: true }); } catch (e) {} }

// ==============================================================================
//   6. å·¥å…·å‡½æ•° (Helper Functions)
// ==============================================================================

/**
 * ä¸‹è½½æ–‡ä»¶ (å†…ç½® http/https)
 */
const downloadResource = (url, destination) => new Promise((resolve, reject) => {
    const protocol = url.startsWith('https') ? https : http;
    const request = protocol.get(url, res => {
        if (res.statusCode === 301 || res.statusCode === 302) {
            if (!res.headers.location) return reject('No redirect location found');
            console.log(`âž¡ï¸ Redirecting to: ${res.headers.location}`);
            return downloadResource(res.headers.location, destination).then(resolve).catch(reject);
        }
        if (res.statusCode !== 200) return reject(`Download failed. Status: ${res.statusCode}`);
        
        const fileStream = fs.createWriteStream(destination);
        res.pipe(fileStream);
        fileStream.on('finish', () => fileStream.close(resolve));
    }).on('error', reject).setTimeout(30000, () => { request.destroy(); reject('Download timeout'); });
});

/**
 * è§£åŽ‹ tar.gz (å†…ç½® child_process è°ƒç”¨ tar)
 */
const extractTarGz = (archivePath, targetDir, expectedBinName, finalBinPath) => new Promise((resolve, reject) => {
    if (!fs.existsSync(archivePath)) return reject(`Archive not found: ${archivePath}`);

    console.log(`ðŸ“¦ Extracting ${path.basename(archivePath)}...`);
    if (!fs.existsSync(targetDir)) fs.mkdirSync(targetDir, { recursive: true });
    
    const tar = spawn('tar', ['-xzf', archivePath, '-C', targetDir]);

    tar.on('close', (code) => {
        if (code !== 0) return reject(`tar process failed with code ${code}. Check if 'tar' is installed.`);
        
        const findExecutable = (dir, filename) => {
            try {
                for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
                    const fullPath = path.join(dir, entry.name);
                    if (entry.isDirectory()) {
                        const result = findExecutable(fullPath, filename);
                        if (result) return result;
                    } else if (entry.name === filename || entry.name.startsWith(filename + '-')) {
                        return fullPath;
                    }
                }
            } catch (e) { }
            return null;
        };

        const foundPath = findExecutable(targetDir, expectedBinName);
        if (foundPath) {
            if (foundPath !== finalBinPath) {
                fs.renameSync(foundPath, finalBinPath);
            }
            fs.chmodSync(finalBinPath, 0o755);
            resolve(finalBinPath);
        } else {
            reject(`Executable ${expectedBinName} not found after extraction.`);
        }
    });
    tar.on('error', (err) => reject(`Failed to run tar: ${err.message}. Check if 'tar' is installed.`));
});

/**
 * è¿œç¨‹èŽ·å–æœ€æ–° Dufs URL
 */
const fetchDufsLatestUrl = () => new Promise((resolve) => {
    const fallback = 'https://github.com/sigoden/dufs/releases/download/v0.43.0/dufs-v0.43.0-x86_64-unknown-linux-musl.tar.gz';
    https.get('https://github.com/sigoden/dufs/releases/latest', (res) => {
        try {
            const location = res.headers.location;
            const versionTag = location ? path.basename(location) : 'v0.43.0';
            const versionNum = versionTag.replace('v', '');
            resolve(`https://github.com/sigoden/dufs/releases/download/${versionTag}/dufs-v${versionNum}-x86_64-unknown-linux-musl.tar.gz`);
        } catch (e) { resolve(fallback); }
    }).on('error', () => resolve(fallback));
});

/**
 * è¿œç¨‹èŽ·å–æœ€æ–° HubProxy URL
 */
const fetchHubProxyUrl = () => new Promise((resolve) => {
    const fallback = 'https://github.com/sky22333/hubproxy/releases/download/v1.1.9/hubproxy-v1.1.9-linux-amd64.tar.gz';
    const req = https.get('https://github.com/sky22333/hubproxy/releases/latest', (res) => {
        try {
            if (res.statusCode === 200 || res.statusCode === 302) {
                const location = res.headers.location;
                if (location) {
                    const tag = path.basename(location);
                    resolve(`https://github.com/sky22333/hubproxy/releases/download/${tag}/hubproxy-${tag}-linux-amd64.tar.gz`);
                } else { resolve(fallback); }
            } else { resolve(fallback); }
        } catch (e) { resolve(fallback); }
    });
    req.on('error', () => resolve(fallback));
    req.setTimeout(5000, () => { req.destroy(); resolve(fallback); });
});

/**
 * æŽ¨é€çŠ¶æ€åˆ° Gotify (å†…ç½® http/https)
 */
const pushToGotify = (dufsUrl, hubUrl) => new Promise((resolve, reject) => {
    // æ£€æŸ¥ç¡¬ç¼–ç çš„é…ç½®æ˜¯å¦æ˜¯å ä½ç¬¦
    if (!GOTIFY_URL || !GOTIFY_TOKEN || GOTIFY_TOKEN.includes('YOUR_GOTIFY')) {
        console.log('âš ï¸ Gotify URL/Token is missing or is the placeholder. Skipping notification.');
        return resolve();
    }

    // æž„é€ æ¶ˆæ¯ä½“
    const message = [
        "ðŸš€ æœåŠ¡å¯åŠ¨æˆåŠŸï¼",
        `\n[Dufs æ–‡ä»¶æœåŠ¡]`,
        `æœ¬åœ°: http://localhost:${DUFS_PORT}`,
        `å…¬ç½‘: ${dufsUrl || 'N/A (éš§é“æ­£åœ¨åˆå§‹åŒ–)'}`,
        `\n[HubProxy é•œåƒ]`,
        `æœ¬åœ°: http://localhost:${HUBPROXY_PORT}`,
        `å…¬ç½‘: ${hubUrl || 'N/A (éš§é“æ­£åœ¨åˆå§‹åŒ–)'}`,
        `\nâ° Time: ${new Date().toLocaleString()}`
    ].join('\n');

    try {
        const url = new URL(GOTIFY_URL);
        const gotifyHost = url.hostname;
        const gotifyPort = url.port || (url.protocol === 'https:' ? 443 : 80);
        const gotifyProtocol = url.protocol.startsWith('https') ? https : http;
        const gotifyPath = url.pathname.replace(/\/$/, '') + '/message';
        
        const postData = JSON.stringify({
            title: `æœåŠ¡çŠ¶æ€æŠ¥å‘Š`,
            message: message,
            priority: GOTIFY_PRIORITY
        });

        const req = gotifyProtocol.request({
            hostname: gotifyHost,
            port: gotifyPort,
            path: `${gotifyPath}?token=${GOTIFY_TOKEN}`, 
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Content-Length': Buffer.byteLength(postData)
            }
        }, res => {
            if (res.statusCode >= 200 && res.statusCode < 300) {
                console.log('âœ… Gotify notification sent.');
                resolve();
            } else {
                let responseBody = '';
                res.on('data', chunk => responseBody += chunk);
                res.on('end', () => {
                    console.error(`âŒ Gotify failed. Status: ${res.statusCode}. Response: ${responseBody}`);
                    resolve(); 
                });
            }
        });

        req.on('error', (e) => {
            console.error(`âŒ Gotify connection error: ${e.message}`);
            resolve();
        });
        
        req.write(postData);
        req.end();

    } catch (e) {
        console.error('âŒ Gotify URL/Token configuration error:', e.message);
        resolve();
    }
});

// ==============================================================================
//   7. ä¸»ç¨‹åºé€»è¾‘ (Main Execution)
// ==============================================================================

(async () => {
    let dufsPublicUrl = '';
    let hubProxyPublicUrl = '';

    // æ¸…ç†å¹¶åˆ›å»ºä¸´æ—¶ç›®å½•
    if (fs.existsSync(TEMP_DIR)) fs.rmSync(TEMP_DIR, { recursive: true, force: true });
    fs.mkdirSync(TEMP_DIR, { recursive: true });

    try {
        console.log('â³ Initializing services...');

        // --- 1. ä¸‹è½½é˜¶æ®µ ---
        const [dufsDownloadUrl, hubProxyDownloadUrl] = await Promise.all([
            fetchDufsLatestUrl(),
            fetchHubProxyUrl()
        ]);

        const downloadTasks = [
            downloadResource(dufsDownloadUrl, DUFS_ARCHIVE),
            downloadResource(hubProxyDownloadUrl, HUBPROXY_ARCHIVE)
        ];

        // æ—¢ç„¶ IS_CLOUDFLARED_ENABLED æ˜¯ trueï¼Œå°±ä¸‹è½½
        if (IS_CLOUDFLARED_ENABLED) { 
            console.log(`â¬ Downloading Cloudflared...`);
            downloadTasks.push(downloadResource(CLOUDFLARED_URL, CLOUDFLARED_EXEC));
        }

        await Promise.all(downloadTasks);

        // --- 2. è§£åŽ‹ä¸Žå®‰è£…é˜¶æ®µ ---
        await Promise.all([
            extractTarGz(DUFS_ARCHIVE, TEMP_DIR, 'dufs', DUFS_EXEC),
            extractTarGz(HUBPROXY_ARCHIVE, TEMP_DIR, 'hubproxy', HUBPROXY_EXEC)
                .catch(e => console.warn(`âš ï¸ HubProxy extraction failed: ${e.message}`)) 
        ]);

        if (IS_CLOUDFLARED_ENABLED && fs.existsSync(CLOUDFLARED_EXEC)) {
            fs.chmodSync(CLOUDFLARED_EXEC, 0o755);
        }


        // --- 3. å¯åŠ¨æœåŠ¡é˜¶æ®µ ---

        // å¯åŠ¨ Dufs
        console.log(`ðŸ“‚ Starting Dufs on port ${DUFS_PORT}...`);
        spawn(DUFS_EXEC, [SHARE_DIR, '-p', String(DUFS_PORT), '-A', '--bind', '0.0.0.0'], {
            stdio: 'inherit',
            detached: true
        }).unref();

        // å¯åŠ¨ HubProxy
        if (fs.existsSync(HUBPROXY_EXEC)) {
            console.log(`ðŸ³ Starting HubProxy on port ${HUBPROXY_PORT}...`);
            spawn(HUBPROXY_EXEC, ['--addr', `:${HUBPROXY_PORT}`], {
                stdio: 'ignore',
                detached: true,
                env: { ...process.env, PORT: String(HUBPROXY_PORT), SERVER_PORT: String(HUBPROXY_PORT) }
            }).unref();
        }

        // --- 4. å¯åŠ¨éš§é“é˜¶æ®µ (Argo) ---
        if (IS_CLOUDFLARED_ENABLED && fs.existsSync(CLOUDFLARED_EXEC)) {
            
            // Dufs éš§é“ (ç¡¬ç¼–ç ä¸º true)
            if (IS_DUFS_TUNNEL_ENABLED) {
                // TOKEN/DOMAIN ä¸ºç©ºï¼Œèµ°ä¸´æ—¶éš§é“
                if (DUFS_TUNNEL_TOKEN && DUFS_TUNNEL_DOMAIN) {
                    dufsPublicUrl = `https://${DUFS_TUNNEL_DOMAIN}`;
                    spawn(CLOUDFLARED_EXEC, ['tunnel', 'run', '--token', DUFS_TUNNEL_TOKEN], { stdio: 'ignore', detached: true }).unref();
                    console.log(`ðŸ”— Dufs Tunnel (Fixed): ${dufsPublicUrl}`);
                } else {
                    const tunnel = spawn(CLOUDFLARED_EXEC, ['tunnel', '--url', `http://localhost:${DUFS_PORT}`, '--no-autoupdate'], { stdio: ['ignore', 'ignore', 'pipe'] });
                    tunnel.stderr.on('data', d => {
                        const match = d.toString().match(/(https:\/\/[a-zA-Z0-9-]+\.trycloudflare\.com)/);
                        if (match) { dufsPublicUrl = match[1]; console.log(`ðŸ”— Dufs Tunnel (Temp): ${dufsPublicUrl}`); }
                    });
                }
            }

            // HubProxy éš§é“ (ç¡¬ç¼–ç ä¸º true)
            if (IS_HUBPROXY_TUNNEL_ENABLED) {
                // TOKEN/DOMAIN ä¸ºç©ºï¼Œèµ°ä¸´æ—¶éš§é“
                if (HUBPROXY_TUNNEL_TOKEN && HUBPROXY_TUNNEL_DOMAIN) {
                    hubProxyPublicUrl = `https://${HUBPROXY_TUNNEL_DOMAIN}`;
                    spawn(CLOUDFLARED_EXEC, ['tunnel', 'run', '--token', HUBPROXY_TUNNEL_TOKEN], { stdio: 'ignore', detached: true }).unref();
                    console.log(`ðŸ”— HubProxy Tunnel (Fixed): ${hubProxyPublicUrl}`);
                } else {
                    const tunnel = spawn(CLOUDFLARED_EXEC, ['tunnel', '--url', `http://localhost:${HUBPROXY_PORT}`, '--no-autoupdate'], { stdio: ['ignore', 'ignore', 'pipe'] });
                    tunnel.stderr.on('data', d => {
                        const match = d.toString().match(/(https:\/\/[a-zA-Z0-9-]+\.trycloudflare\.com)/);
                        if (match) { hubProxyPublicUrl = match[1]; console.log(`ðŸ”— HubProxy Tunnel (Temp): ${hubProxyPublicUrl}`); }
                    });
                }
            }
        }

    } catch (e) {
        console.error('âŒ Critical Error:', e);
        process.exit(1);
    }

    // --- 5. çŠ¶æ€æ‰“å°ä¸Ž Gotify æŽ¨é€ ---
    const printServiceStatus = async (isFirstRun = false) => {
        process.stdout.write('\033c');
        
        console.log(`\n========================================`);
        console.log(`   ðŸš€ SERVICE RUNNING STATUS`);
        console.log(`   â° Time: ${new Date().toLocaleString()}`);
        console.log(`========================================`);
        
        console.log(`\nðŸ“‚ [Dufs File Manager]`);
        console.log(`   â–º Local: http://localhost:${DUFS_PORT}`);
        if (IS_DUFS_TUNNEL_ENABLED) {
            console.log(`   â–º Public: ${dufsPublicUrl || '(Initializing...)'}`);
        }

        console.log(`\nðŸ³ [HubProxy Docker Mirror]`);
        console.log(`   â–º Local: http://localhost:${HUBPROXY_PORT}`);
        if (IS_HUBPROXY_TUNNEL_ENABLED) {
            console.log(`   â–º Public: ${hubProxyPublicUrl || '(Initializing...)'}`);
        }
        console.log(`\n========================================\n`);

        // ä»…åœ¨é¦–æ¬¡æŽ¨é€ Gotify
        if (isFirstRun && IS_GOTIFY_ENABLED) { 
            try {
                await pushToGotify(dufsPublicUrl, hubProxyPublicUrl);
            } catch (e) {}
        }
    };
    
    // å¯åŠ¨åŽåˆæ¬¡æ±‡æ€» (30ç§’å»¶è¿Ÿç»™ä¸´æ—¶éš§é“èŽ·å– URL)
    setTimeout(async () => {
        if (fs.existsSync(TEMP_DIR)) fs.rmSync(TEMP_DIR, { recursive: true, force: true });
        await printServiceStatus(true); // ä¼ å…¥ true è¡¨ç¤ºé¦–æ¬¡æŽ¨é€ Gotify
    }, 30000);

    // å®šæ—¶ä»»åŠ¡
    setInterval(() => printServiceStatus(false), 3600000); // æ¯ 1 å°æ—¶æ˜¾ç¤ºçŠ¶æ€
    setInterval(() => console.log('ðŸ’— Keep alive', new Date().toISOString()), 300000);
})();
// END OF FILE
