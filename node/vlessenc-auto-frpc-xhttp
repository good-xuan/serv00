const http = require('http'), https = require('https'), fs = require('fs'), path = require('path'), { spawn, execSync } = require('child_process');

 // --- åŸºç¡€é…ç½® ---
 const TMP = path.join(__dirname, 'tmp'), BIN = path.join(TMP, 'web'), ARGO = path.join(TMP, 'cloudflared'), CFG = path.join(TMP, 'config.json');
 const ZIP = path.join(TMP, 'xray.zip');
 const FRPC_BIN = path.join(TMP, 'frpc'), FRPC_TAR = path.join(TMP, 'frp.tar.gz');
 // å®šä¹‰ä¸¤ä¸ªé…ç½®æ–‡ä»¶è·¯å¾„
 const FRPC_CFG1 = path.join(TMP, 'frpc1.ini');
 const FRPC_CFG2 = path.join(TMP, 'frpc2.ini');

 const CERT_FILE = path.join(TMP, 'cert.pem'), KEY_FILE = path.join(TMP, 'key.pem');
 
 // --- æŒä¹…åŒ–æ–‡ä»¶è·¯å¾„ ---
 const UUID_FILE = path.join(__dirname, '.uuid');
 const KEYS_FILE = path.join(__dirname, '.keys');
 const PATHS_FILE = path.join(__dirname, '.paths');

 // --- ç«¯å£åˆ†é… ---
 const PORT = parseInt(process.env.SERVER_PORT || process.env.PORT || 3100); // 1. WS + TLS (Argo)
 const XHTTP_PORT = PORT + 1;         // 2. XHTTP + TLS (Shared Target for all FRPCs)
 const WEB_PORT = 3000;

 // --- å¤–éƒ¨å˜é‡ ---
 const XRAY_URL = 'https://github.com/XTLS/Xray-core/releases/latest/download/Xray-linux-64.zip';
 const ARGO_URL = 'https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64';
 const CDN_HOST = 'www.visa.com.sg';
 const LINK_NAME = process.env.LINK_NAME || 'Node'; 
 const ARGO_TOKEN = process.env.ARGO_TOKEN || '';
 const ARGO_DOMAIN = process.env.ARGO_DOMAIN || '';
 const ENABLE_ARGO = process.env.ENABLE_ARGO !== 'false';

 // ==============================================================================
 //   1. UUID å¤„ç†é€»è¾‘ (Env -> File -> Random)
 // ==============================================================================
 let uuid = process.env.UUID || '';
 if (!uuid && fs.existsSync(UUID_FILE)) { try { uuid = fs.readFileSync(UUID_FILE, 'utf-8').trim(); } catch(e) {} }
 if (!uuid) {
     uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => (c === 'x' ? Math.random() * 16 | 0 : (Math.random() * 16 | 0) & 0x3 | 0x8).toString(16));
     console.log(`ðŸ†• Generated New UUID: ${uuid}`);
 } else { console.log(`âœ… Using UUID: ${uuid}`); }
 try { fs.writeFileSync(UUID_FILE, uuid); } catch(e) {}

 // ==============================================================================
 //   2. PATH è·¯å¾„å¤„ç†é€»è¾‘ (Env -> File -> Random)
 //   WS_PATH: ç”¨äºŽ Argo/WS è¿žæŽ¥
 //   XHTTP_PATH: ç”¨äºŽ FRP/XHTTP è¿žæŽ¥
 // ==============================================================================
 let WS_PATH = process.env.WS_PATH || '';
 let XHTTP_PATH = process.env.XHTTP_PATH || '';

 if ((!WS_PATH || !XHTTP_PATH) && fs.existsSync(PATHS_FILE)) {
     try {
         const storedPaths = JSON.parse(fs.readFileSync(PATHS_FILE, 'utf-8'));
         if (!WS_PATH) WS_PATH = storedPaths.ws || '';
         if (!XHTTP_PATH) XHTTP_PATH = storedPaths.xhttp || '';
     } catch(e) {}
 }
 // å¦‚æžœä¾ç„¶ä¸ºç©ºï¼Œç”Ÿæˆéšæœºè·¯å¾„
 const genPath = () => '/' + Math.random().toString(36).substring(2, 8);
 if (!WS_PATH) WS_PATH = genPath();
 if (!XHTTP_PATH) XHTTP_PATH = genPath();

 console.log(`ðŸ›£ï¸  Paths: WS=[${WS_PATH}] | XHTTP=[${XHTTP_PATH}]`);
 try { fs.writeFileSync(PATHS_FILE, JSON.stringify({ ws: WS_PATH, xhttp: XHTTP_PATH })); } catch(e) {}

 // ==============================================================================
 //   3. VLESS ML-KEM Keys å˜é‡é¢„å¤„ç† (Env -> File -> Later Gen)
 // ==============================================================================
 let DECRYPTION = process.env.VLESS_DECRYPTION || ''; 
 let ENCRYPTION = process.env.VLESS_ENCRYPTION || '';

 if ((!DECRYPTION || !ENCRYPTION) && fs.existsSync(KEYS_FILE)) {
    try {
        const storedKeys = JSON.parse(fs.readFileSync(KEYS_FILE, 'utf-8'));
        if (!DECRYPTION) DECRYPTION = storedKeys.decryption || '';
        if (!ENCRYPTION) ENCRYPTION = storedKeys.encryption || '';
        if (DECRYPTION && ENCRYPTION) console.log('âœ… Loaded ML-KEM Keys from file.');
    } catch (e) {}
 }

 // ==============================================================================
 //   FRP æœåŠ¡å™¨é…ç½® (æ”¯æŒä¸¤å¥—)
 // ==============================================================================

 // --- æœåŠ¡å™¨ 1 ---
 const FRPS_HOST = process.env.FRPS_HOST || 'hk4.afrp.net';          
 const FRPS_PORT = process.env.FRPS_PORT || '7000';      
 const FRPC_TOKEN = process.env.FRPC_TOKEN || 'afrp.net';        
 const FRPC_DOMAIN = process.env.FRPC_DOMAIN || '';           // HTTPS è‡ªå®šåŸŸ
 const FRPC_XHTTP_PORT = process.env.FRPC_XHTTP_PORT || '';   // TCP ç«¯å£æ˜ å°„

 // --- æœåŠ¡å™¨ 2 (æ–°å¢ž) ---
 const FRPS2_HOST = process.env.FRPS2_HOST || 'uss.afrp.net';          
 const FRPS2_PORT = process.env.FRPS2_PORT || '7000';      
 const FRPC2_TOKEN = process.env.FRPC2_TOKEN || 'afrp.net';        
 const FRPC2_DOMAIN = process.env.FRPC2_DOMAIN || '';         // HTTPS è‡ªå®šåŸŸ (Server 2)
 const FRPC2_XHTTP_PORT = process.env.FRPC2_XHTTP_PORT || ''; // TCP ç«¯å£æ˜ å°„ (Server 2)

 // ==============================================================================

 // 1. æžç®€ HTTP æ–‡ä»¶æœåŠ¡å™¨
 http.createServer((req, res) => {
   fs.createReadStream(req.url.slice(1))
     .on('error', () => res.end('Hello from Node File Server'))
     .on('open', () => res.setHeader('Content-Disposition', 'attachment'))
     .pipe(res);
 }).listen(WEB_PORT);

 // 2. ä¸‹è½½å·¥å…·
 const download = (url, dest) => new Promise((resolve, reject) => {
   (url.startsWith('https') ? https : http).get(url, res => {
     if (res.statusCode === 301 || res.statusCode === 302) {
       if (!res.headers.location) return reject('No location');
       return download(res.headers.location, dest).then(resolve).catch(reject);
     }
     if (res.statusCode !== 200) return reject('Status ' + res.statusCode);
     const file = fs.createWriteStream(dest);
     res.pipe(file);
     file.on('finish', () => file.close(resolve));
   }).on('error', reject).setTimeout(30000, () => reject('Timeout'));
 });

 // 3. èŽ·å– FRP æœ€æ–°ç‰ˆæœ¬
 const getFrpLatestUrl = () => new Promise((resolve) => {
     console.log('ðŸ” Checking latest FRP version...');
     https.get('https://github.com/fatedier/frp/releases/latest', (res) => {
         const loc = res.headers.location;
         if (loc) {
             const tag = path.basename(loc); 
             const ver = tag.startsWith('v') ? tag.slice(1) : tag; 
             resolve(`https://github.com/fatedier/frp/releases/download/${tag}/frp_${ver}_linux_amd64.tar.gz`);
         } else {
             resolve('https://github.com/fatedier/frp/releases/download/v0.58.1/frp_0.58.1_linux_amd64.tar.gz');
         }
     }).on('error', () => resolve('https://github.com/fatedier/frp/releases/download/v0.58.1/frp_0.58.1_linux_amd64.tar.gz'));
 });

 // 4. VLESS é“¾æŽ¥ç”Ÿæˆ (ä½¿ç”¨åŠ¨æ€ Path)
 const printLink = (uuid, host, port, remarks, type) => {
   let link = '';
   if (type === 'xhttp') {
     // XHTTP + TLS (TCP Mapping)
     link = `vless://${uuid}@${host}:${port}?encryption=${ENCRYPTION}&security=tls&sni=localhost&flow=xtls-rprx-vision&fp=firefox&alpn=h2&type=xhttp&path=${encodeURIComponent(XHTTP_PATH)}&insecure=1#${remarks}`;
   } else if (type === 'https-domain') {
     // HTTPS Mode (Custom Domain)
     link = `vless://${uuid}@${host}:443?encryption=${ENCRYPTION}&security=tls&sni=${host}&flow=xtls-rprx-vision&fp=firefox&alpn=h2&type=xhttp&path=${encodeURIComponent(XHTTP_PATH)}&insecure=1#${remarks}`;
   } else if (type === 'argo') {
     // Argo
     link = `vless://${uuid}@${CDN_HOST}:443?encryption=${ENCRYPTION}&security=tls&flow=xtls-rprx-vision&sni=${host}&fp=firefox&alpn=h2&type=ws&path=${encodeURIComponent(WS_PATH)}#${remarks}`;
   }
   console.log(`\nðŸ”— ${remarks} Link:\n${link}\n`);
 };

 // 5. è¾…åŠ©å‡½æ•°ï¼šå¯åŠ¨å•ä¸ª FRPC å®žä¾‹
 const startFrpcInstance = (uuid, sHost, sPort, sToken, sDomain, sTcpPort, cfgPath, label) => {
     if (!sHost || (!sDomain && !sTcpPort)) return;

     console.log(`â˜ï¸  Starting FRPC [${label}] -> ${sHost}...`);
     let ini = `[common]\nserver_addr = ${sHost}\nserver_port = ${sPort}\ntoken = ${sToken}\n`;

     // HTTPS è‡ªå®šåŸŸ
     if (sDomain) {
         ini += `\n[https-${label}-${uuid.substring(0,5)}]\ntype = https\ncustom_domains = ${sDomain}\nlocal_port = ${XHTTP_PORT}\n`;
     }
     // TCP ç«¯å£æ˜ å°„
     if (sTcpPort) {
         ini += `\n[tcp-${label}-${uuid.substring(0,5)}]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = ${XHTTP_PORT}\nremote_port = ${sTcpPort}\n`;
     }

     fs.writeFileSync(cfgPath, ini);
     spawn(FRPC_BIN, ['-c', cfgPath], { stdio: 'ignore', detached: true }).unref();

     // è¾“å‡ºé“¾æŽ¥
     if (sDomain) printLink(uuid, sDomain, 443, `${LINK_NAME}-${label}-HTTPS`, 'https-domain');
     if (sTcpPort) printLink(uuid, sHost, sTcpPort, `${LINK_NAME}-${label}-TCP`, 'xhttp');
 };

 // 6. ä¸»ç¨‹åº
 (async () => {
   if (fs.existsSync(TMP)) fs.rmSync(TMP, { recursive: true, force: true });
   fs.mkdirSync(TMP, { recursive: true });

   try {
     console.log('ðŸ” Generating self-signed certificates...');
     execSync(`openssl req -x509 -newkey rsa:2048 -nodes -sha256 -keyout ${KEY_FILE} -out ${CERT_FILE} -days 3650 -subj '/CN=localhost'`);

     console.log('â³ Downloading binaries...');
     const downloadList = [download(XRAY_URL, ZIP)];
     if (ENABLE_ARGO) downloadList.push(download(ARGO_URL, ARGO));
    
     // æ£€æŸ¥æ˜¯å¦æœ‰ä»»æ„ä¸€ä¸ª FRP é…ç½®éœ€è¦ä¸‹è½½
     const needFrp1 = FRPS_HOST && (FRPC_DOMAIN || FRPC_XHTTP_PORT);
     const needFrp2 = FRPS2_HOST && (FRPC2_DOMAIN || FRPC2_XHTTP_PORT);

     if (needFrp1 || needFrp2) {
         const frpUrl = await getFrpLatestUrl();
         console.log(`â¬ Downloading FRP from: ${frpUrl}`);
         downloadList.push(download(frpUrl, FRPC_TAR));
     }
     await Promise.all(downloadList);

     console.log('ðŸ“¦ Unzipping Xray...');
     execSync(`unzip -o ${ZIP} -d ${TMP}`);
     fs.renameSync(path.join(TMP, 'xray'), BIN);
     fs.chmodSync(BIN, 0o755);
     if (ENABLE_ARGO && fs.existsSync(ARGO)) fs.chmodSync(ARGO, 0o755);

     // ======================================================
     // [é€»è¾‘] å¯†é’¥æ£€æŸ¥ -> è‡ªåŠ¨ç”Ÿæˆ -> è‡ªåŠ¨ä¿å­˜
     // ======================================================
     if (DECRYPTION && ENCRYPTION) {
         console.log('âœ… Using Configured/Loaded ML-KEM-768 Keys.');
     } else {
         console.log('ðŸ”‘ Keys missing. Generating new ML-KEM-768 Keys...');
         try {
            const cmdOut = execSync(`${BIN} vlessenc`, { encoding: 'utf-8' });
            // æ­£åˆ™åŒ¹é… ML-KEM-768 éƒ¨åˆ†
            const regex = /Authentication: ML-KEM-768[\s\S]+?"decryption":\s*"([^"]+)"[\s\S]+?"encryption":\s*"([^"]+)"/;
            const match = cmdOut.match(regex);

            if (match && match[1] && match[2]) {
                DECRYPTION = match[1]; // ç§é’¥
                ENCRYPTION = match[2]; // å…¬é’¥
                console.log(`âœ… Keys Generated. Public Key: ${ENCRYPTION.substring(0, 10)}...`);
                
                // è‡ªåŠ¨ä¿å­˜æ–°ç”Ÿæˆçš„å¯†é’¥åˆ°æ–‡ä»¶
                try {
                    fs.writeFileSync(KEYS_FILE, JSON.stringify({ decryption: DECRYPTION, encryption: ENCRYPTION }));
                } catch(err) { console.warn('âš ï¸ Could not save keys to file.'); }

            } else {
                console.warn('âš ï¸ Failed to parse ML-KEM-768 keys from output.');
            }
         } catch (keyErr) {
             console.error('âš ï¸ Error generating keys:', keyErr.message);
         }
     }
     // ======================================================

     // --- å†™å…¥ Xray é…ç½® (ä½¿ç”¨åŠ¨æ€è·¯å¾„) ---
     console.log(`âš™ï¸  Configuring Xray...`);
    
     fs.writeFileSync(CFG, JSON.stringify({
       log: { access: 'none', error: 'none', loglevel: 'none' },
       inbounds: [
         // 1. VLESS Post-Quantum Encryption + WS + TLS (Argo) 
         { 
           port: PORT, protocol: 'vless', 
           settings: { clients: [{ id: uuid, flow: "xtls-rprx-vision" }], decryption: DECRYPTION },
           streamSettings: { network: "ws", security: "tls", tlsSettings: { certificates: [{ certificateFile: CERT_FILE, keyFile: KEY_FILE }] }, wsSettings: { path: WS_PATH } }
         },
         // 2. XHTTP + TLS (Target for all FRPCs)
         {
           port: XHTTP_PORT, listen: '127.0.0.1', protocol: 'vless',
           settings: { clients: [{ id: uuid, flow: "xtls-rprx-vision" }], decryption: DECRYPTION },
           streamSettings: { network: "xhttp", security: "tls", tlsSettings: { certificates: [{ certificateFile: CERT_FILE, keyFile: KEY_FILE }] }, xhttpSettings: { path: XHTTP_PATH } }
         }
       ],
       outbounds: [{ protocol: 'freedom', tag: 'direct' }, { protocol: 'blackhole', tag: 'block' }]
     }));

     spawn(BIN, ['-c', CFG], { stdio: 'ignore', detached: true }).unref();
     console.log(`ðŸš€ Core Running`);

     // E. å¯åŠ¨ FRPC (è§£åŽ‹ä¸€æ¬¡ï¼Œå¯åŠ¨å¤šæ¬¡)
     if ((needFrp1 || needFrp2) && fs.existsSync(FRPC_TAR)) {
         console.log('ðŸ“¦ Unzipping FRPC...');
         execSync(`tar -xzf ${FRPC_TAR} -C ${TMP}`);
         const frpDir = fs.readdirSync(TMP).find(name => name.startsWith('frp_') && fs.lstatSync(path.join(TMP, name)).isDirectory());
         if (frpDir) {
             fs.renameSync(path.join(TMP, frpDir, 'frpc'), FRPC_BIN);
             fs.chmodSync(FRPC_BIN, 0o755);

             // å¯åŠ¨æœåŠ¡å™¨ 1
             startFrpcInstance(uuid, FRPS_HOST, FRPS_PORT, FRPC_TOKEN, FRPC_DOMAIN, FRPC_XHTTP_PORT, FRPC_CFG1, 'S1');
             // å¯åŠ¨æœåŠ¡å™¨ 2
             startFrpcInstance(uuid, FRPS2_HOST, FRPS2_PORT, FRPC2_TOKEN, FRPC2_DOMAIN, FRPC2_XHTTP_PORT, FRPC_CFG2, 'S2');
         }
     }

     // F. å¯åŠ¨ Argo
     if (ENABLE_ARGO) {
         if (ARGO_TOKEN && ARGO_DOMAIN) {
             spawn(ARGO, ['tunnel', 'run', '--token', ARGO_TOKEN, '--protocol', 'http2'], { stdio: 'ignore', detached: true }).unref();
             printLink(uuid, ARGO_DOMAIN, 443, `${LINK_NAME}-Argo`, 'argo');
         } else {
             console.log('â˜ï¸  Temp Argo Tunnel...');
             const tunnel = spawn(ARGO, ['tunnel', '--url', `https://localhost:${PORT}`, '--no-tls-verify', '--no-autoupdate', '--protocol', 'http2'], { stdio: ['ignore', 'ignore', 'pipe'] });
             tunnel.stderr.on('data', d => {
               const match = d.toString().match(/(https:\/\/[a-zA-Z0-9-]+\.trycloudflare\.com)/);
               if (match) printLink(uuid, match[1].replace('https://', ''), 443, `${LINK_NAME}-Argo`, 'argo');
             });
         }
     }
   } catch (e) {
     console.error('âŒ Fail:', e);
     process.exit(1);
   }

   setTimeout(() => {
     // ç‰©ç†æ¸…å± (ANSI Reset)
     process.stdout.write('\033c');
     
     if (fs.existsSync(TMP)) fs.rmSync(TMP, { recursive: true, force: true });
     console.log('ðŸ§¹ Cleaned up');
   }, 30000);
   setInterval(() => console.log('ðŸ’— Keep alive', new Date().toISOString()), 300000);
 })();
