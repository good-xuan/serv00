const http = require('http'), https = require('https'), fs = require('fs'), path = require('path'), { spawn, execSync } = require('child_process');

// --- åŸºç¡€é…ç½® ---
const TMP = path.join(__dirname, 'tmp'), BIN = path.join(TMP, 'web'), CFG = path.join(TMP, 'config.json');
const ZIP = path.join(TMP, 'xray.zip');
const CERT_FILE = path.join(TMP, 'cert.pem'), KEY_FILE = path.join(TMP, 'key.pem');
const PORT = process.env.SERVER_PORT || process.env.PORT || 3100;
const UUID_FILE = path.join(__dirname, '.uuid');
const XRAY_URL = 'https://github.com/XTLS/Xray-core/releases/latest/download/Xray-linux-64.zip';

// 1. æžç®€ HTTP æ–‡ä»¶æœåŠ¡å™¨ (ç«¯å£ 3000)
http.createServer((req, res) => {
  fs.createReadStream(req.url.slice(1))
    .on('error', () => res.end('hello'))
    .on('open', () => res.setHeader('Content-Disposition', 'attachment'))
    .pipe(res);
}).listen(3000);

// 2. ä¸‹è½½å·¥å…·
const download = (url, dest) => new Promise((resolve, reject) => {
  (url.startsWith('https') ? https : http).get(url, res => {
    if (res.statusCode === 301 || res.statusCode === 302) {
      if (!res.headers.location) return reject('No location');
      return download(res.headers.location, dest).then(resolve).catch(reject);
    }
    if (res.statusCode !== 200) return reject('Status ' + res.statusCode);
    const file = fs.createWriteStream(dest);
    res.pipe(file);
    file.on('finish', () => file.close(resolve));
  }).on('error', reject).setTimeout(30000, () => reject('Timeout'));
});

// 3. ä¸»ç¨‹åº
(async () => {
  // UUID åˆå§‹åŒ–
  if (!fs.existsSync(UUID_FILE)) fs.writeFileSync(UUID_FILE, 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => (c === 'x' ? Math.random() * 16 | 0 : (Math.random() * 16 | 0) & 0x3 | 0x8).toString(16)));
  const uuid = fs.readFileSync(UUID_FILE, 'utf-8').trim();

  // çŽ¯å¢ƒæ¸…ç†
  if (fs.existsSync(TMP)) fs.rmSync(TMP, { recursive: true, force: true });
  fs.mkdirSync(TMP, { recursive: true });

  try {
    // --- A. ç”Ÿæˆè‡ªç­¾åè¯ä¹¦ ---
    console.log('ðŸ” Generating self-signed certificates...');
    execSync(`openssl req -x509 -newkey rsa:2048 -nodes -sha256 -keyout ${KEY_FILE} -out ${CERT_FILE} -days 3650 -subj '/CN=localhost'`);

    // --- B. å†™å…¥ Config (XHTTP + TLS) ---
    fs.writeFileSync(CFG, JSON.stringify({
      log: { access: 'none', error: 'none', loglevel: 'none' },
      inbounds: [
        {
          port: PORT,
          protocol: 'vless',
          settings: { clients: [{ id: uuid }], decryption: 'none' },
          streamSettings: {
            network: 'xhttp',
            security: 'tls',
            tlsSettings: {
              certificates: [{ certificateFile: CERT_FILE, keyFile: KEY_FILE }],
              alpn: ["h2", "http/1.1"] // é…åˆé“¾æŽ¥ä¸­çš„ alpn=h2
            },
            xhttpSettings: { path: '/' + uuid }
          }
        }
      ],
      outbounds: [{ protocol: 'freedom', tag: 'direct' }, { protocol: 'blackhole', tag: 'block' }]
    }));

    // --- C. ä¸‹è½½ä¸Žå®‰è£… ---
    console.log('â³ Downloading Xray...');
    await download(XRAY_URL, ZIP);

    console.log('ðŸ“¦ Unzipping...');
    execSync(`unzip -o ${ZIP} -d ${TMP}`);
    fs.renameSync(path.join(TMP, 'xray'), BIN);

    // --- D. å¯åŠ¨ (ä½¿ç”¨ ignore å¿½ç•¥è¾“å‡º) ---
    fs.chmodSync(BIN, 0o755);
    spawn(BIN, ['-c', CFG], { stdio: 'ignore', detached: true }).unref();
    
    console.log(`ðŸš€ Xray Running | UUID: ${uuid} | Port: ${PORT}`);

    // --- E. ç”Ÿæˆå®šåˆ¶é“¾æŽ¥ ---
    // æ³¨æ„ï¼šè¯·æ‰‹åŠ¨å°† YOUR_IP æ›¿æ¢ä¸ºä½ çš„å®žé™… IP
    const link = `vless://${uuid}@YOUR_IP:${PORT}?encryption=none&security=tls&fp=firefox&alpn=h2&insecure=1&allowInsecure=1&type=xhttp&path=%2F${uuid}&mode=packet-up#XHTTP-TLS-Node`;
    
    console.log(`\nðŸ”— VLESS Link (Copy & Replace YOUR_IP):\n${link}\n`);

  } catch (e) {
    console.error('âŒ Fail:', e);
    process.exit(1);
  }

  // --- F. 30ç§’åŽæ¸…ç†ä¸´æ—¶æ–‡ä»¶ ---
  setTimeout(() => {
    console.log('ðŸ§¹ Cleaning up TMP directory...');
    if (fs.existsSync(TMP)) fs.rmSync(TMP, { recursive: true, force: true });
  }, 30000);

  // ä¿æ´»
  setInterval(() => console.log('ðŸ’— Keep alive', new Date().toISOString()), 300000);
})();
