const http = require('http'), https = require('https'), fs = require('fs'), path = require('path'), { spawn, execSync } = require('child_process');

// ==============================================================================
//   1. åŸºç¡€é…ç½®ä¸Žç«¯å£
// ==============================================================================
const TMP = path.join(__dirname, 'tmp');
const BIN = path.join(TMP, 'web');            // Xray Binary

// æ ¸å¿ƒç«¯å£å®šä¹‰ï¼šXray ä½¿ç”¨
const PORT = parseInt(process.env.SERVER_PORT || process.env.PORT || 3000); 

// é…ç½®æ–‡ä»¶ä¸Žèµ„æº
const CFG = path.join(TMP, 'config.json');
const ZIP = path.join(TMP, 'xray.zip');

// è¯ä¹¦æ–‡ä»¶è·¯å¾„
const CERT_FILE = path.join(TMP, 'cert.pem');
const KEY_FILE = path.join(TMP, 'key.pem');

// æŒä¹…åŒ–æ–‡ä»¶
const UUID_FILE = path.join(__dirname, '.uuid');
const KEYS_FILE = path.join(__dirname, '.keys');
const PATHS_FILE = path.join(__dirname, '.paths');

// å†…å­˜ä¸­å­˜å‚¨ç”Ÿæˆçš„é“¾æŽ¥
const SAVED_LINKS = [];

// ==============================================================================
//   2. å¤–éƒ¨å˜é‡ä¸ŽçŽ¯å¢ƒé…ç½®
// ==============================================================================
const XRAY_URL = 'https://github.com/XTLS/Xray-core/releases/latest/download/Xray-linux-64.zip';

// --- æ ¸å¿ƒåè®®é€‰æ‹© ---
// é€‰é¡¹: 'ws' (é»˜è®¤) æˆ– 'xhttp'ã€‚
const XRAY_PROTOCOL = process.env.XRAY_PROTOCOL || 'ws'; 

// --- æœåŠ¡å™¨åœ°å€ ---
// ç”¨äºŽç”Ÿæˆé“¾æŽ¥æ—¶çš„ Host åœ°å€ï¼Œå¦‚æžœä¸å¡«é»˜è®¤ 127.0.0.1
const SERVER_HOST = process.env.SERVER_IP || process.env.DOMAIN || '127.0.0.1';

// --- æ˜¾ç¤ºé…ç½® ---
const SHOW_LINKS = process.env.SHOW_LINKS === 'true'; 

// ==============================================================================
//   3. åˆå§‹åŒ– (UUID/è·¯å¾„/å¯†é’¥)
// ==============================================================================

// UUID
let uuid = process.env.UUID || '';
if (!uuid && fs.existsSync(UUID_FILE)) { try { uuid = fs.readFileSync(UUID_FILE, 'utf-8').trim(); } catch(e) {} }
if (!uuid) {
    uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => (c === 'x' ? Math.random() * 16 | 0 : (Math.random() * 16 | 0) & 0x3 | 0x8).toString(16));
}
try { fs.writeFileSync(UUID_FILE, uuid); } catch(e) {}

// Path
let WS_PATH = process.env.WS_PATH || '';
let XHTTP_PATH = process.env.XHTTP_PATH || '';
if ((!WS_PATH || !XHTTP_PATH) && fs.existsSync(PATHS_FILE)) {
    try {
        const storedPaths = JSON.parse(fs.readFileSync(PATHS_FILE, 'utf-8'));
        if (!WS_PATH) WS_PATH = storedPaths.ws || '';
        if (!XHTTP_PATH) XHTTP_PATH = storedPaths.xhttp || '';
    } catch(e) {}
}
const genPath = () => '/' + Math.random().toString(36).substring(2, 8);
if (!WS_PATH) WS_PATH = genPath();
if (!XHTTP_PATH) XHTTP_PATH = genPath();
try { fs.writeFileSync(PATHS_FILE, JSON.stringify({ ws: WS_PATH, xhttp: XHTTP_PATH })); } catch(e) {}

// Keys (VLESS REALITY/Encryption)
let DECRYPTION = process.env.VLESS_DECRYPTION || ''; 
let ENCRYPTION = process.env.VLESS_ENCRYPTION || '';
if ((!DECRYPTION || !ENCRYPTION) && fs.existsSync(KEYS_FILE)) {
   try {
       const storedKeys = JSON.parse(fs.readFileSync(KEYS_FILE, 'utf-8'));
       if (!DECRYPTION) DECRYPTION = storedKeys.decryption || '';
       if (!ENCRYPTION) ENCRYPTION = storedKeys.encryption || '';
   } catch (e) {}
}

// ==============================================================================
//   4. è¾…åŠ©å‡½æ•°
// ==============================================================================
const download = (url, dest) => new Promise((resolve, reject) => {
  (url.startsWith('https') ? https : http).get(url, res => {
    if (res.statusCode === 301 || res.statusCode === 302) {
      if (!res.headers.location) return reject('No location');
      return download(res.headers.location, dest).then(resolve).catch(reject);
    }
    if (res.statusCode !== 200) return reject('Status ' + res.statusCode);
    const file = fs.createWriteStream(dest);
    res.pipe(file);
    file.on('finish', () => file.close(resolve));
  }).on('error', reject).setTimeout(30000, () => reject('Timeout'));
});

// æ‰“å°é“¾æŽ¥ (é€šç”¨æ¨¡æ¿)
const printLink = (uuid, remarks) => {
  // ä½¿ç”¨çŽ¯å¢ƒå˜é‡ SERVER_HOST
  const host = SERVER_HOST; 
  const currentPath = XRAY_PROTOCOL === 'xhttp' ? XHTTP_PATH : WS_PATH;
  const currentType = XRAY_PROTOCOL === 'xhttp' ? 'xhttp' : 'ws';
  
  const link = `vless://${uuid}@${host}:${PORT}?encryption=${ENCRYPTION}&security=tls&sni=${host}&flow=xtls-rprx-vision&fp=firefox&alpn=h2&type=${currentType}&path=${encodeURIComponent(currentPath)}&insecure=1#${remarks}`;
  
  const output = `ðŸ”— ${remarks} Link:\n${link}`;
  console.log(`\n${output}\n`);
  SAVED_LINKS.push(output); 
};

// ==============================================================================
//   5. ä¸»ç¨‹åº
// ==============================================================================

(async () => {
  if (fs.existsSync(TMP)) fs.rmSync(TMP, { recursive: true, force: true });
  fs.mkdirSync(TMP, { recursive: true });

  try {
    console.log('â³ Downloading binaries...');
    // ä¸‹è½½ Xray
    await download(XRAY_URL, ZIP);

    // 1. Setup Xray
    console.log('ðŸ“¦ Unzipping Xray...');
    execSync(`unzip -o ${ZIP} -d ${TMP}`);
    
    // å¦‚æžœè§£åŽ‹å‡ºæ¥æ˜¯ç›´æŽ¥çš„ xray æ–‡ä»¶
    if (fs.existsSync(path.join(TMP, 'xray'))) {
        fs.renameSync(path.join(TMP, 'xray'), BIN);
    } else {
        // é˜²æ­¢ zip ç»“æž„ä¸åŒï¼ˆæœ‰äº›åœ¨ bin/xray ç›®å½•ä¸‹ï¼‰ï¼Œç®€å•æŸ¥æ‰¾ä¸€ä¸‹
        try {
             const findXray = (dir) => {
                const files = fs.readdirSync(dir, { withFileTypes: true });
                for (const f of files) {
                    const fp = path.join(dir, f.name);
                    if (f.isDirectory()) {
                        const res = findXray(fp);
                        if (res) return res;
                    } else if (f.name === 'xray') {
                        return fp;
                    }
                }
            };
            const found = findXray(TMP);
            if (found) fs.renameSync(found, BIN);
        } catch(e) {}
    }
    
    fs.chmodSync(BIN, 0o755);

    console.log('ðŸ” Generating certs using Xray...');
    try {
        const certJsonStr = execSync(`${BIN} tls cert`, { encoding: 'utf-8' });
        const certData = JSON.parse(certJsonStr);
        fs.writeFileSync(CERT_FILE, certData.certificate.join('\n'));
        fs.writeFileSync(KEY_FILE, certData.key.join('\n'));
        console.log('âœ… Certs generated successfully.');
    } catch (err) {
        console.error('âš ï¸ Xray cert generation failed, creating empty fallbacks.', err.message);
        if (!fs.existsSync(CERT_FILE)) fs.writeFileSync(CERT_FILE, '');
        if (!fs.existsSync(KEY_FILE)) fs.writeFileSync(KEY_FILE, '');
    }
    
    // Keys
    if (DECRYPTION && ENCRYPTION) {
        console.log('âœ… Using ML-KEM Keys.');
    } else {
        console.log('ðŸ”‘ Generating Keys...');
        try {
            const cmdOut = execSync(`${BIN} vlessenc`, { encoding: 'utf-8' });
            const match = cmdOut.match(/Authentication: ML-KEM-768[\s\S]+?"decryption":\s*"([^"]+)"[\s\S]+?"encryption":\s*"([^"]+)"/);
            if (match) {
                DECRYPTION = match[1]; ENCRYPTION = match[2];
                try { fs.writeFileSync(KEYS_FILE, JSON.stringify({ decryption: DECRYPTION, encryption: ENCRYPTION })); } catch(err) {}
            }
        } catch (keyErr) {}
    }
    
    // Configure Xray
    console.log(`âš™ï¸  Configuring Xray (${XRAY_PROTOCOL.toUpperCase()})...`);
    
    const wsSettings = { network: "ws", security: "tls", tlsSettings: { certificates: [{ certificateFile: CERT_FILE, keyFile: KEY_FILE }] }, wsSettings: { path: WS_PATH } };
    const xhttpSettings = { network: "xhttp", security: "tls", tlsSettings: { certificates: [{ certificateFile: CERT_FILE, keyFile: KEY_FILE }] }, xhttpSettings: { path: XHTTP_PATH } };
    
    const streamSettings = XRAY_PROTOCOL === 'xhttp' ? xhttpSettings : wsSettings;

    fs.writeFileSync(CFG, JSON.stringify({
        log: { access: 'none', error: 'none', loglevel: 'none' },
        inbounds: [
        { port: PORT, listen: '0.0.0.0', protocol: 'vless', settings: { clients: [{ id: uuid, flow: "xtls-rprx-vision" }], decryption: DECRYPTION }, streamSettings: streamSettings }
        ],
        outbounds: [{ protocol: 'freedom', tag: 'direct' }, { protocol: 'blackhole', tag: 'block' }]
    }));
    
    spawn(BIN, ['-c', CFG], { stdio: 'ignore', detached: true }).unref();
    console.log(`ðŸš€ Xray Running on ${PORT} (${XRAY_PROTOCOL})`);
    
    // ç”Ÿæˆé“¾æŽ¥
    printLink(uuid, `Node-Direct`);

  } catch (e) {
    console.error('âŒ Fail:', e);
    process.exit(1);
  }

  const showDetails = () => {
      if (SHOW_LINKS && SAVED_LINKS.length > 0) {
          console.log('\n--- Saved Links ---');
          SAVED_LINKS.forEach(link => console.log(link));
          console.log('-------------------\n');
      }
  };

  setTimeout(() => {
    process.stdout.write('\033c');
    if (fs.existsSync(TMP)) fs.rmSync(TMP, { recursive: true, force: true });
    console.log('ðŸ§¹ Cleaned up');
    showDetails();
  }, 30000);

  setInterval(() => {
    process.stdout.write('\033c');
    console.log(`\nðŸ•’ 6-Hour Report: ${new Date().toISOString()}`);
    showDetails();
  }, 21600000);

  setInterval(() => console.log('ðŸ’— Keep alive', new Date().toISOString()), 300000);
})();
