const http = require('http');
const https = require('https');
const fs = require('fs');
const path = require('path');
const os = require('os');
const { spawn } = require('child_process');

// ç®€åŒ–çš„ UUID ç”Ÿæˆå™¨
function generateUUID() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c == 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

// === é…ç½®å¸¸é‡ ===
const FILE_PATH = path.resolve(__dirname, 'tmp');
const WORK_PORT = process.env.SERVER_PORT || process.env.PORT || 3100;

// å›ºå®šçš„ä¸‹è½½åœ°å€ï¼ˆåªä¿ç•™ä¸€ä¸ªï¼‰
const DOWNLOAD_WEB = 'http://fi10.bot-hosting.net:20980/web';

// UUID æŒä¹…åŒ–
const uuidFilePath = path.join(__dirname, '.uuid');
let UUID;

try {
  UUID = fs.readFileSync(uuidFilePath, 'utf-8').trim();
  console.log('âœ… ä½¿ç”¨å·²å­˜åœ¨çš„ UUID:', UUID);
} catch (err) {
  UUID = generateUUID();
  fs.writeFileSync(uuidFilePath, UUID);
  console.log('ğŸ†• æ–°ç”Ÿæˆå¹¶ä¿å­˜äº† UUID:', UUID);
}

// åˆ›å»ºç›®å½•
function ensureDir(dir) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
    console.log(`ğŸ“ åˆ›å»ºç›®å½•: ${dir}`);
  } else {
    console.log(`ğŸ“ ç›®å½•å·²å­˜åœ¨: ${dir}`);
  }
}

// åˆ é™¤æ•´ä¸ª tmp æ–‡ä»¶å¤¹çš„å‡½æ•°
function cleanupTmpDir() {
  try {
    if (fs.existsSync(FILE_PATH)) {
      // é€’å½’åˆ é™¤æ•´ä¸ªç›®å½•
      fs.rmSync(FILE_PATH, { recursive: true, force: true });
      console.log(`ğŸ—‘ï¸ åˆ é™¤æ•´ä¸ª tmp ç›®å½•: ${FILE_PATH}`);
    }
  } catch (e) {
    console.warn(`âš ï¸ åˆ é™¤ç›®å½•å¤±è´¥: ${FILE_PATH}`, e.message);
  }
}

// ç”Ÿæˆé…ç½®æ–‡ä»¶
function generateConfig(uuid, port) {
  return {
    log: { access: 'none', error: 'none', loglevel: 'none' },
    inbounds: [
      {
        port,
        protocol: 'vless',
        settings: {
          clients: [{ id: uuid }],
          decryption: 'none',
          fallbacks: [
            { dest: 3001 },
            { path: "/index.html", dest: 3000 },
            { path: "/vless", dest: 3002 }
          ]
        }
      },
      {
        port: 3001,
        listen: "127.0.0.1",
        protocol: "vless",
        settings: { clients: [{ id: uuid }], decryption: "none" },
        streamSettings: { network: "xhttp", xhttpSettings: { path: "/xh" } }
      },
      {
        port: 3002,
        listen: "127.0.0.1",
        protocol: "vless",
        settings: { clients: [{ id: uuid }], decryption: "none" },
        streamSettings: { network: "ws", wsSettings: { path: "/vless" } }
      }
    ],
    dns: {
      servers: ["https+local://1.1.1.1/dns-query"],
      disableCache: true
    },
    outbounds: [
      { protocol: "freedom", tag: "direct", settings: { domainStrategy: "UseIPv4v6" } },
      { protocol: "blackhole", tag: "block" }
    ]
  };
}

const config = generateConfig(UUID, WORK_PORT);

// å¯åŠ¨æ ¸å¿ƒæœåŠ¡
async function startServer() {
  // å¯åŠ¨æ—¶æ¸…ç†æ—§çš„ tmp ç›®å½•
  cleanupTmpDir();
  
  // é‡æ–°åˆ›å»ºç›®å½•
  ensureDir(FILE_PATH);

  // å†™å…¥é…ç½®æ–‡ä»¶ï¼ˆåœ¨ç›®å½•åˆ›å»ºä¹‹åï¼‰
  fs.writeFileSync(path.join(FILE_PATH, 'config.json'), JSON.stringify(config, null, 2));
  console.log('âš™ï¸ é…ç½®æ–‡ä»¶å·²ç”Ÿæˆ');

  console.log(`ğŸ’» ä½¿ç”¨ AMD64 æ¶æ„`);

  try {
    await downloadFile("web", DOWNLOAD_WEB);
  } catch (err) {
    console.error("ğŸš¨ æ–‡ä»¶ä¸‹è½½å¤±è´¥:", err.message);
    return;
  }

  // æ·»åŠ æ‰§è¡Œæƒé™
  authorizeFiles(['./web']);

  // å¯åŠ¨ web æœåŠ¡
  try {
    const webProcess = spawn(path.join(FILE_PATH, 'web'), ['-c', path.join(FILE_PATH, 'config.json')], {
      stdio: 'ignore',
      detached: true
    });
    
    webProcess.unref();
    console.log('ğŸš€ web æœåŠ¡å·²å¯åŠ¨');
  } catch (err) {
    console.error("ğŸ’¥ å¯åŠ¨ web æœåŠ¡å‡ºé”™:", err.message);
  }

  // å»¶è¿Ÿæ¸…ç†ä¸´æ—¶æ–‡ä»¶å¤¹
  setTimeout(() => {
    cleanupTmpDir(); // 30ç§’ååˆ é™¤æ•´ä¸ª tmp ç›®å½•
  }, 30 * 1000);
}

// URL è§£æå‡½æ•°
function parseUrl(urlString) {
  const url = new URL(urlString);
  return {
    protocol: url.protocol,
    hostname: url.hostname,
    port: url.port,
    pathname: url.pathname + url.search
  };
}

// ç®€åŒ–çš„ä¸‹è½½å‡½æ•°ï¼šåªä»ä¸€ä¸ªåœ°å€ä¸‹è½½
function downloadFile(fileName, url) {
  return new Promise((resolve, reject) => {
    const filePath = path.join(FILE_PATH, fileName);
    
    console.log(`ğŸ“¥ æ­£åœ¨ä¸‹è½½: ${url}`);
    
    const urlParts = parseUrl(url);
    const client = urlParts.protocol === 'https:' ? https : http;
    
    const request = client.get(url, { timeout: 30000 }, (response) => {
      if (response.statusCode >= 200 && response.statusCode < 300) {
        const fileStream = fs.createWriteStream(filePath);
        
        response.pipe(fileStream);
        
        fileStream.on('finish', () => {
          fileStream.close();
          console.log(`âœ… æˆåŠŸä¸‹è½½: ${fileName}`);
          resolve(fileName);
        });
        
        fileStream.on('error', (err) => {
          try { fs.unlinkSync(filePath); } catch(e) {}
          console.error(`âŒ æ–‡ä»¶å†™å…¥å¤±è´¥:`, err.message);
          reject(new Error(`æ–‡ä»¶å†™å…¥å¤±è´¥: ${err.message}`));
        });
      } else {
        console.error(`âŒ HTTPé”™è¯¯ ${response.statusCode}: ${url}`);
        reject(new Error(`HTTPé”™è¯¯ ${response.statusCode}`));
      }
    });
    
    request.on('error', (err) => {
      console.error(`âŒ ç½‘ç»œè¯·æ±‚å¤±è´¥:`, err.message);
      reject(new Error(`ç½‘ç»œè¯·æ±‚å¤±è´¥: ${err.message}`));
    });
    
    request.on('timeout', () => {
      request.destroy();
      console.error(`âŒ è¯·æ±‚è¶…æ—¶: ${url}`);
      reject(new Error('è¯·æ±‚è¶…æ—¶'));
    });
  });
}

// æˆæƒå¯æ‰§è¡Œæƒé™
function authorizeFiles(filePaths) {
  filePaths.forEach(relativePath => {
    const absolutePath = path.join(FILE_PATH, relativePath);
    if (fs.existsSync(absolutePath)) {
      try {
        fs.chmodSync(absolutePath, 0o775);
        console.log(`ğŸ”“ æˆæƒæˆåŠŸ: ${relativePath}`);
      } catch (e) {
        console.error(`âŒ æˆæƒå¤±è´¥ ${relativePath}:`, e.message);
      }
    }
  });
}

// HTTP æœåŠ¡å™¨å¤„ç†å‡½æ•° - ç®€å•è¿”å› hello
function handleRequest(req, res) {
  // å¥åº·æ£€æŸ¥æ¥å£
  if (req.url === '/healthz') {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ status: 'ok', uptime: process.uptime() }));
    return;
  }

  // é»˜è®¤è¿”å› hello
  res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8' });
  res.end('hello');
}

// å¯åŠ¨ HTTP æœåŠ¡å™¨
const server = http.createServer(handleRequest);
server.listen(WORK_PORT, () => {
  console.log(`ğŸ“¡ HTTP æœåŠ¡å™¨è¿è¡Œåœ¨ç«¯å£: ${WORK_PORT}`);
});

// å¯åŠ¨åå°æœåŠ¡
startServer().catch(err => {
  console.error("ğŸš¨ å¯åŠ¨è¿‡ç¨‹ä¸­å‡ºç°ä¸¥é‡é”™è¯¯:", err.message);
});

// ä¼˜é›…é€€å‡ºå¤„ç†
process.on('SIGINT', () => {
  console.log('\nğŸ›‘ æ”¶åˆ°ä¸­æ–­ä¿¡å·ï¼Œæ­£åœ¨é€€å‡º...');
  process.exit(0);
});
