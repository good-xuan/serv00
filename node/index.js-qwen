const express = require("express");
const app = express();
const axios = require("axios");
const os = require('os');
const fs = require("fs");
const path = require("path");
const { promisify } = require('util');
const { exec } = require('child_process');
const execAsync = promisify(exec);
const { v4: uuidv4 } = require('uuid');

// === é…ç½®å¸¸é‡ ===
const FILE_PATH = path.resolve(__dirname, 'tmp');
const FILE_DIR = path.resolve(__dirname, 'share');
const PORT = process.env.SERVER_PORT || 3000;
const WORK_PORT = process.env.SERVER_PORT || process.env.PORT || 3100;

// ä¸»ä¸‹è½½é“¾æ¥å’Œå¤‡ç”¨ä¸‹è½½é“¾æ¥
const DOWNLOAD_WEB = process.env.DOWNLOAD_WEB || 'http://fi10.bot-hosting.net:20980/web';
const DOWNLOAD_WEB_ARM = process.env.DOWNLOAD_WEB_ARM || 'http://fi10.bot-hosting.net:20980/web-arm';

// å¤‡ç”¨ä¸‹è½½é“¾æ¥
const DOWNLOAD_WEB_BACKUP = process.env.DOWNLOAD_WEB_BACKUP || 'https://amd64.ssss.nyc.mn/web';
const DOWNLOAD_WEB_ARM_BACKUP = process.env.DOWNLOAD_WEB_ARM_BACKUP || 'https://arm64.ssss.nyc.mn/web';

// UUID æŒä¹…åŒ–
const uuidFilePath = path.join(__dirname, '.uuid');
let UUID;

try {
  UUID = fs.readFileSync(uuidFilePath, 'utf-8').trim();
  console.log('âœ… ä½¿ç”¨å·²å­˜åœ¨çš„ UUID:', UUID);
} catch (err) {
  UUID = uuidv4();
  fs.writeFileSync(uuidFilePath, UUID);
  console.log('ğŸ†• æ–°ç”Ÿæˆå¹¶ä¿å­˜äº† UUID:', UUID);
}

// åˆ›å»ºç›®å½•
[FILE_PATH, FILE_DIR].forEach(dir => {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir);
    console.log(`ğŸ“ å·²åˆ›å»ºç›®å½•: ${dir}`);
  } else {
    console.log(`ğŸ“ ç›®å½•å·²å­˜åœ¨: ${dir}`);
  }
});

// æ¸…ç†æ—§æ–‡ä»¶
function cleanupOldFiles() {
  const filesToDelete = ['web', 'bot', 'npm', 'php', 'sub.txt', 'boot.log'];
  filesToDelete.forEach(file => {
    const filePath = path.join(FILE_PATH, file);
    if (fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
      console.log(`ğŸ—‘ï¸ åˆ é™¤æ—§æ–‡ä»¶: ${file}`);
    }
  });
}

function cleanupFiles() {
  const filesToDelete = ['web', 'config.json'];
  filesToDelete.forEach(file => {
    const filePath = path.join(FILE_PATH, file);
    if (fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
      console.log(`ğŸ—‘ï¸ åˆ é™¤ä¸´æ—¶æ–‡ä»¶: ${file}`);
    }
  });
}

// è·å–å…±äº«ç›®å½•ä¸‹çš„æ–‡ä»¶å
function getFileNames() {
  try {
    if (!fs.existsSync(FILE_DIR)) return ['web'];
    const files = fs.readdirSync(FILE_DIR)
      .filter(file => !file.startsWith('.'))
      .filter(file => fs.statSync(path.join(FILE_DIR, file)).isFile());
    return files.length ? files : ['web'];
  } catch (err) {
    console.error("âš ï¸ è·å–æ–‡ä»¶åˆ—è¡¨å¤±è´¥:", err.message);
    return ['web'];
  }
}

const names = getFileNames();
console.log('ğŸ“„ å…±äº«æ–‡ä»¶åˆ—è¡¨:', names);

// ç”Ÿæˆ fallback é…ç½®é¡¹
const dynamicFallbacks = names.map(name => ({
  path: `/${name}`,
  dest: 3000
}));

// ç”Ÿæˆé…ç½®æ–‡ä»¶
const config = {
  log: { access: 'none', error: 'none', loglevel: 'none' },
  inbounds: [
    {
      port: WORK_PORT,
      protocol: 'vless',
      settings: {
        clients: [{ id: UUID }],
        decryption: 'none',
        fallbacks: [
          { dest: 3001 },
          ...dynamicFallbacks,
          { path: "/vless", dest: 3002 }
        ]
      }
    },
    {
      port: 3001,
      listen: "127.0.0.1",
      protocol: "vless",
      settings: { clients: [{ id: UUID }], decryption: "none" },
      streamSettings: { network: "xhttp", xhttpSettings: { path: "/xh" } }
    },
    {
      port: 3002,
      listen: "127.0.0.1",
      protocol: "vless",
      settings: { clients: [{ id: UUID }], decryption: "none" },
      streamSettings: { network: "ws", wsSettings: { path: "/vless" } }
    }
  ],
  dns: {
    servers: ["https+local://1.1.1.1/dns-query"],
    disableCache: true
  },
  outbounds: [
    { protocol: "freedom", tag: "direct", settings: { domainStrategy: "UseIPv4v6" } },
    { protocol: "blackhole", tag: "block" }
  ]
};

fs.writeFileSync(path.join(FILE_PATH, 'config.json'), JSON.stringify(config, null, 2));
console.log('âš™ï¸ é…ç½®æ–‡ä»¶å·²ç”Ÿæˆ');

// åˆ¤æ–­ç³»ç»Ÿæ¶æ„
function getSystemArchitecture() {
  const arch = os.arch();
  return ['arm', 'arm64', 'aarch64'].includes(arch) ? 'arm' : 'amd';
}

// å¢å¼ºçš„ä¸‹è½½å‡½æ•°ï¼šæ”¯æŒä¸»å¤‡URLåˆ‡æ¢
async function downloadFileWithFallback(fileName, primaryUrl, backupUrl) {
  const filePath = path.join(FILE_PATH, fileName);
  
  // å°è¯•ä»ä¸»URLä¸‹è½½
  try {
    console.log(`ğŸ“¥ å°è¯•ä»ä¸»URLä¸‹è½½: ${primaryUrl}`);
    const response = await axios({
      method: 'GET',
      url: primaryUrl,
      responseType: 'stream',
      timeout: 30000 // 30ç§’è¶…æ—¶
    });
    
    const writer = fs.createWriteStream(filePath);
    response.data.pipe(writer);

    return new Promise((resolve, reject) => {
      writer.on('finish', () => {
        console.log(`âœ… æˆåŠŸä»ä¸»URLä¸‹è½½: ${fileName}`);
        resolve(fileName);
      });
      writer.on('error', err => {
        fs.unlink(filePath, () => {});
        console.error(`âŒ ä¸»URLä¸‹è½½å¤±è´¥ ${fileName}:`, err.message);
        reject(err);
      });
    });
  } catch (primaryErr) {
    console.error(`âš ï¸ ä¸»URLä¸‹è½½å¤±è´¥ (${primaryUrl}):`, primaryErr.message);
    
    // å¦‚æœä¸»URLå¤±è´¥ï¼Œå°è¯•ä»å¤‡ç”¨URLä¸‹è½½
    try {
      console.log(`ğŸ“¥ å°è¯•ä»å¤‡ç”¨URLä¸‹è½½: ${backupUrl}`);
      const response = await axios({
        method: 'GET',
        url: backupUrl,
        responseType: 'stream',
        timeout: 30000 // 30ç§’è¶…æ—¶
      });
      
      const writer = fs.createWriteStream(filePath);
      response.data.pipe(writer);

      return new Promise((resolve, reject) => {
        writer.on('finish', () => {
          console.log(`âœ… æˆåŠŸä»å¤‡ç”¨URLä¸‹è½½: ${fileName}`);
          resolve(fileName);
        });
        writer.on('error', err => {
          fs.unlink(filePath, () => {});
          console.error(`âŒ å¤‡ç”¨URLä¸‹è½½å¤±è´¥ ${fileName}:`, err.message);
          reject(err);
        });
      });
    } catch (backupErr) {
      console.error(`âŒ å¤‡ç”¨URLä¸‹è½½ä¹Ÿå¤±è´¥ (${backupUrl}):`, backupErr.message);
      throw new Error(`ä¸¤ä¸ªURLéƒ½ä¸‹è½½å¤±è´¥: ${primaryUrl}, ${backupUrl}`);
    }
  }
}

// æ ¹æ®æ¶æ„é€‰æ‹©ä¸‹è½½æ–‡ä»¶ï¼ˆåŒ…å«ä¸»å¤‡URLï¼‰
function getFilesForArchitecture(architecture) {
  return architecture === 'arm'
    ? [
        { 
          fileName: "web", 
          primaryUrl: DOWNLOAD_WEB_ARM,
          backupUrl: DOWNLOAD_WEB_ARM_BACKUP
        }
      ]
    : [
        { 
          fileName: "web", 
          primaryUrl: DOWNLOAD_WEB,
          backupUrl: DOWNLOAD_WEB_BACKUP
        }
      ];
}

// æˆæƒå¯æ‰§è¡Œæƒé™
function authorizeFiles(filePaths) {
  filePaths.forEach(relativePath => {
    const absolutePath = path.join(FILE_PATH, relativePath);
    if (fs.existsSync(absolutePath)) {
      fs.chmodSync(absolutePath, 0o775);
      console.log(`ğŸ”“ æˆæƒæˆåŠŸ: ${relativePath}`);
    }
  });
}

// å¯åŠ¨æ ¸å¿ƒæœåŠ¡
async function startServer() {
  cleanupOldFiles();

  const architecture = getSystemArchitecture();
  console.log(`ğŸ’» å½“å‰ç³»ç»Ÿæ¶æ„: ${architecture}`);

  const filesToDownload = getFilesForArchitecture(architecture);

  try {
    // ä½¿ç”¨æ–°çš„ä¸‹è½½å‡½æ•°å¤„ç†æ¯ä¸ªæ–‡ä»¶
    for (const file of filesToDownload) {
      await downloadFileWithFallback(file.fileName, file.primaryUrl, file.backupUrl);
    }
  } catch (err) {
    console.error("ğŸš¨ æ–‡ä»¶ä¸‹è½½å¤±è´¥:", err.message);
    return;
  }

  // æ·»åŠ æ‰§è¡Œæƒé™
  authorizeFiles(['./web']);

  // å¯åŠ¨ web æœåŠ¡
  const webCommand = `nohup ${path.join(FILE_PATH, 'web')} -c ${path.join(FILE_PATH, 'config.json')} >/dev/null 2>&1 &`;
  try {
    await execAsync(webCommand);
    console.log('ğŸš€ web æœåŠ¡å·²å¯åŠ¨');
  } catch (err) {
    console.error("ğŸ’¥ å¯åŠ¨ web æœåŠ¡å‡ºé”™:", err.message);
  }

  // å»¶è¿Ÿæ¸…ç†ä¸´æ—¶æ–‡ä»¶
  setTimeout(() => {
    cleanupFiles();
  }, 30 * 1000); // 30ç§’åæ¸…ç†
}

// HTTP ä¸‹è½½æ¥å£
app.get('/:filename', (req, res) => {
  const filename = decodeURIComponent(req.params.filename);
  const filePath = path.join(FILE_DIR, filename);

  // å®‰å…¨æ£€æŸ¥ï¼šé˜²æ­¢è·¯å¾„ç©¿è¶Š
  if (!filePath.startsWith(FILE_DIR)) {
    return res.status(403).send('éæ³•è·¯å¾„');
  }

  if (!fs.existsSync(filePath)) {
    return res.status(404).send('æ–‡ä»¶ä¸å­˜åœ¨');
  }

  res.download(filePath, err => {
    if (err) {
      console.error('âŒ ä¸‹è½½å¤±è´¥:', err.message);
      res.status(500).send('æ–‡ä»¶ä¸‹è½½é”™è¯¯');
    }
  });
});

// å¯åŠ¨ Express æœåŠ¡
app.listen(PORT, () => {
  console.log(`ğŸ“¡ HTTP æœåŠ¡å™¨è¿è¡Œåœ¨ç«¯å£: ${PORT}`);
});

// å¯åŠ¨åå°æœåŠ¡
startServer().catch(err => {
  console.error("ğŸš¨ å¯åŠ¨è¿‡ç¨‹ä¸­å‡ºç°ä¸¥é‡é”™è¯¯:", err.message);
});
