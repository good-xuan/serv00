const http = require('http');
const https = require('https');
const fs = require('fs');
const path = require('path');
const { spawn, execSync } = require('child_process');

// ==============================================================================
//   1. ç›®å½•ä¸Žæ–‡ä»¶è·¯å¾„é…ç½® (Paths & Files)
// ==============================================================================
const ROOT_DIR = __dirname;
const TEMP_DIR = path.join(ROOT_DIR, 'tmp');
const SHARE_DIR = path.join(ROOT_DIR, 'share');

// å¯æ‰§è¡Œæ–‡ä»¶è·¯å¾„ (Executables)
const DUFS_EXEC = path.join(TEMP_DIR, 'dufs');
const HUBPROXY_EXEC = path.join(TEMP_DIR, 'hub_app'); // æ”¹åä»¥é¿å…ä¸Žè§£åŽ‹ç›®å½•å†²çª
const CLOUDFLARED_EXEC = path.join(TEMP_DIR, 'cloudflared');

// åŽ‹ç¼©åŒ…è·¯å¾„ (Archives)
const DUFS_ARCHIVE = path.join(TEMP_DIR, 'dufs.tar.gz');
const HUBPROXY_ARCHIVE = path.join(TEMP_DIR, 'hub.tar.gz');

// ==============================================================================
//   2. æœåŠ¡ç«¯å£é…ç½® (Port Configuration)
// ==============================================================================
// ä¸»ç«¯å£ï¼šåˆ†é…ç»™ Dufs (æ–‡ä»¶æœåŠ¡)
const DUFS_PORT = parseInt(process.env.SERVER_PORT || process.env.PORT || 3000);

// å‰¯ç«¯å£ï¼šåˆ†é…ç»™ HubProxy (é¿å…å†²çªï¼Œåç§» +2)
const HUBPROXY_PORT = DUFS_PORT + 2;

// ==============================================================================
//   3. å¤–éƒ¨èµ„æºé“¾æŽ¥ (External URLs)
// ==============================================================================
const CLOUDFLARED_URL = 'https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64';

// ==============================================================================
//   4. åŠŸèƒ½å¼€å…³ä¸Žéš§é“é…ç½® (Toggles & Tunnel Config)
// ==============================================================================
// æ€»å¼€å…³
const IS_CLOUDFLARED_ENABLED = process.env.ENABLE_ARGO !== 'false';

// Dufs éš§é“é…ç½® (å¯¹åº”åŽŸ Argo2)
const IS_DUFS_TUNNEL_ENABLED = process.env.ENABLE_ARGO2 !== 'false';
const DUFS_TUNNEL_TOKEN = process.env.ARGO2_TOKEN || '';
const DUFS_TUNNEL_DOMAIN = process.env.ARGO2_DOMAIN || '';

// HubProxy éš§é“é…ç½® (å¯¹åº”åŽŸ Argo3)
const IS_HUBPROXY_TUNNEL_ENABLED = process.env.ENABLE_ARGO3 !== 'false';
const HUBPROXY_TUNNEL_TOKEN = process.env.ARGO3_TOKEN || '';
const HUBPROXY_TUNNEL_DOMAIN = process.env.ARGO3_DOMAIN || '';

// ==============================================================================
//   5. åˆå§‹åŒ–çŽ¯å¢ƒ (Initialization)
// ==============================================================================
if (!fs.existsSync(SHARE_DIR)) {
    try { fs.mkdirSync(SHARE_DIR); } catch (e) {}
}

// ==============================================================================
//   6. å·¥å…·å‡½æ•° (Helper Functions)
// ==============================================================================

/**
 * ä¸‹è½½æ–‡ä»¶
 */
const downloadResource = (url, destination) => new Promise((resolve, reject) => {
    const protocol = url.startsWith('https') ? https : http;
    protocol.get(url, res => {
        if (res.statusCode === 301 || res.statusCode === 302) {
            if (!res.headers.location) return reject('No redirect location found');
            return downloadResource(res.headers.location, destination).then(resolve).catch(reject);
        }
        if (res.statusCode !== 200) return reject(`Download failed. Status: ${res.statusCode}`);
        
        const fileStream = fs.createWriteStream(destination);
        res.pipe(fileStream);
        fileStream.on('finish', () => fileStream.close(resolve));
    }).on('error', reject).setTimeout(30000, () => reject('Download timeout'));
});

/**
 * èŽ·å– Dufs æœ€æ–°ä¸‹è½½é“¾æŽ¥
 */
const fetchDufsLatestUrl = () => new Promise((resolve) => {
    https.get('https://github.com/sigoden/dufs/releases/latest', (res) => {
        try {
            const location = res.headers.location;
            const versionTag = location ? path.basename(location) : 'v0.43.0';
            const versionNum = versionTag.replace('v', '');
            resolve(`https://github.com/sigoden/dufs/releases/download/${versionTag}/dufs-v${versionNum}-x86_64-unknown-linux-musl.tar.gz`);
        } catch (e) {
            resolve('https://github.com/sigoden/dufs/releases/download/v0.43.0/dufs-v0.43.0-x86_64-unknown-linux-musl.tar.gz');
        }
    }).on('error', () => resolve('https://github.com/sigoden/dufs/releases/download/v0.43.0/dufs-v0.43.0-x86_64-unknown-linux-musl.tar.gz'));
});

/**
 * èŽ·å– HubProxy æœ€æ–°ä¸‹è½½é“¾æŽ¥
 */
const fetchHubProxyUrl = () => new Promise((resolve) => {
    console.log('ðŸ” Checking HubProxy version...');
    const fallbackUrl = 'https://github.com/sky22333/hubproxy/releases/download/v1.1.9/hubproxy-v1.1.9-linux-amd64.tar.gz';
    
    const req = https.get('https://github.com/sky22333/hubproxy/releases/latest', (res) => {
        try {
            if (res.statusCode === 200 || res.statusCode === 302) {
                const location = res.headers.location;
                if (location) {
                    const tag = path.basename(location);
                    resolve(`https://github.com/sky22333/hubproxy/releases/download/${tag}/hubproxy-${tag}-linux-amd64.tar.gz`);
                } else {
                    resolve(fallbackUrl);
                }
            } else {
                resolve(fallbackUrl);
            }
        } catch (e) {
            resolve(fallbackUrl);
        }
    });
    
    req.on('error', () => resolve(fallbackUrl));
    req.setTimeout(5000, () => {
        req.destroy();
        resolve(fallbackUrl);
    });
});

/**
 * é€’å½’æŸ¥æ‰¾å¯æ‰§è¡Œæ–‡ä»¶ (å¤„ç†è§£åŽ‹åŽç›®å½•ç»“æž„ä¸ç¡®å®šçš„é—®é¢˜)
 */
const findExecutable = (dir, filename) => {
    try {
        const files = fs.readdirSync(dir, { withFileTypes: true });
        for (const file of files) {
            const fullPath = path.join(dir, file.name);
            if (file.isDirectory()) {
                const result = findExecutable(fullPath, filename);
                if (result) return result;
            } else {
                // åŒ¹é…æ–‡ä»¶åï¼ŒæŽ’é™¤åŽ‹ç¼©åŒ…
                if ((file.name === filename || file.name.startsWith(filename + '-')) && 
                    !file.name.endsWith('.gz') && 
                    !file.name.endsWith('.zip')) {
                    return fullPath;
                }
            }
        }
    } catch (e) {}
    return null;
};

// ==============================================================================
//   7. ä¸»ç¨‹åºé€»è¾‘ (Main Execution)
// ==============================================================================

(async () => {
    // ç”¨äºŽå­˜å‚¨ç”Ÿæˆçš„å…¬ç½‘åœ°å€ (å†…å­˜å­˜å‚¨ï¼Œä¸æŒä¹…åŒ–)
    let dufsPublicUrl = '';
    let hubProxyPublicUrl = '';

    // æ¸…ç†ä¸´æ—¶ç›®å½•
    if (fs.existsSync(TEMP_DIR)) fs.rmSync(TEMP_DIR, { recursive: true, force: true });
    fs.mkdirSync(TEMP_DIR, { recursive: true });

    try {
        console.log('â³ Initializing services...');

        // --- 1. ä¸‹è½½é˜¶æ®µ (Downloading) ---
        const dufsDownloadUrl = await fetchDufsLatestUrl();
        let hubProxyDownloadUrl;
        try {
            hubProxyDownloadUrl = await fetchHubProxyUrl();
        } catch (e) {
            hubProxyDownloadUrl = 'https://github.com/sky22333/hubproxy/releases/download/v1.1.9/hubproxy-v1.1.9-linux-amd64.tar.gz';
        }

        const tasks = [
            downloadResource(dufsDownloadUrl, DUFS_ARCHIVE),
            downloadResource(hubProxyDownloadUrl, HUBPROXY_ARCHIVE)
        ];

        if (IS_CLOUDFLARED_ENABLED) {
            tasks.push(downloadResource(CLOUDFLARED_URL, CLOUDFLARED_EXEC));
        }

        await Promise.all(tasks);

        // --- 2. è§£åŽ‹ä¸Žå®‰è£…é˜¶æ®µ (Extraction & Installation) ---
        
        // å®‰è£… Dufs
        console.log(`ðŸ“¦ Installing Dufs...`);
        execSync(`tar -xzf ${DUFS_ARCHIVE} -C ${TEMP_DIR}`);
        const dufsFoundPath = findExecutable(TEMP_DIR, 'dufs');
        if (dufsFoundPath && dufsFoundPath !== DUFS_EXEC) {
            fs.renameSync(dufsFoundPath, DUFS_EXEC);
        }
        fs.chmodSync(DUFS_EXEC, 0o755);

        // å®‰è£… HubProxy
        console.log(`ðŸ“¦ Installing HubProxy...`);
        execSync(`tar -xzf ${HUBPROXY_ARCHIVE} -C ${TEMP_DIR}`);
        const hubFoundPath = findExecutable(TEMP_DIR, 'hubproxy');
        if (hubFoundPath) {
            if (hubFoundPath !== HUBPROXY_EXEC) {
                fs.renameSync(hubFoundPath, HUBPROXY_EXEC);
            }
            fs.chmodSync(HUBPROXY_EXEC, 0o755);
        } else {
            console.warn('âš ï¸ HubProxy binary not found.');
        }

        // è®¾ç½® Cloudflared æƒé™
        if (IS_CLOUDFLARED_ENABLED && fs.existsSync(CLOUDFLARED_EXEC)) {
            fs.chmodSync(CLOUDFLARED_EXEC, 0o755);
        }

        // --- 3. å¯åŠ¨æœåŠ¡é˜¶æ®µ (Starting Services) ---

        // å¯åŠ¨ Dufs (ä¸»æœåŠ¡)
        console.log(`ðŸ“‚ Starting Dufs on port ${DUFS_PORT}...`);
        spawn(DUFS_EXEC, [SHARE_DIR, '-p', String(DUFS_PORT), '-A', '--bind', '0.0.0.0'], {
            stdio: 'inherit',
            detached: true
        }).unref();

        // å¯åŠ¨ HubProxy (å‰¯æœåŠ¡)
        if (fs.existsSync(HUBPROXY_EXEC)) {
            console.log(`ðŸ³ Starting HubProxy on port ${HUBPROXY_PORT}...`);
            spawn(HUBPROXY_EXEC, ['--addr', `:${HUBPROXY_PORT}`], {
                stdio: 'ignore',
                detached: true,
                // å…³é”®: è¦†ç›–çŽ¯å¢ƒå˜é‡ï¼Œé˜²æ­¢ HubProxy è¯»å–ç³»ç»Ÿçš„ PORT å¯¼è‡´å†²çª
                env: { 
                    ...process.env, 
                    PORT: String(HUBPROXY_PORT), 
                    SERVER_PORT: String(HUBPROXY_PORT) 
                }
            }).unref();
        }

        // --- 4. å¯åŠ¨éš§é“é˜¶æ®µ (Starting Tunnels) ---
        if (IS_CLOUDFLARED_ENABLED && fs.existsSync(CLOUDFLARED_EXEC)) {
            
            // Dufs éš§é“
            if (IS_DUFS_TUNNEL_ENABLED) {
                if (DUFS_TUNNEL_TOKEN && DUFS_TUNNEL_DOMAIN) {
                    // å›ºå®šéš§é“
                    dufsPublicUrl = `https://${DUFS_TUNNEL_DOMAIN}`;
                    
                    spawn(CLOUDFLARED_EXEC, ['tunnel', 'run', '--token', DUFS_TUNNEL_TOKEN], { 
                        stdio: 'ignore', detached: true 
                    }).unref();
                    
                    console.log(`ðŸ”— Dufs Tunnel (Fixed): ${dufsPublicUrl}`);
                } else {
                    // ä¸´æ—¶éš§é“ (TryCloudflare)
                    const tunnel = spawn(CLOUDFLARED_EXEC, [
                        'tunnel', '--url', `http://localhost:${DUFS_PORT}`, 
                        '--no-autoupdate'
                    ], { stdio: ['ignore', 'ignore', 'pipe'] });

                    tunnel.stderr.on('data', d => {
                        const match = d.toString().match(/(https:\/\/[a-zA-Z0-9-]+\.trycloudflare\.com)/);
                        if (match) {
                            dufsPublicUrl = match[1];
                            console.log(`ðŸ”— Dufs Tunnel (Temp): ${dufsPublicUrl}`);
                        }
                    });
                }
            }

            // HubProxy éš§é“
            if (IS_HUBPROXY_TUNNEL_ENABLED) {
                if (HUBPROXY_TUNNEL_TOKEN && HUBPROXY_TUNNEL_DOMAIN) {
                    // å›ºå®šéš§é“
                    hubProxyPublicUrl = `https://${HUBPROXY_TUNNEL_DOMAIN}`;

                    spawn(CLOUDFLARED_EXEC, ['tunnel', 'run', '--token', HUBPROXY_TUNNEL_TOKEN], { 
                        stdio: 'ignore', detached: true 
                    }).unref();

                    console.log(`ðŸ”— HubProxy Tunnel (Fixed): ${hubProxyPublicUrl}`);
                } else {
                    // ä¸´æ—¶éš§é“
                    const tunnel = spawn(CLOUDFLARED_EXEC, [
                        'tunnel', '--url', `http://localhost:${HUBPROXY_PORT}`, 
                        '--no-autoupdate'
                    ], { stdio: ['ignore', 'ignore', 'pipe'] });

                    tunnel.stderr.on('data', d => {
                        const match = d.toString().match(/(https:\/\/[a-zA-Z0-9-]+\.trycloudflare\.com)/);
                        if (match) {
                            hubProxyPublicUrl = match[1];
                            console.log(`ðŸ”— HubProxy Tunnel (Temp): ${hubProxyPublicUrl}`);
                        }
                    });
                }
            }
        }

    } catch (e) {
        console.error('âŒ Critical Error:', e);
        process.exit(1);
    }

    // --- çŠ¶æ€æ‰“å°å‡½æ•° ---
    const printServiceStatus = () => {
        // ç‰©ç†æ¸…å±
        process.stdout.write('\033c');
        
        console.log(`\n========================================`);
        console.log(`   ðŸš€ SERVICE RUNNING STATUS`);
        console.log(`   â° Time: ${new Date().toLocaleString()}`);
        console.log(`========================================`);
        
        console.log(`\nðŸ“‚ [Dufs File Manager]`);
        console.log(`   â–º Local: http://localhost:${DUFS_PORT}`);
        if (IS_DUFS_TUNNEL_ENABLED && dufsPublicUrl) {
            console.log(`   â–º Public: ${dufsPublicUrl}`);
        } else if (IS_DUFS_TUNNEL_ENABLED) {
            console.log(`   â–º Public: (Initializing...)`);
        }

        console.log(`\nðŸ³ [HubProxy Docker Mirror]`);
        console.log(`   â–º Local: http://localhost:${HUBPROXY_PORT}`);
        if (IS_HUBPROXY_TUNNEL_ENABLED && hubProxyPublicUrl) {
            console.log(`   â–º Public: ${hubProxyPublicUrl}`);
        } else if (IS_HUBPROXY_TUNNEL_ENABLED) {
            console.log(`   â–º Public: (Initializing...)`);
        }
        console.log(`\n========================================\n`);
    };

    // --- 5. å¯åŠ¨åŽåˆæ¬¡æ±‡æ€» ---
    setTimeout(() => {
        // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
        if (fs.existsSync(TEMP_DIR)) fs.rmSync(TEMP_DIR, { recursive: true, force: true });
        printServiceStatus();
    }, 30000);

    // --- 6. å®šæ—¶ä»»åŠ¡ ---
    
    // æ¯ 1 å°æ—¶æ¸…å±å¹¶æ˜¾ç¤ºçŠ¶æ€ (3600000 ms)
    setInterval(printServiceStatus, 3600000);

    // æ¯ 5 åˆ†é’Ÿç®€å•å¿ƒè·³ (ä¸æ›¿ä»£çŠ¶æ€æ¿ï¼Œåªæ˜¯ä¸ºäº†ä¿æ´»æ—¥å¿—)
    setInterval(() => console.log('ðŸ’— Keep alive', new Date().toISOString()), 300000);

})();
// END OF FILE
