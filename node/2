const http = require('http'), https = require('https'), fs = require('fs'), path = require('path'), { spawn, execSync } = require('child_process');

// --- åŸºç¡€é…ç½® ---
const TMP = path.join(__dirname, 'tmp');
const BIN = path.join(TMP, 'web');      // Xray Binary
const DUFS_BIN = path.join(TMP, 'dufs'); // Dufs Binary
const ARGO = path.join(TMP, 'cloudflared');
const CFG = path.join(TMP, 'config.json');
const ZIP = path.join(TMP, 'xray.zip');
const DUFS_TAR = path.join(TMP, 'dufs.tar.gz');
const FRPC_BIN = path.join(TMP, 'frpc'), FRPC_TAR = path.join(TMP, 'frp.tar.gz');
const FRPC_CFG1 = path.join(TMP, 'frpc1.ini');
const FRPC_CFG2 = path.join(TMP, 'frpc2.ini');
const CERT_FILE = path.join(TMP, 'cert.pem'), KEY_FILE = path.join(TMP, 'key.pem');

// --- æŒä¹…åŒ–æ–‡ä»¶è·¯å¾„ ---
const UUID_FILE = path.join(__dirname, '.uuid');
const PASSWORD_FILE = path.join(__dirname, '.password'); 
const KEYS_FILE = path.join(__dirname, '.keys');
const PATHS_FILE = path.join(__dirname, '.paths');
const SHARE_PATH = path.join(__dirname, 'share');

// --- ç«¯å£åˆ†é… ---
// WEB_PORT: Dufs ç«¯å£
const WEB_PORT = parseInt(process.env.SERVER_PORT || process.env.PORT || 3000);
// PORT: Xray æ ¸å¿ƒç«¯å£
const PORT = 3100;
const XHTTP_PORT = PORT + 1;

// --- å¤–éƒ¨å˜é‡ ---
const XRAY_URL = 'https://github.com/XTLS/Xray-core/releases/latest/download/Xray-linux-64.zip';
const ARGO_URL = 'https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64';
const CDN_HOST = 'www.visa.com.sg';
const LINK_NAME = process.env.LINK_NAME || 'Node'; 

// --- Argo å¼€å…³æŽ§åˆ¶ ---
const ENABLE_ARGO = process.env.ENABLE_ARGO !== 'false';   // æ€»å¼€å…³ (æŽ§åˆ¶ä¸‹è½½)
const ENABLE_ARGO1 = process.env.ENABLE_ARGO1 !== 'false'; // æŽ§åˆ¶ Xray éš§é“ (é»˜è®¤å¼€å¯)
const ENABLE_ARGO2 = process.env.ENABLE_ARGO2 !== 'false'; // æŽ§åˆ¶ Dufs éš§é“ (é»˜è®¤å¼€å¯)

// [Argo 1] ç”¨äºŽ Xray
const ARGO_TOKEN = process.env.ARGO_TOKEN || '';
const ARGO_DOMAIN = process.env.ARGO_DOMAIN || '';

// [Argo 2] ç”¨äºŽ Dufs
const ARGO2_TOKEN = process.env.ARGO2_TOKEN || '';
const ARGO2_DOMAIN = process.env.ARGO2_DOMAIN || '';

// ==============================================================================
//   åˆå§‹åŒ–é€»è¾‘
// ==============================================================================

// 0. ç¡®ä¿ share ç›®å½•
if (!fs.existsSync(SHARE_PATH)) { try { fs.mkdirSync(SHARE_PATH); } catch(e) {} }

// 1. UUID å¤„ç†
let uuid = process.env.UUID || '';
if (!uuid && fs.existsSync(UUID_FILE)) { try { uuid = fs.readFileSync(UUID_FILE, 'utf-8').trim(); } catch(e) {} }
if (!uuid) {
    uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => (c === 'x' ? Math.random() * 16 | 0 : (Math.random() * 16 | 0) & 0x3 | 0x8).toString(16));
    console.log(`ðŸ†• Generated New UUID: ${uuid}`);
} else { console.log(`âœ… Using UUID: ${uuid}`); }
try { fs.writeFileSync(UUID_FILE, uuid); } catch(e) {}

// 2. Web å¯†ç å¤„ç† (Env -> File -> Random)
const WEB_USER = process.env.WEB_USER || 'admin';
let WEB_PASSWORD = process.env.WEB_PASSWORD || '';
if (!WEB_PASSWORD && fs.existsSync(PASSWORD_FILE)) { 
    try { WEB_PASSWORD = fs.readFileSync(PASSWORD_FILE, 'utf-8').trim(); } catch(e) {} 
}
if (!WEB_PASSWORD) {
    const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    for (let i = 0; i < 16; i++) {
        WEB_PASSWORD += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    console.log(`ðŸ†• Generated New Web Password`);
}
try { fs.writeFileSync(PASSWORD_FILE, WEB_PASSWORD); } catch(e) {}

// 3. Path å¤„ç†
let WS_PATH = process.env.WS_PATH || '';
let XHTTP_PATH = process.env.XHTTP_PATH || '';
if ((!WS_PATH || !XHTTP_PATH) && fs.existsSync(PATHS_FILE)) {
    try {
        const storedPaths = JSON.parse(fs.readFileSync(PATHS_FILE, 'utf-8'));
        if (!WS_PATH) WS_PATH = storedPaths.ws || '';
        if (!XHTTP_PATH) XHTTP_PATH = storedPaths.xhttp || '';
    } catch(e) {}
}
const genPath = () => '/' + Math.random().toString(36).substring(2, 8);
if (!WS_PATH) WS_PATH = genPath();
if (!XHTTP_PATH) XHTTP_PATH = genPath();
try { fs.writeFileSync(PATHS_FILE, JSON.stringify({ ws: WS_PATH, xhttp: XHTTP_PATH })); } catch(e) {}

// 4. ML-KEM Keys å¤„ç†
let DECRYPTION = process.env.VLESS_DECRYPTION || ''; 
let ENCRYPTION = process.env.VLESS_ENCRYPTION || '';
if ((!DECRYPTION || !ENCRYPTION) && fs.existsSync(KEYS_FILE)) {
   try {
       const storedKeys = JSON.parse(fs.readFileSync(KEYS_FILE, 'utf-8'));
       if (!DECRYPTION) DECRYPTION = storedKeys.decryption || '';
       if (!ENCRYPTION) ENCRYPTION = storedKeys.encryption || '';
   } catch (e) {}
}

// ==============================================================================
//   FRP é…ç½®
// ==============================================================================
const FRPS_HOST = process.env.FRPS_HOST || 'hk4.afrp.net';          
const FRPS_PORT = process.env.FRPS_PORT || '7000';      
const FRPC_TOKEN = process.env.FRPC_TOKEN || 'afrp.net';        
const FRPC_DOMAIN = process.env.FRPC_DOMAIN || '';           
const FRPC_XHTTP_PORT = process.env.FRPC_XHTTP_PORT || '';   

const FRPS2_HOST = process.env.FRPS2_HOST || 'uss.afrp.net';          
const FRPS2_PORT = process.env.FRPS2_PORT || '7000';      
const FRPC2_TOKEN = process.env.FRPC2_TOKEN || 'afrp.net';        
const FRPC2_DOMAIN = process.env.FRPC2_DOMAIN || '';         
const FRPC2_XHTTP_PORT = process.env.FRPC2_XHTTP_PORT || ''; 

// ==============================================================================
//   å·¥å…·å‡½æ•°
// ==============================================================================

const download = (url, dest) => new Promise((resolve, reject) => {
  (url.startsWith('https') ? https : http).get(url, res => {
    if (res.statusCode === 301 || res.statusCode === 302) {
      if (!res.headers.location) return reject('No location');
      return download(res.headers.location, dest).then(resolve).catch(reject);
    }
    if (res.statusCode !== 200) return reject('Status ' + res.statusCode);
    const file = fs.createWriteStream(dest);
    res.pipe(file);
    file.on('finish', () => file.close(resolve));
  }).on('error', reject).setTimeout(30000, () => reject('Timeout'));
});

// èŽ·å– FRP æœ€æ–°ç‰ˆ
const getFrpLatestUrl = () => new Promise((resolve) => {
    https.get('https://github.com/fatedier/frp/releases/latest', (res) => {
        const loc = res.headers.location;
        if (loc) {
            const tag = path.basename(loc); 
            const ver = tag.startsWith('v') ? tag.slice(1) : tag; 
            resolve(`https://github.com/fatedier/frp/releases/download/${tag}/frp_${ver}_linux_amd64.tar.gz`);
        } else {
            resolve('https://github.com/fatedier/frp/releases/download/v0.58.1/frp_0.58.1_linux_amd64.tar.gz');
        }
    }).on('error', () => resolve('https://github.com/fatedier/frp/releases/download/v0.58.1/frp_0.58.1_linux_amd64.tar.gz'));
});

// èŽ·å– Dufs æœ€æ–°ç‰ˆ
const getDufsLatestUrl = () => new Promise((resolve) => {
    console.log('ðŸ” Checking latest Dufs version...');
    https.get('https://github.com/sigoden/dufs/releases/latest', (res) => {
        const loc = res.headers.location;
        const tag = loc ? path.basename(loc) : 'v0.43.0';
        const ver = tag.replace('v', '');
        resolve(`https://github.com/sigoden/dufs/releases/download/${tag}/dufs-v${ver}-x86_64-unknown-linux-musl.tar.gz`);
    }).on('error', () => resolve('https://github.com/sigoden/dufs/releases/download/v0.43.0/dufs-v0.43.0-x86_64-unknown-linux-musl.tar.gz'));
});

const printLink = (uuid, host, port, remarks, type) => {
  let link = '';
  if (type === 'xhttp') {
    link = `vless://${uuid}@${host}:${port}?encryption=${ENCRYPTION}&security=tls&sni=localhost&flow=xtls-rprx-vision&fp=firefox&alpn=h2&type=xhttp&path=${encodeURIComponent(XHTTP_PATH)}&insecure=1#${remarks}`;
  } else if (type === 'https-domain') {
    link = `vless://${uuid}@${host}:443?encryption=${ENCRYPTION}&security=tls&sni=${host}&flow=xtls-rprx-vision&fp=firefox&alpn=h2&type=xhttp&path=${encodeURIComponent(XHTTP_PATH)}&insecure=1#${remarks}`;
  } else if (type === 'argo') {
    link = `vless://${uuid}@${CDN_HOST}:443?encryption=${ENCRYPTION}&security=tls&flow=xtls-rprx-vision&sni=${host}&fp=firefox&alpn=h2&type=ws&path=${encodeURIComponent(WS_PATH)}#${remarks}`;
  }
  console.log(`\nðŸ”— ${remarks} Link:\n${link}\n`);
};

const startFrpcInstance = (uuid, sHost, sPort, sToken, sDomain, sTcpPort, cfgPath, label) => {
    if (!sHost || (!sDomain && !sTcpPort)) return;
    console.log(`â˜ï¸  Starting FRPC [${label}] -> ${sHost}...`);
    let ini = `[common]\nserver_addr = ${sHost}\nserver_port = ${sPort}\ntoken = ${sToken}\n`;
    if (sDomain) ini += `\n[https-${label}-${uuid.substring(0,5)}]\ntype = https\ncustom_domains = ${sDomain}\nlocal_port = ${XHTTP_PORT}\n`;
    if (sTcpPort) ini += `\n[tcp-${label}-${uuid.substring(0,5)}]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = ${XHTTP_PORT}\nremote_port = ${sTcpPort}\n`;
    fs.writeFileSync(cfgPath, ini);
    spawn(FRPC_BIN, ['-c', cfgPath], { stdio: 'ignore', detached: true }).unref();
    if (sDomain) printLink(uuid, sDomain, 443, `${LINK_NAME}-${label}-HTTPS`, 'https-domain');
    if (sTcpPort) printLink(uuid, sHost, sTcpPort, `${LINK_NAME}-${label}-TCP`, 'xhttp');
};

// ==============================================================================
//   Main
// ==============================================================================

(async () => {
  if (fs.existsSync(TMP)) fs.rmSync(TMP, { recursive: true, force: true });
  fs.mkdirSync(TMP, { recursive: true });

  try {
    console.log('ðŸ” Generating self-signed certificates...');
    execSync(`openssl req -x509 -newkey rsa:2048 -nodes -sha256 -keyout ${KEY_FILE} -out ${CERT_FILE} -days 3650 -subj '/CN=localhost'`);

    console.log('â³ Downloading binaries...');
    const dufsUrl = await getDufsLatestUrl();
    const downloadList = [
        download(XRAY_URL, ZIP),
        download(dufsUrl, DUFS_TAR)
    ];
    // æ€»å¼€å…³å¼€å¯æ‰ä¼šä¸‹è½½ Argo
    if (ENABLE_ARGO) downloadList.push(download(ARGO_URL, ARGO));
    
    const needFrp1 = FRPS_HOST && (FRPC_DOMAIN || FRPC_XHTTP_PORT);
    const needFrp2 = FRPS2_HOST && (FRPC2_DOMAIN || FRPC2_XHTTP_PORT);
    if (needFrp1 || needFrp2) {
        const frpUrl = await getFrpLatestUrl();
        console.log(`â¬ Downloading FRP from: ${frpUrl}`);
        downloadList.push(download(frpUrl, FRPC_TAR));
    }
    await Promise.all(downloadList);

    // 1. Xray
    console.log('ðŸ“¦ Unzipping Xray...');
    execSync(`unzip -o ${ZIP} -d ${TMP}`);
    fs.renameSync(path.join(TMP, 'xray'), BIN);
    fs.chmodSync(BIN, 0o755);
    
    // 2. Dufs
    console.log(`ðŸ“¦ Unzipping Dufs...`);
    execSync(`tar -xzf ${DUFS_TAR} -C ${TMP}`);
    const dufsFile = fs.readdirSync(TMP).find(n => n === 'dufs' || n.startsWith('dufs-'));
    if (dufsFile) {
        const srcPath = path.join(TMP, dufsFile);
        if (!fs.lstatSync(srcPath).isDirectory()) {
             fs.renameSync(srcPath, DUFS_BIN);
        }
    }
    fs.chmodSync(DUFS_BIN, 0o755);

    if (ENABLE_ARGO && fs.existsSync(ARGO)) fs.chmodSync(ARGO, 0o755);

    // 3. Keys
    if (DECRYPTION && ENCRYPTION) {
        console.log('âœ… Using Configured/Loaded ML-KEM-768 Keys.');
    } else {
        console.log('ðŸ”‘ Keys missing. Generating new ML-KEM-768 Keys...');
        try {
           const cmdOut = execSync(`${BIN} vlessenc`, { encoding: 'utf-8' });
           const regex = /Authentication: ML-KEM-768[\s\S]+?"decryption":\s*"([^"]+)"[\s\S]+?"encryption":\s*"([^"]+)"/;
           const match = cmdOut.match(regex);
           if (match && match[1] && match[2]) {
               DECRYPTION = match[1]; ENCRYPTION = match[2];
               console.log(`âœ… Keys Generated. Public Key: ${ENCRYPTION.substring(0, 10)}...`);
               try { fs.writeFileSync(KEYS_FILE, JSON.stringify({ decryption: DECRYPTION, encryption: ENCRYPTION })); } catch(err) {}
           }
        } catch (keyErr) {}
    }

    // 4. Xray Run
    console.log(`âš™ï¸  Configuring Xray...`);
    fs.writeFileSync(CFG, JSON.stringify({
      log: { access: 'none', error: 'none', loglevel: 'none' },
      inbounds: [
        { 
          port: PORT, protocol: 'vless', 
          settings: { clients: [{ id: uuid, flow: "xtls-rprx-vision" }], decryption: DECRYPTION },
          streamSettings: { network: "ws", security: "tls", tlsSettings: { certificates: [{ certificateFile: CERT_FILE, keyFile: KEY_FILE }] }, wsSettings: { path: WS_PATH } }
        },
        {
          port: XHTTP_PORT, listen: '127.0.0.1', protocol: 'vless',
          settings: { clients: [{ id: uuid, flow: "xtls-rprx-vision" }], decryption: DECRYPTION },
          streamSettings: { network: "xhttp", security: "tls", tlsSettings: { certificates: [{ certificateFile: CERT_FILE, keyFile: KEY_FILE }] }, xhttpSettings: { path: XHTTP_PATH } }
        }
      ],
      outbounds: [{ protocol: 'freedom', tag: 'direct' }, { protocol: 'blackhole', tag: 'block' }]
    }));
    spawn(BIN, ['-c', CFG], { stdio: 'ignore', detached: true }).unref();
    console.log(`ðŸš€ Xray Running on ${PORT}`);

    // 5. Dufs Run (With Auth + -A)
    console.log(`ðŸ“‚ Starting Dufs on port ${WEB_PORT}...`);
    // å‚æ•°: -p ç«¯å£, -A å…è®¸æ‰€æœ‰æ“ä½œ, --bind 0.0.0.0
    const dufsArgs = [SHARE_PATH, '-p', String(WEB_PORT), '-A', '--bind', '0.0.0.0'];
    
    if (WEB_USER && WEB_PASSWORD) {
        // æ·»åŠ è®¤è¯è§„åˆ™: user:pass@/:rw
        dufsArgs.push('-a', `${WEB_USER}:${WEB_PASSWORD}@/:rw`);
    }
    
    spawn(DUFS_BIN, dufsArgs, { stdio: 'inherit', detached: true }).unref();

    // 6. FRP
    if ((needFrp1 || needFrp2) && fs.existsSync(FRPC_TAR)) {
        console.log('ðŸ“¦ Unzipping FRPC...');
        execSync(`tar -xzf ${FRPC_TAR} -C ${TMP}`);
        const frpDir = fs.readdirSync(TMP).find(name => name.startsWith('frp_') && fs.lstatSync(path.join(TMP, name)).isDirectory());
        if (frpDir) {
            fs.renameSync(path.join(TMP, frpDir, 'frpc'), FRPC_BIN);
            fs.chmodSync(FRPC_BIN, 0o755);
            startFrpcInstance(uuid, FRPS_HOST, FRPS_PORT, FRPC_TOKEN, FRPC_DOMAIN, FRPC_XHTTP_PORT, FRPC_CFG1, 'S1');
            startFrpcInstance(uuid, FRPS2_HOST, FRPS2_PORT, FRPC2_TOKEN, FRPC2_DOMAIN, FRPC2_XHTTP_PORT, FRPC_CFG2, 'S2');
        }
    }

    // 7. Argo Tunnels
    if (ENABLE_ARGO && fs.existsSync(ARGO)) {
        // [Argo 1] Xray Tunnel
        if (ENABLE_ARGO1) {
            console.log('â˜ï¸  Starting Argo 1 (Xray)...');
            if (ARGO_TOKEN && ARGO_DOMAIN) {
                spawn(ARGO, ['tunnel', 'run', '--token', ARGO_TOKEN, '--protocol', 'http2'], { stdio: 'ignore', detached: true }).unref();
                printLink(uuid, ARGO_DOMAIN, 443, `${LINK_NAME}-Argo`, 'argo');
            } else {
                const tunnel1 = spawn(ARGO, ['tunnel', '--url', `https://localhost:${PORT}`, '--no-tls-verify', '--no-autoupdate', '--protocol', 'http2'], { stdio: ['ignore', 'ignore', 'pipe'] });
                tunnel1.stderr.on('data', d => {
                  const match = d.toString().match(/(https:\/\/[a-zA-Z0-9-]+\.trycloudflare\.com)/);
                  if (match) printLink(uuid, match[1].replace('https://', ''), 443, `${LINK_NAME}-Argo`, 'argo');
                });
            }
        }

        // [Argo 2] Dufs Tunnel
        if (ENABLE_ARGO2) {
            console.log('â˜ï¸  Starting Argo 2 (Dufs)...');
            if (ARGO2_TOKEN && ARGO2_DOMAIN) {
                spawn(ARGO, ['tunnel', 'run', '--token', ARGO2_TOKEN, '--protocol', 'http2'], { stdio: 'ignore', detached: true }).unref();
                console.log(`\nðŸ”— Dufs Argo Fixed Link: https://${ARGO2_DOMAIN}\n`);
            } else {
                const tunnel2 = spawn(ARGO, ['tunnel', '--url', `http://localhost:${WEB_PORT}`, '--no-autoupdate', '--protocol', 'http2'], { stdio: ['ignore', 'ignore', 'pipe'] });
                tunnel2.stderr.on('data', d => {
                  const match = d.toString().match(/(https:\/\/[a-zA-Z0-9-]+\.trycloudflare\.com)/);
                  if (match) console.log(`\nðŸ”— Dufs Argo Temp Link: ${match[1]}\n`);
                });
            }
        }
    }
  } catch (e) {
    console.error('âŒ Fail:', e);
    process.exit(1);
  }

  setTimeout(() => {
    process.stdout.write('\033c');
    if (fs.existsSync(TMP)) fs.rmSync(TMP, { recursive: true, force: true });
    console.log('ðŸ§¹ Cleaned up');
    console.log(`\nðŸš€ Dufs running at: http://localhost:${WEB_PORT} (Serving ./share)`);
  }, 30000);
  setInterval(() => console.log('ðŸ’— Keep alive', new Date().toISOString()), 300000);
})();
// END OF FILE
