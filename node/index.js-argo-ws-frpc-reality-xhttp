const http = require('http'), https = require('https'), fs = require('fs'), path = require('path'), { spawn, execSync } = require('child_process');

// --- åŸºç¡€é…ç½® ---
const TMP = path.join(__dirname, 'tmp'), BIN = path.join(TMP, 'web'), ARGO = path.join(TMP, 'cloudflared'), CFG = path.join(TMP, 'config.json');
const ZIP = path.join(TMP, 'xray.zip');
const FRPC_BIN = path.join(TMP, 'frpc'), FRPC_TAR = path.join(TMP, 'frp.tar.gz'), FRPC_CFG = path.join(TMP, 'frpc.ini');
const CERT_FILE = path.join(TMP, 'cert.pem'), KEY_FILE = path.join(TMP, 'key.pem');
const UUID_FILE = path.join(__dirname, '.uuid');

// --- ç«¯å£åˆ†é… ---
const PORT = parseInt(process.env.SERVER_PORT || process.env.PORT || 3100); // 1. Argo WS+TLS
const TLS_PORT = PORT + 1;           // 2. FRPC TCP+Reality+Vision
const XHTTP_PORT = PORT + 2;         // 3. FRPC XHTTP+TLS
const REALITY_XHTTP_PORT = PORT + 3; // 4. FRPC XHTTP+Reality (æ–°å¢ž)
const WEB_PORT = 3000;

// --- å¤–éƒ¨å˜é‡ ---
const XRAY_URL = 'https://github.com/XTLS/Xray-core/releases/latest/download/Xray-linux-64.zip';
const ARGO_URL = 'https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64';
const CDN_HOST = 'cdns.doon.eu.org';
const LINK_NAME = process.env.LINK_NAME || 'Node'; 
const ARGO_TOKEN = process.env.ARGO_TOKEN || '';
const ARGO_DOMAIN = process.env.ARGO_DOMAIN || '';

// Argo å¼€å…³
const ENABLE_ARGO = process.env.ENABLE_ARGO !== 'false';

// ==============================================================================
//   REALITY å¯†é’¥é…ç½® (æ‰‹åŠ¨å¡«å†™)
// ==============================================================================
const REALITY_PRIVATE_KEY = process.env.REALITY_PRIVATE_KEY || 'kInkC2w6r-M0dcaW91j3oM1Q_oF2N9p2yW2yXv5c8Wc';
const REALITY_PUBLIC_KEY  = process.env.REALITY_PUBLIC_KEY  || 'o6o5U4y1z_k2r6M0dcaW91j3oM1Q_oF2N9p2yW2yXv4';
const REALITY_DEST = 'www.microsoft.com:443';
const REALITY_SNI = 'www.microsoft.com';

const MLDSA_SEED = process.env.MLDSA_SEED || ''; 
const MLDSA_POV  = process.env.MLDSA_POV  || ''; 
// ==============================================================================

// --- FRPC å˜é‡ ---
const FRPS_HOST = process.env.FRPS_HOST || '';          
const FRPS_PORT = process.env.FRPS_PORT || '7000';      
const FRPC_TOKEN = process.env.FRPC_TOKEN || '';        
// ç«¯å£æ˜ å°„é…ç½®
const FRPC_REMOTE_PORT = process.env.FRPC_REMOTE_PORT || '';       // TCP Reality
const FRPC_XHTTP_PORT = process.env.FRPC_XHTTP_PORT || '';         // XHTTP TLS
const FRPC_REALITY_XHTTP_PORT = process.env.FRPC_REALITY_XHTTP_PORT || ''; // XHTTP Reality (æ–°å¢ž)

// 1. æžç®€ HTTP æ–‡ä»¶æœåŠ¡å™¨
http.createServer((req, res) => {
  fs.createReadStream(req.url.slice(1))
    .on('error', () => res.end('Hello from Node File Server'))
    .on('open', () => res.setHeader('Content-Disposition', 'attachment'))
    .pipe(res);
}).listen(WEB_PORT);

// 2. ä¸‹è½½å·¥å…·
const download = (url, dest) => new Promise((resolve, reject) => {
  (url.startsWith('https') ? https : http).get(url, res => {
    if (res.statusCode === 301 || res.statusCode === 302) {
      if (!res.headers.location) return reject('No location');
      return download(res.headers.location, dest).then(resolve).catch(reject);
    }
    if (res.statusCode !== 200) return reject('Status ' + res.statusCode);
    const file = fs.createWriteStream(dest);
    res.pipe(file);
    file.on('finish', () => file.close(resolve));
  }).on('error', reject).setTimeout(30000, () => reject('Timeout'));
});

// 3. èŽ·å– FRP æœ€æ–°ç‰ˆæœ¬
const getFrpLatestUrl = () => new Promise((resolve) => {
    console.log('ðŸ” Checking latest FRP version...');
    https.get('https://github.com/fatedier/frp/releases/latest', (res) => {
        const loc = res.headers.location;
        if (loc) {
            const tag = path.basename(loc); 
            const ver = tag.startsWith('v') ? tag.slice(1) : tag; 
            resolve(`https://github.com/fatedier/frp/releases/download/${tag}/frp_${ver}_linux_amd64.tar.gz`);
        } else {
            resolve('https://github.com/fatedier/frp/releases/download/v0.58.1/frp_0.58.1_linux_amd64.tar.gz');
        }
    }).on('error', () => resolve('https://github.com/fatedier/frp/releases/download/v0.58.1/frp_0.58.1_linux_amd64.tar.gz'));
});

// 4. VLESS é“¾æŽ¥ç”Ÿæˆ
const printLink = (uuid, host, port, remarks, type) => {
  let link = '';
  const pqvPart = MLDSA_POV ? `&pqv=${encodeURIComponent(MLDSA_POV)}` : '';

  if (type === 'reality') {
    // TCP + REALITY + Vision
    link = `vless://${uuid}@${host}:${port}?encryption=none&flow=xtls-rprx-vision&security=reality&sni=${REALITY_SNI}&fp=chrome&pbk=${REALITY_PUBLIC_KEY}${pqvPart}&type=tcp&sid=&insecure=1#${remarks}`;
  } else if (type === 'reality-xhttp') {
    // XHTTP + REALITY (No Vision)
    link = `vless://${uuid}@${host}:${port}?encryption=none&security=reality&sni=${REALITY_SNI}&fp=chrome&pbk=${REALITY_PUBLIC_KEY}${pqvPart}&type=xhttp&path=%2Fray-x&insecure=1#${remarks}`;
  } else if (type === 'xhttp') {
    // XHTTP + TLS (Self-signed)
    link = `vless://${uuid}@${host}:${port}?encryption=none&security=tls&sni=localhost&fp=chrome&type=xhttp&path=%2Fray&insecure=1#${remarks}`;
  } else if (type === 'argo') {
    // WS + TLS (Argo)
    link = `vless://${uuid}@${CDN_HOST}:443?encryption=none&security=tls&sni=${host}&fp=chrome&type=ws&path=%2Fvless#${remarks}`;
  }
  console.log(`\nðŸ”— ${remarks} Link:\n${link}\n`);
};

// 5. ä¸»ç¨‹åº
(async () => {
  if (!fs.existsSync(UUID_FILE)) fs.writeFileSync(UUID_FILE, 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => (c === 'x' ? Math.random() * 16 | 0 : (Math.random() * 16 | 0) & 0x3 | 0x8).toString(16)));
  const uuid = fs.readFileSync(UUID_FILE, 'utf-8').trim();

  if (fs.existsSync(TMP)) fs.rmSync(TMP, { recursive: true, force: true });
  fs.mkdirSync(TMP, { recursive: true });

  try {
    console.log('ðŸ” Generating self-signed certificates for Argo & XHTTP...');
    execSync(`openssl req -x509 -newkey rsa:2048 -nodes -sha256 -keyout ${KEY_FILE} -out ${CERT_FILE} -days 3650 -subj '/CN=localhost'`);

    console.log('â³ Downloading binaries...');
    const downloadList = [download(XRAY_URL, ZIP)];
    
    if (ENABLE_ARGO) {
        console.log('â˜ï¸  Argo is ENABLED.');
        downloadList.push(download(ARGO_URL, ARGO));
    }

    // æ£€æŸ¥æ˜¯å¦éœ€è¦ä¸‹è½½ FRPC
    if (FRPS_HOST && (FRPC_REMOTE_PORT || FRPC_XHTTP_PORT || FRPC_REALITY_XHTTP_PORT)) {
        const frpUrl = await getFrpLatestUrl();
        console.log(`â¬ Downloading FRP from: ${frpUrl}`);
        downloadList.push(download(frpUrl, FRPC_TAR));
    }
    
    await Promise.all(downloadList);

    console.log('ðŸ“¦ Unzipping Xray...');
    execSync(`unzip -o ${ZIP} -d ${TMP}`);
    fs.renameSync(path.join(TMP, 'xray'), BIN);
    fs.chmodSync(BIN, 0o755);
    if (ENABLE_ARGO && fs.existsSync(ARGO)) fs.chmodSync(ARGO, 0o755);

    // --- å†™å…¥ Xray é…ç½® ---
    console.log(`âš™ï¸  Configuring Xray...`);
    
    // Reality Config (å…±ç”¨)
    const realityConfig = { 
        show: false, dest: REALITY_DEST, xver: 0, serverNames: [REALITY_SNI],
        privateKey: REALITY_PRIVATE_KEY, shortIds: ["", "a1", "b2"]
    };
    if (MLDSA_SEED) realityConfig.mldsa65Seed = MLDSA_SEED;

    fs.writeFileSync(CFG, JSON.stringify({
      log: { access: 'none', error: 'none', loglevel: 'none' },
      inbounds: [
        // 1. WS + TLS (Argo)
        { 
          port: PORT, 
          protocol: 'vless', 
          settings: { clients: [{ id: uuid }], decryption: 'none' },
          streamSettings: { 
            network: "ws", security: "tls", 
            tlsSettings: { certificates: [{ certificateFile: CERT_FILE, keyFile: KEY_FILE }] },
            wsSettings: { path: "/vless" } 
          }
        },
        // 2. TCP + Reality + Vision (FRP Port 1)
        { 
          port: TLS_PORT, 
          listen: '127.0.0.1', 
          protocol: 'vless', 
          settings: { 
            clients: [{ id: uuid, flow: "xtls-rprx-vision" }], decryption: 'none',
            fallbacks: [{ dest: REALITY_DEST }] 
          },
          streamSettings: { network: "tcp", security: "reality", realitySettings: realityConfig }
        },
        // 3. XHTTP + TLS (FRP Port 2)
        {
          port: XHTTP_PORT,
          listen: '127.0.0.1',
          protocol: 'vless',
          settings: { clients: [{ id: uuid }], decryption: 'none' },
          streamSettings: {
            network: "xhttp", security: "tls",
            tlsSettings: { certificates: [{ certificateFile: CERT_FILE, keyFile: KEY_FILE }] },
            xhttpSettings: { path: "/ray" } 
          }
        },
        // 4. XHTTP + Reality (FRP Port 3) - NEW
        {
            port: REALITY_XHTTP_PORT,
            listen: '127.0.0.1',
            protocol: 'vless',
            settings: { 
                clients: [{ id: uuid }], // Visionä¸æ”¯æŒXHTTPï¼Œæ‰€ä»¥ä¸å¡«flow
                decryption: 'none',
                fallbacks: [{ dest: REALITY_DEST }]
            },
            streamSettings: {
                network: "xhttp", 
                security: "reality",
                realitySettings: realityConfig,
                xhttpSettings: { path: "/ray-x" } // ç‹¬ç«‹çš„ path
            }
        }
      ],
      outbounds: [{ protocol: 'freedom', tag: 'direct' }, { protocol: 'blackhole', tag: 'block' }]
    }));

    spawn(BIN, ['-c', CFG], { stdio: 'ignore', detached: true }).unref();
    console.log(`ðŸš€ Core Running`);

    // E. å¯åŠ¨ FRPC
    const hasFrpConfig = FRPC_REMOTE_PORT || FRPC_XHTTP_PORT || FRPC_REALITY_XHTTP_PORT;
    if (FRPS_HOST && hasFrpConfig && fs.existsSync(FRPC_TAR)) {
        console.log('ðŸ“¦ Unzipping FRPC...');
        execSync(`tar -xzf ${FRPC_TAR} -C ${TMP}`);
        const frpDir = fs.readdirSync(TMP).find(name => name.startsWith('frp_') && fs.lstatSync(path.join(TMP, name)).isDirectory());
        if (frpDir) {
            fs.renameSync(path.join(TMP, frpDir, 'frpc'), FRPC_BIN);
            fs.chmodSync(FRPC_BIN, 0o755);

            console.log(`â˜ï¸  Starting FRPC...`);
            let iniContent = `[common]\nserver_addr = ${FRPS_HOST}\nserver_port = ${FRPS_PORT}\ntoken = ${FRPC_TOKEN}\n`;
            
            // æ˜ å°„è§„åˆ™
            if (FRPC_REMOTE_PORT) {
                iniContent += `\n[reality-${uuid.substring(0,5)}]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = ${TLS_PORT}\nremote_port = ${FRPC_REMOTE_PORT}\n`;
            }
            if (FRPC_XHTTP_PORT) {
                iniContent += `\n[xhttp-tls-${uuid.substring(0,5)}]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = ${XHTTP_PORT}\nremote_port = ${FRPC_XHTTP_PORT}\n`;
            }
            if (FRPC_REALITY_XHTTP_PORT) {
                iniContent += `\n[xhttp-reality-${uuid.substring(0,5)}]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = ${REALITY_XHTTP_PORT}\nremote_port = ${FRPC_REALITY_XHTTP_PORT}\n`;
            }

            fs.writeFileSync(FRPC_CFG, iniContent);
            spawn(FRPC_BIN, ['-c', FRPC_CFG], { stdio: 'ignore', detached: true }).unref();
            
            // è¾“å‡ºé“¾æŽ¥
            if (FRPC_REMOTE_PORT) printLink(uuid, FRPS_HOST, FRPC_REMOTE_PORT, `${LINK_NAME}-Reality-TCP`, 'reality');
            if (FRPC_XHTTP_PORT) printLink(uuid, FRPS_HOST, FRPC_XHTTP_PORT, `${LINK_NAME}-XHTTP-TLS`, 'xhttp');
            if (FRPC_REALITY_XHTTP_PORT) printLink(uuid, FRPS_HOST, FRPC_REALITY_XHTTP_PORT, `${LINK_NAME}-XHTTP-Reality`, 'reality-xhttp');
        }
    }

    // F. å¯åŠ¨ Argo
    if (ENABLE_ARGO) {
        if (ARGO_TOKEN && ARGO_DOMAIN) {
            spawn(ARGO, ['tunnel', 'run', '--token', ARGO_TOKEN, '--protocol', 'http2'], { stdio: 'ignore', detached: true }).unref();
            printLink(uuid, ARGO_DOMAIN, 443, `${LINK_NAME}-Argo`, 'argo');
        } else {
            console.log('â˜ï¸  Temp Argo Tunnel...');
            const tunnel = spawn(ARGO, ['tunnel', '--url', `https://localhost:${PORT}`, '--no-tls-verify', '--no-autoupdate', '--protocol', 'http2'], { stdio: ['ignore', 'ignore', 'pipe'] });
            tunnel.stderr.on('data', d => {
              const match = d.toString().match(/(https:\/\/[a-zA-Z0-9-]+\.trycloudflare\.com)/);
              if (match) printLink(uuid, match[1].replace('https://', ''), 443, `${LINK_NAME}-Argo`, 'argo');
            });
        }
    }
  } catch (e) {
    console.error('âŒ Fail:', e);
    process.exit(1);
  }

  setTimeout(() => {
    if (fs.existsSync(TMP)) fs.rmSync(TMP, { recursive: true, force: true });
    console.log('ðŸ§¹ Cleaned up');
  }, 30000);
  setInterval(() => console.log('ðŸ’— Keep alive', new Date().toISOString()), 300000);
})();
