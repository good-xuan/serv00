const http = require('http'), https = require('https'), fs = require('fs'), path = require('path'), { spawn, execSync } = require('child_process');

// ==============================================================================
//   1. åŸºç¡€é…ç½®ä¸Žç«¯å£
// ==============================================================================
const TMP = path.join(__dirname, 'tmp');
const BIN = path.join(TMP, 'web');              // Xray Binary
const HUB_BIN = path.join(TMP, 'hub_app');      // HubProxy Binary
const ARGO_BIN = path.join(TMP, 'cloudflared'); // Cloudflared Binary

// æ ¸å¿ƒç«¯å£å®šä¹‰
const PORT = parseInt(process.env.SERVER_PORT || process.env.PORT || 3000); 
const WEB_PORT = PORT + 1; // Filebrowser (HTTP)
const HUB_PORT = PORT + 2; // HubProxy (HTTP)

// é…ç½®æ–‡ä»¶ä¸Žèµ„æº
const CFG = path.join(TMP, 'config.json');
const ZIP = path.join(TMP, 'xray.zip');
const HUB_TAR = path.join(TMP, 'hub.tar.gz');

// --- Filebrowser ç›¸å…³æ–‡ä»¶ ---
const FB_TAR = path.join(TMP, 'fb.tar.gz');
const FB_BIN = path.join(TMP, 'filebrowser');
// æ•°æ®åº“ä¿å­˜åˆ°è„šæœ¬åŒçº§ç›®å½•ï¼Œå®žçŽ°æŒä¹…åŒ–
const FB_DB  = path.join(__dirname, 'filebrowser.db'); 

const FRPC_BIN = path.join(TMP, 'frpc');
const FRPC_TAR = path.join(TMP, 'frp.tar.gz');
const FRPC_CFG = path.join(TMP, 'frpc.ini'); 

// è¯ä¹¦ä¸ŽæŒä¹…åŒ–æ–‡ä»¶
const CERT_FILE = path.join(TMP, 'cert.pem');
const KEY_FILE = path.join(TMP, 'key.pem');
const UUID_FILE = path.join(__dirname, '.uuid');
const PASSWORD_FILE = path.join(__dirname, '.password');
const KEYS_FILE = path.join(__dirname, '.keys');
const PATHS_FILE = path.join(__dirname, '.paths');
const SHARE_PATH = path.join(__dirname, 'share');

const SAVED_LINKS = [];

// ==============================================================================
//   2. å¤–éƒ¨å˜é‡ä¸ŽçŽ¯å¢ƒé…ç½®
// ==============================================================================
const XRAY_URL = 'https://github.com/XTLS/Xray-core/releases/latest/download/Xray-linux-64.zip';
const LINK_NAME = process.env.LINK_NAME || 'Node'; 

// ç›´è¿žé…ç½®
const CDN_HOST = process.env.CDN_HOST || 'www.visa.com.sg'; 
const SERVER_IP = process.env.SERVER_IP || '127.0.0.1';              

// åè®®ä¸Žå¼€å…³
const XRAY_PROTOCOL = process.env.XRAY_PROTOCOL || 'ws'; // 'ws' or 'xhttp'
const ENABLE_XRAY = process.env.ENABLE_XRAY !== 'false'; 
const ENABLE_FB   = process.env.ENABLE_FB !== 'false';   // é»˜è®¤å¼€å¯ Filebrowser
const ENABLE_HUB  = process.env.ENABLE_HUB !== 'false';   
const SHOW_LINKS  = process.env.SHOW_LINKS === 'true'; 

// --- åŽé‡å­å¯†ç  (PQ) å¼€å…³ ---
const ENABLE_PQ = process.env.ENABLE_PQ !== 'false';
const FLOW = ENABLE_PQ ? 'xtls-rprx-vision' : '';

// --- Filebrowser Auth (å¼ºåˆ¶éªŒè¯) ---
const FB_USER = process.env.FB_USER || 'admin';
let FB_PASSWORD = process.env.FB_PASSWORD || ''; 

// --- Argo å¼€å…³ä¸Žé…ç½® ---
const ENABLE_ARGO = process.env.ENABLE_ARGO !== 'false'; 
const ENABLE_MAIN_ARGO = process.env.ENABLE_MAIN_ARGO !== 'false';
const ARGO_TOKEN = process.env.ARGO_TOKEN || '';
const ARGO_DOMAIN = process.env.ARGO_DOMAIN || '';

// Filebrowser Argo
const ENABLE_FB_ARGO = process.env.ENABLE_FB_ARGO !== 'false';
const FB_ARGO_TOKEN = process.env.FB_ARGO_TOKEN || '';
const FB_ARGO_DOMAIN = process.env.FB_ARGO_DOMAIN || '';

// Hub Argo
const ENABLE_HUB_ARGO = process.env.ENABLE_HUB_ARGO !== 'false';
const HUB_ARGO_TOKEN = process.env.HUB_ARGO_TOKEN || '';
const HUB_ARGO_DOMAIN = process.env.HUB_ARGO_DOMAIN || '';

// --- FRP Configuration ---
const FRPS_HOST = process.env.FRPS_HOST || 'uss.afrp.net';          
const FRPS_PORT = process.env.FRPS_PORT || '7000';      
const FRPS_TOKEN = process.env.FRPS_TOKEN ||  'afrp.net';        

const FRP_XRAY_DOMAIN = process.env.FRP_XRAY_DOMAIN || ''; 
const FRP_XRAY_DIRECT = process.env.FRP_XRAY_DIRECT || ''; 
const FRP_FB_DOMAIN   = process.env.FRP_FB_DOMAIN || '';   // Filebrowser FRP
const FRP_HUB_DOMAIN  = process.env.FRP_HUB_DOMAIN || '';  

const NEED_FRP = FRPS_HOST && FRPS_TOKEN && (FRP_XRAY_DOMAIN || FRP_XRAY_DIRECT || FRP_FB_DOMAIN || FRP_HUB_DOMAIN);

// ==============================================================================
//   3. åˆå§‹åŒ– (UUID, Password, Paths, Keys)
// ==============================================================================
if (!fs.existsSync(SHARE_PATH)) { try { fs.mkdirSync(SHARE_PATH); } catch(e) {} }

// UUID
let uuid = process.env.UUID || '';
if (!uuid && fs.existsSync(UUID_FILE)) { try { uuid = fs.readFileSync(UUID_FILE, 'utf-8').trim(); } catch(e) {} }
if (!uuid) {
    uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => (c === 'x' ? Math.random() * 16 | 0 : (Math.random() * 16 | 0) & 0x3 | 0x8).toString(16));
}
try { fs.writeFileSync(UUID_FILE, uuid); } catch(e) {}

// Filebrowser Password
if (!FB_PASSWORD && fs.existsSync(PASSWORD_FILE)) { try { FB_PASSWORD = fs.readFileSync(PASSWORD_FILE, 'utf-8').trim(); } catch(e) {} }
if (!FB_PASSWORD) {
    const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    for (let i = 0; i < 16; i++) FB_PASSWORD += chars.charAt(Math.floor(Math.random() * chars.length));
}
try { fs.writeFileSync(PASSWORD_FILE, FB_PASSWORD); } catch(e) {}

// Path
let WS_PATH = process.env.WS_PATH || '';
let XHTTP_PATH = process.env.XHTTP_PATH || '';
if ((!WS_PATH || !XHTTP_PATH) && fs.existsSync(PATHS_FILE)) {
    try {
        const storedPaths = JSON.parse(fs.readFileSync(PATHS_FILE, 'utf-8'));
        if (!WS_PATH) WS_PATH = storedPaths.ws || '';
        if (!XHTTP_PATH) XHTTP_PATH = storedPaths.xhttp || '';
    } catch(e) {}
}
const genPath = () => '/' + Math.random().toString(36).substring(2, 8);
if (!WS_PATH) WS_PATH = genPath();
if (!XHTTP_PATH) XHTTP_PATH = genPath();
try { fs.writeFileSync(PATHS_FILE, JSON.stringify({ ws: WS_PATH, xhttp: XHTTP_PATH })); } catch(e) {}

// Keys (ML-KEM)
let DECRYPTION = ''; 
let ENCRYPTION = '';

if (ENABLE_PQ) {
    DECRYPTION = process.env.VLESS_DECRYPTION || '';
    ENCRYPTION = process.env.VLESS_ENCRYPTION || '';
    if ((!DECRYPTION || !ENCRYPTION) && fs.existsSync(KEYS_FILE)) {
       try {
           const storedKeys = JSON.parse(fs.readFileSync(KEYS_FILE, 'utf-8'));
           if (!DECRYPTION) DECRYPTION = storedKeys.decryption || '';
           if (!ENCRYPTION) ENCRYPTION = storedKeys.encryption || '';
       } catch (e) {}
    }
}

// ==============================================================================
//   4. è¾…åŠ©å‡½æ•° (Download, FindBin, PrintLink)
// ==============================================================================
const download = (url, dest) => new Promise((resolve, reject) => {
  (url.startsWith('https') ? https : http).get(url, res => {
    if (res.statusCode === 301 || res.statusCode === 302) {
      if (!res.headers.location) return reject('No location');
      return download(res.headers.location, dest).then(resolve).catch(reject);
    }
    if (res.statusCode !== 200) return reject('Status ' + res.statusCode);
    const file = fs.createWriteStream(dest);
    res.pipe(file);
    file.on('finish', () => file.close(resolve));
  }).on('error', reject).setTimeout(30000, () => reject('Timeout'));
});

const getFrpUrl = () => new Promise((resolve) => {
    console.log('ðŸ” Checking latest FRP version...');
    const fallbackVer = '0.61.0'; 
    const fallback = `https://github.com/fatedier/frp/releases/download/v${fallbackVer}/frp_${fallbackVer}_linux_amd64.tar.gz`;
    const req = https.get('https://github.com/fatedier/frp/releases/latest', (res) => {
        try {
            if (res.statusCode === 302 && res.headers.location) {
                const parts = res.headers.location.split('/');
                let tag = parts[parts.length - 1]; 
                if (!tag.startsWith('v')) tag = 'v' + tag;
                const verNum = tag.replace(/^v/, ''); 
                resolve(`https://github.com/fatedier/frp/releases/download/${tag}/frp_${verNum}_linux_amd64.tar.gz`);
            } else { resolve(fallback); }
        } catch(e) { resolve(fallback); }
    });
    req.on('error', () => resolve(fallback));
    req.setTimeout(5000, () => { req.destroy(); resolve(fallback); });
});

const getFbUrl = () => new Promise((resolve) => {
    console.log('ðŸ” Checking Filebrowser version...');
    const fallback = 'https://github.com/filebrowser/filebrowser/releases/download/v2.32.0/linux-amd64-filebrowser.tar.gz';
    https.get('https://github.com/filebrowser/filebrowser/releases/latest', (res) => {
        try {
            if (res.statusCode === 302 && res.headers.location) {
                const tag = path.basename(res.headers.location);
                resolve(`https://github.com/filebrowser/filebrowser/releases/download/${tag}/linux-amd64-filebrowser.tar.gz`);
            } else { resolve(fallback); }
        } catch(e) { resolve(fallback); }
    }).on('error', () => resolve(fallback));
});

const getHubProxyUrl = () => new Promise((resolve) => {
    console.log('ðŸ” Checking HubProxy...');
    const fallback = 'https://github.com/sky22333/hubproxy/releases/download/v1.1.9/hubproxy-v1.1.9-linux-amd64.tar.gz';
    const req = https.get('https://github.com/sky22333/hubproxy/releases/latest', (res) => {
        try {
            if (res.statusCode === 200 || res.statusCode === 302) {
                 const loc = res.headers.location;
                 const tag = loc ? path.basename(loc) : 'v1.1.9';
                 resolve(`https://github.com/sky22333/hubproxy/releases/download/${tag}/hubproxy-${tag}-linux-amd64.tar.gz`);
            } else { resolve(fallback); }
        } catch(e) { resolve(fallback); }
    });
    req.on('error', () => resolve(fallback));
    req.setTimeout(5000, () => { req.destroy(); resolve(fallback); });
});

const findBin = (dir, name) => {
    try {
        const files = fs.readdirSync(dir, { withFileTypes: true });
        for (const f of files) {
            const fullPath = path.join(dir, f.name);
            if (f.isDirectory()) {
                const res = findBin(fullPath, name);
                if (res) return res;
            } else {
                if ((f.name === name || f.name.startsWith(name + '-')) && !f.name.endsWith('.gz') && !f.name.endsWith('.zip')) {
                    return fullPath;
                }
            }
        }
    } catch (e) {}
    return null;
};

const printLink = (uuid, host, port, remarks, type) => {
  let link = '';
  const currentPath = XRAY_PROTOCOL === 'xhttp' ? XHTTP_PATH : WS_PATH;
  const currentType = XRAY_PROTOCOL === 'xhttp' ? 'xhttp' : 'ws';
  const encParam = (ENABLE_PQ && ENCRYPTION) ? `encryption=${ENCRYPTION}&` : '';

  if (type === 'direct' || type === 'xhttp' || type === 'tcp') {
      link = `vless://${uuid}@${host}:${port}?${encParam}security=tls&sni=${CDN_HOST}&flow=${FLOW}&fp=firefox&alpn=h2&type=${currentType}&path=${encodeURIComponent(currentPath)}&insecure=1#${remarks}`;
  }
  else if (type === 'https-domain') {
      link = `vless://${uuid}@${host}:443?${encParam}security=tls&sni=${host}&flow=${FLOW}&fp=firefox&alpn=h2&type=${currentType}&path=${encodeURIComponent(currentPath)}&insecure=1#${remarks}`;
  }
  else if (type === 'argo') {
      link = `vless://${uuid}@${CDN_HOST}:443?${encParam}security=tls&flow=${FLOW}&sni=${host}&fp=firefox&alpn=h2&type=${currentType}&path=${encodeURIComponent(currentPath)}#${remarks}`;
  }
  
  const output = `ðŸ”— ${remarks} Link:\n${link}`;
  console.log(`\n${output}\n`);
  SAVED_LINKS.push(output); 
};

// å¯åŠ¨ FRP
const runFrp = () => {
    if (!NEED_FRP) return;
    console.log(`â˜ï¸  Configuring FRPC -> ${FRPS_HOST}...`);
    
    const uidSuffix = uuid.substring(0, 6);
    let ini = `[common]\nserver_addr = ${FRPS_HOST}\nserver_port = ${FRPS_PORT}\ntoken = ${FRPS_TOKEN}\n`;

    if (ENABLE_XRAY && FRP_XRAY_DOMAIN) {
        ini += `\n[xray-https-${uidSuffix}]\ntype = https\ncustom_domains = ${FRP_XRAY_DOMAIN}\nlocal_port = ${PORT}\n`;
        printLink(uuid, FRP_XRAY_DOMAIN, 443, `${LINK_NAME}-FRP-HTTPS`, 'https-domain');
    }
    if (ENABLE_XRAY && FRP_XRAY_DIRECT) {
        ini += `\n[xray-tcp-${uidSuffix}]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = ${PORT}\nremote_port = ${FRP_XRAY_DIRECT}\n`;
        printLink(uuid, FRPS_HOST, FRP_XRAY_DIRECT, `${LINK_NAME}-FRP-TCP`, 'direct');
    }
    if (ENABLE_FB && FRP_FB_DOMAIN) {
        ini += `\n[fb-http-${uidSuffix}]\ntype = http\ncustom_domains = ${FRP_FB_DOMAIN}\nlocal_port = ${WEB_PORT}\n`;
    }
    if (ENABLE_HUB && FRP_HUB_DOMAIN) {
        ini += `\n[hub-http-${uidSuffix}]\ntype = http\ncustom_domains = ${FRP_HUB_DOMAIN}\nlocal_port = ${HUB_PORT}\n`;
    }

    fs.writeFileSync(FRPC_CFG, ini);
    spawn(FRPC_BIN, ['-c', FRPC_CFG], { stdio: 'ignore', detached: true }).unref();
};

// ==============================================================================
//   5. ä¸»ç¨‹åº
// ==============================================================================

(async () => {
  let mainArgoUrl = ''; 
  let fbArgoUrl = ''; 
  let hubArgoUrl = '';  

  if (fs.existsSync(TMP)) fs.rmSync(TMP, { recursive: true, force: true });
  fs.mkdirSync(TMP, { recursive: true });

  try {
    console.log('â³ Downloading binaries...');
    const downloadList = [];
    
    if (ENABLE_XRAY) downloadList.push(download(XRAY_URL, ZIP));

    if (ENABLE_FB) {
        const fbUrl = await getFbUrl();
        console.log(`â¬ Downloading Filebrowser from ${fbUrl}`);
        downloadList.push(download(fbUrl, FB_TAR));
    }

    if (ENABLE_HUB) {
        let hubUrl;
        try { hubUrl = await getHubProxyUrl(); } catch (e) { hubUrl = 'https://github.com/sky22333/hubproxy/releases/download/v1.1.9/hubproxy-v1.1.9-linux-amd64.tar.gz'; }
        downloadList.push(download(hubUrl, HUB_TAR));
    }
    
    const argoUrl = 'https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64';
    if (ENABLE_ARGO) downloadList.push(download(argoUrl, ARGO_BIN));
    
    const frpUrl = NEED_FRP ? await getFrpUrl() : '';
    if (frpUrl) {
        console.log(`â¬ Downloading FRP from ${frpUrl}`);
        downloadList.push(download(frpUrl, FRPC_TAR));
    }

    await Promise.all(downloadList);

    // 1. Xray
    if (ENABLE_XRAY) {
        console.log('ðŸ“¦ Unzipping Xray...');
        execSync(`unzip -o ${ZIP} -d ${TMP}`);
        fs.renameSync(path.join(TMP, 'xray'), BIN); 
        fs.chmodSync(BIN, 0o755);

        console.log('ðŸ” Generating certs using Xray...');
        try {
            const certJsonStr = execSync(`${BIN} tls cert`, { encoding: 'utf-8' });
            const certData = JSON.parse(certJsonStr);
            fs.writeFileSync(CERT_FILE, certData.certificate.join('\n'));
            fs.writeFileSync(KEY_FILE, certData.key.join('\n'));
            console.log('âœ… Certs generated successfully.');
        } catch (err) {
            console.error('âš ï¸ Xray cert generation failed, creating empty fallbacks.', err.message);
            if (!fs.existsSync(CERT_FILE)) fs.writeFileSync(CERT_FILE, '');
            if (!fs.existsSync(KEY_FILE)) fs.writeFileSync(KEY_FILE, '');
        }
        
        // Keys Logic (ML-KEM)
        if (ENABLE_PQ) {
            if (DECRYPTION && ENCRYPTION) {
                console.log('âœ… Using existing ML-KEM Keys.');
            } else {
                console.log('ðŸ”‘ Generating ML-KEM Keys...');
                try {
                   const cmdOut = execSync(`${BIN} vlessenc`, { encoding: 'utf-8' });
                   const match = cmdOut.match(/Authentication: ML-KEM-768[\s\S]+?"decryption":\s*"([^"]+)"[\s\S]+?"encryption":\s*"([^"]+)"/);
                   if (match) {
                       DECRYPTION = match[1]; ENCRYPTION = match[2];
                       try { fs.writeFileSync(KEYS_FILE, JSON.stringify({ decryption: DECRYPTION, encryption: ENCRYPTION })); } catch(err) {}
                   }
                } catch (keyErr) {
                    console.log('âš ï¸ Failed to generate ML-KEM keys.');
                }
            }
        }
        
        // Configure & Start
        console.log(`âš™ï¸  Configuring Xray (${XRAY_PROTOCOL.toUpperCase()}) | PQ: ${ENABLE_PQ} | Flow: ${FLOW || 'none'}...`);
        
        const wsSettings = { network: "ws", security: "tls", tlsSettings: { certificates: [{ certificateFile: CERT_FILE, keyFile: KEY_FILE }] }, wsSettings: { path: WS_PATH } };
        const xhttpSettings = { network: "xhttp", security: "tls", tlsSettings: { certificates: [{ certificateFile: CERT_FILE, keyFile: KEY_FILE }] }, xhttpSettings: { path: XHTTP_PATH } };
        
        const streamSettings = XRAY_PROTOCOL === 'xhttp' ? xhttpSettings : wsSettings;
        const decryptionValue = (ENABLE_PQ && DECRYPTION) ? DECRYPTION : "none";

        fs.writeFileSync(CFG, JSON.stringify({
          log: { access: 'none', error: 'none', loglevel: 'none' },
          inbounds: [
            { 
                port: PORT, 
                listen: '0.0.0.0', 
                protocol: 'vless', 
                settings: { 
                    clients: [{ id: uuid, flow: FLOW }], 
                    decryption: decryptionValue 
                }, 
                streamSettings: streamSettings 
            }
          ],
          dns: {servers:["https+local://1.1.1.1/dns-query"], disableCache: true},
          outbounds: [{ protocol: 'freedom', tag: 'direct' }, { protocol: 'blackhole', tag: 'block' }]
        }));
        
        spawn(BIN, ['-c', CFG], { stdio: 'ignore', detached: true }).unref();
        console.log(`ðŸš€ Xray Running on ${PORT} (${XRAY_PROTOCOL})`);

        if (SERVER_IP) {
            printLink(uuid, SERVER_IP, PORT, `${LINK_NAME}-Direct-IP`, 'direct');
        }
    }

    // 2. Filebrowser (FB)
    if (ENABLE_FB) {
        console.log(`ðŸ“¦ Unzipping Filebrowser...`);
        execSync(`tar -xzf ${FB_TAR} -C ${TMP}`);
        const fbFound = findBin(TMP, 'filebrowser');
        if (fbFound && fbFound !== FB_BIN) fs.renameSync(fbFound, FB_BIN);
        fs.chmodSync(FB_BIN, 0o755);

        // --- é€»è¾‘ä¿®æ”¹ï¼šæ— è®ºæ•°æ®åº“æ˜¯å¦å­˜åœ¨ï¼Œéƒ½ç¡®ä¿å½“å‰ç”¨æˆ·å¯†ç æ­£ç¡® ---
        if (!fs.existsSync(FB_DB)) {
            console.log(`ðŸ”’ Initializing Filebrowser Database (User: ${FB_USER})...`);
            // åˆå§‹åŒ– DB
            execSync(`${FB_BIN} config init --database ${FB_DB}`, { stdio: 'ignore' });
            // é…ç½®åˆå§‹è®¾ç½®
            execSync(`${FB_BIN} config set --address 0.0.0.0 --port ${WEB_PORT} --database ${FB_DB} --root ${SHARE_PATH}`, { stdio: 'ignore' });
            // æ·»åŠ ç®¡ç†å‘˜ç”¨æˆ·
            execSync(`${FB_BIN} users add ${FB_USER} ${FB_PASSWORD} --perm.admin --database ${FB_DB}`, { stdio: 'ignore' });
        } else {
            console.log(`â™»ï¸  Updating Filebrowser Password for ${FB_USER}...`);
            // å°è¯•æ›´æ–°å¯†ç ï¼Œä¿è¯ä¸ŽçŽ¯å¢ƒå˜é‡ä¸€è‡´
            try {
                execSync(`${FB_BIN} users update ${FB_USER} --password ${FB_PASSWORD} --database ${FB_DB}`, { stdio: 'ignore' });
            } catch (e) {
                // å¦‚æžœæ›´æ–°å¤±è´¥ï¼ˆä¾‹å¦‚ç”¨æˆ·ä¹‹å‰è¢«æ‰‹åŠ¨åˆ é™¤ï¼‰ï¼Œå°è¯•é‡æ–°æ·»åŠ 
                try {
                    execSync(`${FB_BIN} users add ${FB_USER} ${FB_PASSWORD} --perm.admin --database ${FB_DB}`, { stdio: 'ignore' });
                } catch(e2) {}
            }
        }

        console.log(`ðŸ“‚ Starting Filebrowser on ${WEB_PORT}...`);
        
        // å¯åŠ¨æ—¶æ˜¾å¼æŒ‡å®šç«¯å£å’Œæ ¹ç›®å½•ï¼Œè¦†ç›– DB ä¸­çš„æ—§é…ç½®
        spawn(FB_BIN, [
            '--database', FB_DB, 
            '--port', String(WEB_PORT), 
            '--address', '0.0.0.0',
            '--root', SHARE_PATH,
            '--noauth=false'
        ], { stdio: 'ignore', detached: true }).unref();
    }

    // 3. HubProxy
    if (ENABLE_HUB) {
        console.log(`ðŸ“¦ Unzipping HubProxy...`);
        execSync(`tar -xzf ${HUB_TAR} -C ${TMP}`);
        const hubFound = findBin(TMP, 'hubproxy');
        if (hubFound) {
            if (hubFound !== HUB_BIN) fs.renameSync(hubFound, HUB_BIN);
            fs.chmodSync(HUB_BIN, 0o755);
        }
        console.log(`ðŸ³ HubProxy Running on ${HUB_PORT}`);
        spawn(HUB_BIN, ['--addr', `:${HUB_PORT}`], {
            stdio: 'ignore',
            detached: true,
            env: { ...process.env, PORT: String(HUB_PORT), SERVER_PORT: String(HUB_PORT) }
        }).unref();
    }

    if (ENABLE_ARGO && fs.existsSync(ARGO_BIN)) fs.chmodSync(ARGO_BIN, 0o755);

    // 4. Start FRP
    if (NEED_FRP && fs.existsSync(FRPC_TAR)) {
        console.log('ðŸ“¦ Unzipping FRPC...');
        execSync(`tar -xzf ${FRPC_TAR} -C ${TMP}`);
        const frpFound = findBin(TMP, 'frpc');
        if (frpFound) {
            fs.renameSync(frpFound, FRPC_BIN);
            fs.chmodSync(FRPC_BIN, 0o755);
            runFrp(); 
        }
    }

    // 5. Start Argo Tunnels
    if (ENABLE_ARGO && fs.existsSync(ARGO_BIN)) {
        if (ENABLE_XRAY && ENABLE_MAIN_ARGO) {
            if (ARGO_TOKEN && ARGO_DOMAIN) {
                spawn(ARGO_BIN, ['tunnel', 'run', '--token', ARGO_TOKEN], { stdio: 'ignore', detached: true }).unref();
                printLink(uuid, ARGO_DOMAIN, 443, `${LINK_NAME}-Argo`, 'argo');
            } else {
                const t1 = spawn(ARGO_BIN, ['tunnel', '--url', `https://localhost:${PORT}`, '--no-tls-verify', '--no-autoupdate'], { stdio: ['ignore', 'ignore', 'pipe'] });
                t1.stderr.on('data', d => {
                    const m = d.toString().match(/(https:\/\/[a-zA-Z0-9-]+\.trycloudflare\.com)/);
                    if (m) {
                        mainArgoUrl = m[1]; 
                        printLink(uuid, m[1].replace('https://', ''), 443, `${LINK_NAME}-Argo`, 'argo');
                    }
                });
            }
        }
        if (ENABLE_FB && ENABLE_FB_ARGO) {
            if (FB_ARGO_TOKEN && FB_ARGO_DOMAIN) {
                fbArgoUrl = `https://${FB_ARGO_DOMAIN}`;
                spawn(ARGO_BIN, ['tunnel', 'run', '--token', FB_ARGO_TOKEN], { stdio: 'ignore', detached: true }).unref();
            } else {
                const t2 = spawn(ARGO_BIN, ['tunnel', '--url', `http://localhost:${WEB_PORT}`, '--no-autoupdate'], { stdio: ['ignore', 'ignore', 'pipe'] });
                t2.stderr.on('data', d => {
                    const m = d.toString().match(/(https:\/\/[a-zA-Z0-9-]+\.trycloudflare\.com)/);
                    if (m) fbArgoUrl = m[1]; 
                });
            }
        }
        if (ENABLE_HUB && ENABLE_HUB_ARGO) {
            if (HUB_ARGO_TOKEN && HUB_ARGO_DOMAIN) {
                hubArgoUrl = `https://${HUB_ARGO_DOMAIN}`;
                spawn(ARGO_BIN, ['tunnel', 'run', '--token', HUB_ARGO_TOKEN], { stdio: 'ignore', detached: true }).unref();
            } else {
                const t3 = spawn(ARGO_BIN, ['tunnel', '--url', `http://localhost:${HUB_PORT}`, '--no-autoupdate'], { stdio: ['ignore', 'ignore', 'pipe'] });
                t3.stderr.on('data', d => {
                    const m = d.toString().match(/(https:\/\/[a-zA-Z0-9-]+\.trycloudflare\.com)/);
                    if (m) hubArgoUrl = m[1]; 
                });
            }
        }
    }
  } catch (e) {
    console.error('âŒ Fail:', e);
    process.exit(1);
  }

  const showDetails = () => {
      if (ENABLE_FB) {
        console.log(`\nðŸ“‚ Filebrowser: http://localhost:${WEB_PORT} (User: ${FB_USER}, Pass: ${FB_PASSWORD})`);
        if (ENABLE_FB_ARGO && fbArgoUrl) console.log(`ðŸ”— Argo URL: ${fbArgoUrl}`);
        if (FRP_FB_DOMAIN) console.log(`â˜ï¸  FRP URL: http://${FRP_FB_DOMAIN}`);
      }
      
      if (ENABLE_HUB) {
        console.log(`\nðŸ³ HubProxy: http://localhost:${HUB_PORT}`);
        if (ENABLE_HUB_ARGO && hubArgoUrl) console.log(`ðŸ”— Argo URL: ${hubArgoUrl}`);
        if (FRP_HUB_DOMAIN) console.log(`â˜ï¸  FRP URL: http://${FRP_HUB_DOMAIN}`);
      }
      
      if (SHOW_LINKS && SAVED_LINKS.length > 0) {
          console.log('\n--- Saved Links ---');
          SAVED_LINKS.forEach(link => console.log(link));
          console.log('-------------------\n');
      }
  };

  setTimeout(() => {
    process.stdout.write('\033c');
    if (fs.existsSync(TMP)) fs.rmSync(TMP, { recursive: true, force: true });
    console.log('ðŸ§¹ Cleaned up (TMP deleted, DB saved)');
    showDetails();
  }, 30000);

  setInterval(() => {
    process.stdout.write('\033c');
    console.log(`\nðŸ•’ 6-Hour Report: ${new Date().toISOString()}`);
    showDetails();
  }, 21600000);

  setInterval(() => console.log('ðŸ’— Keep alive', new Date().toISOString()), 300000);
})();
