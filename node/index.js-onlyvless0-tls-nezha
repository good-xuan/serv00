const http = require('http'), https = require('https'), fs = require('fs'), path = require('path'), { spawn, execSync } = require('child_process');

// --- åŸºç¡€é…ç½® ---
const TMP = path.join(__dirname, 'tmp'), BIN = path.join(TMP, 'web'), ARGO = path.join(TMP, 'cloudflared'), CFG = path.join(TMP, 'config.json');
const ZIP = path.join(TMP, 'xray.zip');
const AGENT_BIN = path.join(TMP, 'nezha-agent'), AGENT_ZIP = path.join(TMP, 'agent.zip');
const NEZHA_CFG = path.join(TMP, 'nezha.yml'); // å“ªå’é…ç½®æ–‡ä»¶
const CERT_FILE = path.join(TMP, 'cert.pem'), KEY_FILE = path.join(TMP, 'key.pem');
const PORT = process.env.SERVER_PORT || process.env.PORT || 3100;
const UUID_FILE = path.join(__dirname, '.uuid');

// --- å¤–éƒ¨èµ„æº ---
const XRAY_URL = 'https://github.com/XTLS/Xray-core/releases/latest/download/Xray-linux-64.zip';
const ARGO_URL = 'https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64';
const NEZHA_URL = 'https://github.com/nezhahq/agent/releases/latest/download/nezha-agent_linux_amd64.zip';
const CDN_HOST = 'cdns.doon.eu.org';

// --- çŽ¯å¢ƒå˜é‡é…ç½® ---
const LINK_NAME = process.env.LINK_NAME || 'Argo-Node'; 
const ARGO_TOKEN = process.env.ARGO_TOKEN || '';
const ARGO_DOMAIN = process.env.ARGO_DOMAIN || '';

// --- å“ªå’ç›‘æŽ§é…ç½® ---
const NEZHA_SERVER = process.env.NEZHA_SERVER || '';
const NEZHA_KEY = process.env.NEZHA_KEY || '';
const NEZHA_TLS = process.env.NEZHA_TLS || 'true'; 

// 1. æžç®€ HTTP æ–‡ä»¶æœåŠ¡å™¨
http.createServer((req, res) => {
  fs.createReadStream(req.url.slice(1))
    .on('error', () => res.end('hello'))
    .on('open', () => res.setHeader('Content-Disposition', 'attachment'))
    .pipe(res);
}).listen(3000);

// 2. ä¸‹è½½å·¥å…·
const download = (url, dest) => new Promise((resolve, reject) => {
  (url.startsWith('https') ? https : http).get(url, res => {
    if (res.statusCode === 301 || res.statusCode === 302) {
      if (!res.headers.location) return reject('No location');
      return download(res.headers.location, dest).then(resolve).catch(reject);
    }
    if (res.statusCode !== 200) return reject('Status ' + res.statusCode);
    const file = fs.createWriteStream(dest);
    res.pipe(file);
    file.on('finish', () => file.close(resolve));
  }).on('error', reject).setTimeout(30000, () => reject('Timeout'));
});

// 3. VLESS é“¾æŽ¥ç”Ÿæˆ
const printLink = (uuid, host) => {
  const link = `vless://${uuid}@${CDN_HOST}:443?encryption=none&security=tls&sni=${host}&fp=firefox&alpn=h2&insecure=0&allowInsecure=0&type=ws&path=%2Fvless%3Fed%3D2560#${LINK_NAME}`;
  console.log(`\nðŸ”— VLESS Link:\n${link}\n`);
};

// 4. ä¸»ç¨‹åº
(async () => {
  // UUID
  if (!fs.existsSync(UUID_FILE)) fs.writeFileSync(UUID_FILE, 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => (c === 'x' ? Math.random() * 16 | 0 : (Math.random() * 16 | 0) & 0x3 | 0x8).toString(16)));
  const uuid = fs.readFileSync(UUID_FILE, 'utf-8').trim();

  // åˆå§‹åŒ–ç›®å½•
  if (fs.existsSync(TMP)) fs.rmSync(TMP, { recursive: true, force: true });
  fs.mkdirSync(TMP, { recursive: true });

  try {
    // A. ç”Ÿæˆè‡ªç­¾åè¯ä¹¦
    console.log('ðŸ” Generating certificates...');
    execSync(`openssl req -x509 -newkey rsa:2048 -nodes -sha256 -keyout ${KEY_FILE} -out ${CERT_FILE} -days 3650 -subj '/CN=localhost'`);
    
    // B. å†™å…¥ Xray é…ç½®
    fs.writeFileSync(CFG, JSON.stringify({
      log: { access: 'none', error: 'none', loglevel: 'none' },
      inbounds: [
        { 
          port: PORT, protocol: 'vless', settings: { clients: [{ id: uuid }], decryption: 'none', fallbacks: [{ dest: 3001 }, { path: '/hello', dest: 3000 }, { path: '/web', dest: 3000 }, { path: '/vless', dest: 3002 }] },
          streamSettings: { network: "tcp", security: "tls", tlsSettings: { certificates: [{ certificateFile: CERT_FILE, keyFile: KEY_FILE }] } }
        },
        { port: 3001, listen: '127.0.0.1', protocol: 'vless', settings: { clients: [{ id: uuid }], decryption: 'none' }, streamSettings: { network: 'xhttp', xhttpSettings: { path: '/xhttp' } } },
        { port: 3002, listen: '127.0.0.1', protocol: 'vless', settings: { clients: [{ id: uuid }], decryption: 'none' }, streamSettings: { network: 'ws', wsSettings: { path: '/vless' } } }
      ],
      dns: { servers: ["https+local://1.1.1.1/dns-query"], disableCache: true },
      outbounds: [{ protocol: 'freedom', tag: 'direct' }, { protocol: 'blackhole', tag: 'block' }]
    }));

    // C. ä¸‹è½½æ–‡ä»¶ (å¹¶è¡Œ)
    console.log('â³ Downloading binaries...');
    const downloads = [download(XRAY_URL, ZIP), download(ARGO_URL, ARGO)];
    if (NEZHA_SERVER && NEZHA_KEY) downloads.push(download(NEZHA_URL, AGENT_ZIP));
    await Promise.all(downloads);

    // D. è§£åŽ‹ä¸Žé…ç½®
    console.log('ðŸ“¦ Unzipping...');
    execSync(`unzip -o ${ZIP} -d ${TMP}`);
    fs.renameSync(path.join(TMP, 'xray'), BIN);
    fs.chmodSync(BIN, 0o755);
    fs.chmodSync(ARGO, 0o755);

    // E. å¯åŠ¨ Nezha Agent (ä½¿ç”¨è¯¦ç»†é…ç½®)
    if (NEZHA_SERVER && NEZHA_KEY) {
      console.log('ðŸ”” Installing Nezha Agent...');
      execSync(`unzip -o ${AGENT_ZIP} -d ${TMP}`);
      if (fs.existsSync(path.join(TMP, 'nezha-agent'))) {
          fs.renameSync(path.join(TMP, 'nezha-agent'), AGENT_BIN);
      }
      fs.chmodSync(AGENT_BIN, 0o755);

      // --- ç”Ÿæˆé…ç½®æ–‡ä»¶ (åŸºäºŽä½ æä¾›çš„æ¨¡æ¿) ---
      const isTls = NEZHA_TLS === 'true' || NEZHA_TLS === '1';
      const nezhaYamlContent = `
client_secret: "${NEZHA_KEY}"
debug: false
disable_auto_update: false
disable_command_execute: false
disable_force_update: false
disable_nat: false
disable_send_query: false
gpu: false
insecure_tls: false
ip_report_period: 1800
report_delay: 3
self_update_period: 0
server: "${NEZHA_SERVER}"
skip_connection_count: false
skip_procs_count: false
temperature: false
tls: ${isTls}
use_gitee_to_upgrade: false
use_ipv6_country_code: false
uuid: "${uuid}"
`;
      fs.writeFileSync(NEZHA_CFG, nezhaYamlContent);

      // å¯åŠ¨
      spawn(AGENT_BIN, ['-c', NEZHA_CFG], { stdio: 'ignore', detached: true }).unref();
      console.log(`ðŸ”” Nezha Agent Running: ${NEZHA_SERVER}`);
    }

    // F. å¯åŠ¨ Xray
    spawn(BIN, ['-c', CFG], { stdio: 'ignore', detached: true }).unref();
    console.log(`ðŸš€ Core Running | UUID: ${uuid} | Port: ${PORT}`);

    // G. å¯åŠ¨ Argo
    if (ARGO_TOKEN && ARGO_DOMAIN) {
        console.log(`â˜ï¸  Static Argo Tunnel: ${ARGO_DOMAIN}`);
        spawn(ARGO, ['tunnel', 'run', '--token', ARGO_TOKEN, '--protocol', 'http2'], { stdio: 'ignore', detached: true }).unref();
        printLink(uuid, ARGO_DOMAIN);
    } else {
        console.log('â˜ï¸  Temp Argo Tunnel...');
        const tunnel = spawn(ARGO, ['tunnel', '--url', `https://localhost:${PORT}`, '--no-autoupdate', '--no-tls-verify', '--protocol', 'http2'], { stdio: ['ignore', 'ignore', 'pipe'] });
        tunnel.stderr.on('data', d => {
          const match = d.toString().match(/(https:\/\/[a-zA-Z0-9-]+\.trycloudflare\.com)/);
          if (match) {
            const domain = match[1].replace('https://', '');
            console.log(`ðŸš‡ Domain: ${domain}`);
            printLink(uuid, domain);
          }
        });
    }
  } catch (e) {
    console.error('âŒ Fail:', e);
    process.exit(1);
  }

  // H. æ¸…ç†ä¸Žä¿æ´»
  setTimeout(() => {
    if (fs.existsSync(TMP)) fs.rmSync(TMP, { recursive: true, force: true });
    console.log('ðŸ§¹ Cleaned up');
  }, 30000);

  setInterval(() => console.log('ðŸ’— Keep alive', new Date().toISOString()), 300000);
})();
