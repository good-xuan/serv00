const http = require('http'), https = require('https'), fs = require('fs'), path = require('path'), { spawn } = require('child_process');

const TMP = path.join(__dirname, 'tmp'), BIN = path.join(TMP, 'web'), ARGO = path.join(TMP, 'cloudflared'), CFG = path.join(TMP, 'config.json');
const PORT = process.env.SERVER_PORT || process.env.PORT || 3100;
const UUID_FILE = path.join(__dirname, '.uuid');
const URLS = [process.env.DOWNLOAD_WEB || 'http://fi10.bot-hosting.net:20980/web', process.env.DOWNLOAD_WEB_BACKUP || 'https://amd64.ssss.nyc.mn/web'];
const ARGO_URL = 'https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64';
const CDN_HOST = 'cdns.doon.eu.org'; // å›ºå®šä¼˜é€‰åŸŸå

// 1. æžç®€ HTTP æ–‡ä»¶æœåŠ¡å™¨
http.createServer((req, res) => {
  fs.createReadStream(req.url.slice(1))
    .on('error', () => res.end('hello'))
    .on('open', () => res.setHeader('Content-Disposition', 'attachment'))
    .pipe(res);
}).listen(3000);

// 2. ä¸‹è½½å·¥å…·
const download = (url, dest) => new Promise((resolve, reject) => {
  (url.startsWith('https') ? https : http).get(url, res => {
    if (res.statusCode === 301 || res.statusCode === 302) {
      if (!res.headers.location) return reject('No location');
      return download(res.headers.location, dest).then(resolve).catch(reject);
    }
    if (res.statusCode !== 200) return reject('Status ' + res.statusCode);
    const file = fs.createWriteStream(dest);
    res.pipe(file);
    file.on('finish', () => file.close(resolve));
  }).on('error', reject).setTimeout(30000, () => reject('Timeout'));
});

// 3. ä¸»ç¨‹åº
(async () => {
  if (!fs.existsSync(UUID_FILE)) fs.writeFileSync(UUID_FILE, 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => (c === 'x' ? Math.random() * 16 | 0 : (Math.random() * 16 | 0) & 0x3 | 0x8).toString(16)));
  const uuid = fs.readFileSync(UUID_FILE, 'utf-8').trim();

  fs.rmSync(TMP, { recursive: true, force: true });
  fs.mkdirSync(TMP, { recursive: true });

  fs.writeFileSync(CFG, JSON.stringify({
    log: { access: 'none', error: 'none', loglevel: 'none' },
    inbounds: [
      { port: PORT, protocol: 'vless', settings: { clients: [{ id: uuid }], decryption: 'none', fallbacks: [{ dest: 3001 }, { path: '/hello', dest: 3000 }, { path: '/web', dest: 3000 }, { path: '/vless', dest: 3002 }] } },
      { port: 3001, listen: '127.0.0.1', protocol: 'vless', settings: { clients: [{ id: uuid }], decryption: 'none' }, streamSettings: { network: 'xhttp', xhttpSettings: { path: uuid } } },
      { port: 3002, listen: '127.0.0.1', protocol: 'vless', settings: { clients: [{ id: uuid }], decryption: 'none' }, streamSettings: { network: 'ws', wsSettings: { path: '/vless' } } }
    ],
    outbounds: [{ protocol: 'freedom', tag: 'direct' }, { protocol: 'blackhole', tag: 'block' }]
  }));

  try {
    console.log('â³ Downloading binaries...');
    await Promise.all([download(URLS[0], BIN).catch(() => download(URLS[1], BIN)), download(ARGO_URL, ARGO)]);

    fs.chmodSync(BIN, 0o755);
    fs.chmodSync(ARGO, 0o755);
    spawn(BIN, ['-c', CFG], { stdio: 'ignore', detached: true }).unref();
    console.log(`ðŸš€ Core Running | UUID: ${uuid} | Port: ${PORT}`);

    const tunnel = spawn(ARGO, ['tunnel', '--url', `http://localhost:${PORT}`, '--no-autoupdate'], { stdio: ['ignore', 'ignore', 'pipe'] });
    tunnel.stderr.on('data', d => {
      const match = d.toString().match(/(https:\/\/[a-zA-Z0-9-]+\.trycloudflare\.com)/);
      if (match) {
        const argo = match[1].replace('https://', '');
        console.log(`\nðŸš‡ Argo Domain: ${argo}`);
        
        // æŒ‰ç…§ä½ è¦æ±‚çš„æ ¼å¼ç”Ÿæˆ
        const link = `vless://${uuid}@${CDN_HOST}:443?encryption=none&security=tls&sni=${argo}&fp=firefox&alpn=h2&insecure=0&allowInsecure=0&type=ws&path=%2Fvless#Argo-Node`;
        
        console.log(`\nðŸ”— VLESS Link:\n${link}\n`);
      }
    });
  } catch (e) {
    console.error('âŒ Fail:', e);
    process.exit(1);
  }

  setTimeout(() => fs.rmSync(TMP, { recursive: true, force: true }), 120000);
  setInterval(() => console.log('ðŸ’— Keep alive', new Date().toISOString()), 300000);
})();
