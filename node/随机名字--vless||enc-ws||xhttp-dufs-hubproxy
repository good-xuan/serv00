const http = require('http'), https = require('https'), fs = require('fs'), path = require('path'), { spawn, execSync } = require('child_process');

// ==============================================================================
//   1. åŸºç¡€é…ç½®ä¸Žé˜²ç‰¹å¾æ£€æµ‹ (Obfuscation)
// ==============================================================================
const TMP = path.join(__dirname, 'tmp');

// éšæœºç”Ÿæˆ 4-8 ä½å­—ç¬¦ä¸²
// ä½œç”¨ï¼šæ··æ·†ä¸‹è½½çš„æ–‡ä»¶åå’ŒåŽ‹ç¼©åŒ…åï¼Œé˜²æ­¢äº‘å¹³å°é€šè¿‡æ–‡ä»¶åæ‰«æè¿›è¡Œç‰¹å¾æ£€æµ‹
const randomStr = () => Math.random().toString(36).substring(2, 6 + Math.floor(Math.random() * 5));

// å®šä¹‰éšæœºæ–‡ä»¶å (Binaries & Archives)
const BIN_NAME = randomStr();             
const DUFS_NAME = randomStr();           
const HUB_NAME = randomStr();             
const ARGO_NAME = randomStr();           
const FRPC_NAME = randomStr();           

const ZIP_NAME = randomStr() + '.zip';  
const DUFS_TAR_NAME = randomStr() + '.tar.gz';
const HUB_TAR_NAME = randomStr() + '.tar.gz';
const FRPC_TAR_NAME = randomStr() + '.tar.gz';
const LINKS_FILE_NAME = `LINK-${randomStr()}.txt`; // æœ€ç»ˆé“¾æŽ¥ä¿å­˜çš„æ–‡ä»¶å

// æž„é€ å®Œæ•´çš„æ–‡ä»¶è·¯å¾„
const BIN = path.join(TMP, BIN_NAME);
const DUFS_BIN = path.join(TMP, DUFS_NAME);
const HUB_BIN = path.join(TMP, HUB_NAME);
const ARGO_BIN = path.join(TMP, ARGO_NAME);
const FRPC_BIN = path.join(TMP, FRPC_NAME);
const LINKS_PATH = path.join(TMP, LINKS_FILE_NAME);
const CFG = path.join(TMP, 'config.json');      // Xray é…ç½®æ–‡ä»¶
const FRPC_CFG = path.join(TMP, 'frpc.ini');    // FRP é…ç½®æ–‡ä»¶
const ZIP = path.join(TMP, ZIP_NAME);
const DUFS_TAR = path.join(TMP, DUFS_TAR_NAME);
const HUB_TAR = path.join(TMP, HUB_TAR_NAME);
const FRPC_TAR = path.join(TMP, FRPC_TAR_NAME);
const CERT_FILE = path.join(TMP, 'cert.pem');   // è‡ªç­¾ TLS è¯ä¹¦
const KEY_FILE = path.join(TMP, 'key.pem');     // è‡ªç­¾ TLS ç§é’¥

// æŒä¹…åŒ–æ–‡ä»¶è·¯å¾„ (ç”¨äºŽåœ¨å®¹å™¨é‡å¯åŽä¿æŒ UUIDã€å¯†ç ç­‰ä¿¡æ¯ä¸å˜)
const UUID_FILE = path.join(__dirname, '.uuid');
const PASSWORD_FILE = path.join(__dirname, '.password');
const KEYS_FILE = path.join(__dirname, '.keys');
const PATHS_FILE = path.join(__dirname, '.paths');
const SHARE_PATH = path.join(__dirname, 'share'); // Dufs é»˜è®¤å…±äº«ç›®å½•

// å†…å­˜å­˜å‚¨ï¼šç”¨äºŽå­˜æ”¾å…¬å¼€çš„é“¾æŽ¥ (å¦‚ Dufs/Hub çš„ Argo é“¾æŽ¥)ï¼Œä»¥ä¾¿å®šæ—¶è¾“å‡ºåˆ°æŽ§åˆ¶å°
const PUBLIC_LINKS = [];

// ç«¯å£åˆ†é…
const PORT = parseInt(process.env.SERVER_PORT || process.env.PORT || 3000); // ä¸»ç«¯å£ (PaaS å¹³å°åˆ†é…)
const WEB_PORT = PORT + 1; // Dufs æ–‡ä»¶æœåŠ¡å†…éƒ¨ç«¯å£
const HUB_PORT = PORT + 2; // HubProxy æœåŠ¡å†…éƒ¨ç«¯å£

// ==============================================================================
//   2. çŽ¯å¢ƒé…ç½®ä¸Žå¼€å…³ (Environment Variables) - æ ¸å¿ƒæŽ§åˆ¶åŒº
// ==============================================================================
const XRAY_URL = 'https://github.com/XTLS/Xray-core/releases/latest/download/Xray-linux-64.zip';

const LINK_NAME = process.env.LINK_NAME || 'Node';        // ç”Ÿæˆé“¾æŽ¥æ—¶çš„å¤‡æ³¨å‰ç¼€
const CDN_HOST = process.env.CDN_HOST || 'www.visa.com.sg'; // ä¼ªè£…åŸŸå (ç”¨äºŽ SNI å’Œ Argo å®¿ä¸»)
const SERVER_IP = process.env.SERVER_IP || '127.0.0.1';     // å¦‚æžœä½ çŸ¥é“æœåŠ¡å™¨çœŸå®žIPï¼Œå¡«å…¥å¯ç”Ÿæˆç›´è¿žé“¾æŽ¥

// --- Xray é…ç½® ---
const XRAY_PROTOCOL = process.env.XRAY_PROTOCOL || 'ws'; // ä¼ è¾“åè®®: 'ws' æˆ– 'xhttp'
const ENABLE_XRAY = process.env.ENABLE_XRAY !== 'false'; // Xray æ€»å¼€å…³
const ENABLE_PQ = process.env.ENABLE_PQ !== 'false';     // æ˜¯å¦å¼€å¯æŠ—é‡å­åŠ å¯† (ML-KEM)
const FLOW = ENABLE_PQ ? 'xtls-rprx-vision' : '';        // å¼€å¯ PQ æ—¶å¿…é¡»ä½¿ç”¨ Vision æµæŽ§

// --- Dufs æ–‡ä»¶æœåŠ¡å™¨é…ç½® ---
const ENABLE_DUFS = process.env.ENABLE_DUFS !== 'false';           // Dufs æ€»å¼€å…³
const ENABLE_DUFS_AUTH = process.env.ENABLE_DUFS_AUTH === 'true';  // æ˜¯å¦å¼€å¯ Dufs å¯†ç è®¿é—®
const DUFS_USER = process.env.DUFS_USER || 'admin';                // Dufs ç”¨æˆ·å
let DUFS_PASSWORD = process.env.DUFS_PASSWORD || '';               // Dufs å¯†ç 

// --- HubProxy å®¹å™¨é•œåƒåŠ é€Ÿé…ç½® ---
const ENABLE_HUB = process.env.ENABLE_HUB !== 'false'; // HubProxy æ€»å¼€å…³

// --- Argo (Cloudflare Tunnel) é…ç½® ---
// 1. ç¨‹åºå¼€å…³
const ENABLE_CLOUDFLARED = process.env.ENABLE_CLOUDFLARED !== 'false'; // æ€»å¼€å…³ï¼šæ˜¯å¦ä¸‹è½½/è¿è¡Œ cloudflared
// 2. ä¸šåŠ¡å¼€å…³ (Xray)
const ENABLE_ARGO_XRAY = process.env.ENABLE_ARGO_XRAY !== 'false';     // æ˜¯å¦æŠŠ Xray ä»£ç†é€šè¿‡ Argo æš´éœ²
const ARGO_TOKEN = process.env.ARGO_TOKEN || '';                       // Xray ç”¨çš„å›ºå®š Tunnel Token
const ARGO_DOMAIN = process.env.ARGO_DOMAIN || '';                     // Xray ç”¨çš„å›ºå®šåŸŸå
// 3. ä¸šåŠ¡å¼€å…³ (Dufs)
const ENABLE_DUFS_ARGO = process.env.ENABLE_DUFS_ARGO !== 'false'; 
const DUFS_ARGO_TOKEN = process.env.DUFS_ARGO_TOKEN || '';         
const DUFS_ARGO_DOMAIN = process.env.DUFS_ARGO_DOMAIN || '';       
// 4. ä¸šåŠ¡å¼€å…³ (HubProxy)
const ENABLE_HUB_ARGO = process.env.ENABLE_HUB_ARGO !== 'false';   
const HUB_ARGO_TOKEN = process.env.HUB_ARGO_TOKEN || '';           
const HUB_ARGO_DOMAIN = process.env.HUB_ARGO_DOMAIN || '';         

// --- FRP å†…ç½‘ç©¿é€é…ç½® ---
const FRPS_HOST = process.env.FRPS_HOST || 'uss.afrp.net'; // FRP æœåŠ¡å™¨åœ°å€
const FRPS_PORT = process.env.FRPS_PORT || '7000';         // FRP æœåŠ¡å™¨ç«¯å£
const FRPS_TOKEN = process.env.FRPS_TOKEN ||  'afrp.net';  // FRP å¯†é’¥

// å¡«å…¥ä»¥ä¸‹å˜é‡å³ä»£è¡¨å¼€å¯å¯¹åº”çš„ FRP ç©¿é€åŠŸèƒ½
const FRP_XRAY_DOMAIN = process.env.FRP_XRAY_DOMAIN || ''; // ç©¿é€ Xray (HTTPS)
const FRP_XRAY_DIRECT = process.env.FRP_XRAY_DIRECT || ''; // ç©¿é€ Xray (TCP ç›´è¿ž)
const FRP_DUFS_DOMAIN = process.env.FRP_DUFS_DOMAIN || ''; // ç©¿é€ Dufs (HTTP)
const FRP_HUB_DOMAIN  = process.env.FRP_HUB_DOMAIN || '';  // ç©¿é€ HubProxy (HTTP)

// åˆ¤æ–­æ˜¯å¦éœ€è¦ä¸‹è½½å¹¶è¿è¡Œ FRP
const NEED_FRP = FRPS_HOST && FRPS_TOKEN && (FRP_XRAY_DOMAIN || FRP_XRAY_DIRECT || FRP_DUFS_DOMAIN || FRP_HUB_DOMAIN);

// ==============================================================================
//   3. åˆå§‹åŒ–é€»è¾‘ (è¯»å–æŒä¹…åŒ–é…ç½®)
// ==============================================================================
// åˆ›å»ºå…±äº«ç›®å½•
if (!fs.existsSync(SHARE_PATH)) { try { fs.mkdirSync(SHARE_PATH); } catch(e) {} }

// è¯»å–æˆ–ç”Ÿæˆ UUID (VLESS ç”¨æˆ· ID)
let uuid = process.env.UUID || '';
if (!uuid && fs.existsSync(UUID_FILE)) { try { uuid = fs.readFileSync(UUID_FILE, 'utf-8').trim(); } catch(e) {} }
if (!uuid) {
    uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => (c === 'x' ? Math.random() * 16 | 0 : (Math.random() * 16 | 0) & 0x3 | 0x8).toString(16));
}
try { fs.writeFileSync(UUID_FILE, uuid); } catch(e) {}

// è¯»å–æˆ–ç”Ÿæˆ Dufs å¯†ç 
if (ENABLE_DUFS_AUTH) {
    if (!DUFS_PASSWORD && fs.existsSync(PASSWORD_FILE)) { try { DUFS_PASSWORD = fs.readFileSync(PASSWORD_FILE, 'utf-8').trim(); } catch(e) {} }
    if (!DUFS_PASSWORD) DUFS_PASSWORD = Math.random().toString(36).slice(2) + Math.random().toString(36).slice(2);
    try { fs.writeFileSync(PASSWORD_FILE, DUFS_PASSWORD); } catch(e) {}
}

// è¯»å–æˆ–ç”Ÿæˆ WS/XHTTP è·¯å¾„ (Path)
let WS_PATH = process.env.WS_PATH || '';
let XHTTP_PATH = process.env.XHTTP_PATH || '';
if ((!WS_PATH || !XHTTP_PATH) && fs.existsSync(PATHS_FILE)) {
    try {
        const storedPaths = JSON.parse(fs.readFileSync(PATHS_FILE, 'utf-8'));
        if (!WS_PATH) WS_PATH = storedPaths.ws || '';
        if (!XHTTP_PATH) XHTTP_PATH = storedPaths.xhttp || '';
    } catch(e) {}
}
if (!WS_PATH) WS_PATH = '/' + Math.random().toString(36).substring(2, 8);
if (!XHTTP_PATH) XHTTP_PATH = '/' + Math.random().toString(36).substring(2, 8);
try { fs.writeFileSync(PATHS_FILE, JSON.stringify({ ws: WS_PATH, xhttp: XHTTP_PATH })); } catch(e) {}

// è¯»å–æˆ–ç”Ÿæˆ ML-KEM å¯†é’¥å¯¹ (ç”¨äºŽæŠ—é‡å­åŠ å¯†)
let DECRYPTION = ''; let ENCRYPTION = '';
if (ENABLE_PQ) {
    DECRYPTION = process.env.VLESS_DECRYPTION || ''; ENCRYPTION = process.env.VLESS_ENCRYPTION || '';
    if ((!DECRYPTION || !ENCRYPTION) && fs.existsSync(KEYS_FILE)) {
       try { const k = JSON.parse(fs.readFileSync(KEYS_FILE, 'utf-8')); DECRYPTION = k.decryption||''; ENCRYPTION = k.encryption||''; } catch (e) {}
    }
}

// ==============================================================================
//   4. è¾…åŠ©å·¥å…·å‡½æ•°
// ==============================================================================
// é€šç”¨ä¸‹è½½å‡½æ•° (å¤„ç†é‡å®šå‘)
const download = (url, dest) => new Promise((resolve, reject) => {
  (url.startsWith('https') ? https : http).get(url, res => {
    if (res.statusCode === 301 || res.statusCode === 302) return download(res.headers.location, dest).then(resolve).catch(reject);
    if (res.statusCode !== 200) return reject('Status ' + res.statusCode);
    const file = fs.createWriteStream(dest);
    res.pipe(file);
    file.on('finish', () => file.close(resolve));
  }).on('error', reject).setTimeout(30000, () => reject('Timeout'));
});

// èŽ·å– FRP æœ€æ–°ç‰ˆæœ¬ä¸‹è½½é“¾æŽ¥
const getFrpUrl = () => new Promise((resolve) => {
    const fallback = 'https://github.com/fatedier/frp/releases/download/v0.61.0/frp_0.61.0_linux_amd64.tar.gz';
    https.get('https://github.com/fatedier/frp/releases/latest', (res) => {
        try { if (res.statusCode === 302) {
                const parts = res.headers.location.split('/'); let tag = parts[parts.length - 1]; if (!tag.startsWith('v')) tag = 'v' + tag;
                resolve(`https://github.com/fatedier/frp/releases/download/${tag}/frp_${tag.replace(/^v/, '')}_linux_amd64.tar.gz`);
            } else resolve(fallback);
        } catch(e) { resolve(fallback); }
    }).on('error', () => resolve(fallback));
});

// èŽ·å– Dufs æœ€æ–°ç‰ˆæœ¬
const getDufsLatestUrl = () => new Promise((resolve) => {
    const fallback = 'https://github.com/sigoden/dufs/releases/download/v0.43.0/dufs-v0.43.0-x86_64-unknown-linux-musl.tar.gz';
    https.get('https://github.com/sigoden/dufs/releases/latest', (res) => {
        try { const tag = res.headers.location ? path.basename(res.headers.location) : 'v0.43.0'; resolve(`https://github.com/sigoden/dufs/releases/download/${tag}/dufs-v${tag.replace('v', '')}-x86_64-unknown-linux-musl.tar.gz`);
        } catch(e) { resolve(fallback); }
    }).on('error', () => resolve(fallback));
});

// èŽ·å– HubProxy æœ€æ–°ç‰ˆæœ¬
const getHubProxyUrl = () => new Promise((resolve) => {
    const fallback = 'https://github.com/sky22333/hubproxy/releases/download/v1.1.9/hubproxy-v1.1.9-linux-amd64.tar.gz';
    https.get('https://github.com/sky22333/hubproxy/releases/latest', (res) => {
        try { const tag = res.headers.location ? path.basename(res.headers.location) : 'v1.1.9'; resolve(`https://github.com/sky22333/hubproxy/releases/download/${tag}/hubproxy-${tag}-linux-amd64.tar.gz`);
        } catch(e) { resolve(fallback); }
    }).on('error', () => resolve(fallback));
});

// é€’å½’æŸ¥æ‰¾äºŒè¿›åˆ¶æ–‡ä»¶
const findBin = (dir, name) => {
    try { const files = fs.readdirSync(dir, { withFileTypes: true }); for (const f of files) { const fullPath = path.join(dir, f.name);
            if (f.isDirectory()) { const res = findBin(fullPath, name); if (res) return res; } 
            else if ((f.name === name || f.name.startsWith(name + '-')) && !f.name.endsWith('.gz')) return fullPath;
    }} catch (e) {} return null;
};

// ä¿å­˜é“¾æŽ¥åˆ°æ–‡ä»¶å¹¶æ‰“å°
// type='hidden': åªå†™æ–‡ä»¶ï¼Œä¸æ‰“å° (ç”¨äºŽæ•æ„Ÿçš„ Xray é“¾æŽ¥)
// type='public': å†™æ–‡ä»¶ + å­˜å†…å­˜ + æ‰“å° (ç”¨äºŽå…¬å¼€çš„ Dufs/Hub é“¾æŽ¥)
const saveLink = (content, title = '', type = 'hidden') => {
    // æ ¼å¼åŒ–è¾“å‡ºï¼šåŽ»é™¤æ ‡é¢˜æ–¹æ‹¬å·
    const fileOutput = title ? `${title}\n${content}` : content;
    try { fs.appendFileSync(LINKS_PATH, fileOutput + '\n\n', 'utf-8'); } catch(e) {}
    if (type === 'public') {
        const consoleOutput = `ðŸ”— ${title}:\n${content}`;
        PUBLIC_LINKS.push(consoleOutput);
        console.log(consoleOutput);
    }
};

// ç”Ÿæˆ VLESS é“¾æŽ¥ (æ”¯æŒ Argo æ ¼å¼å’Œæ ‡å‡†æ ¼å¼)
const genVlessLink = (host, port, remarks, type) => {
    const currentPath = XRAY_PROTOCOL === 'xhttp' ? XHTTP_PATH : WS_PATH;
    const currentType = XRAY_PROTOCOL === 'xhttp' ? 'xhttp' : 'ws';
    const encParam = (ENABLE_PQ && ENCRYPTION) ? `encryption=${ENCRYPTION}&` : '';
    // Argo é“¾æŽ¥ä½¿ç”¨ç«¯å£ 443 + TLS
    if (type === 'argo') return `vless://${uuid}@${CDN_HOST}:443?${encParam}security=tls&flow=${FLOW}&sni=${host}&fp=firefox&alpn=h2&type=${currentType}&path=${encodeURIComponent(currentPath)}#${remarks}`;
    // ç›´è¿ž/FRP é“¾æŽ¥ä½¿ç”¨æŒ‡å®šç«¯å£
    return `vless://${uuid}@${host}:${port}?${encParam}security=tls&sni=${CDN_HOST}&flow=${FLOW}&fp=firefox&alpn=h2&type=${currentType}&path=${encodeURIComponent(currentPath)}&insecure=1#${remarks}`;
};

// ==============================================================================
//   5. ä¸»ç¨‹åºæµç¨‹
// ==============================================================================
(async () => {
  // 1. æ¸…ç†å¹¶é‡å»ºä¸´æ—¶ç›®å½•
  if (fs.existsSync(TMP)) fs.rmSync(TMP, { recursive: true, force: true });
  fs.mkdirSync(TMP, { recursive: true });
  fs.writeFileSync(LINKS_PATH, `--- LINKS [${new Date().toISOString()}] ---\n\n`);

  try {
    // 2. å¹¶è¡Œä¸‹è½½æ‰€æœ‰å¼€å¯çš„ç»„ä»¶
    const dl = [];
    if (ENABLE_XRAY) dl.push(download(XRAY_URL, ZIP));
    if (ENABLE_DUFS) dl.push(download(await getDufsLatestUrl(), DUFS_TAR));
    if (ENABLE_HUB) dl.push(download(await getHubProxyUrl(), HUB_TAR));
    // ä½¿ç”¨ ENABLE_CLOUDFLARED æŽ§åˆ¶æ˜¯å¦ä¸‹è½½ Argo æ ¸å¿ƒ
    if (ENABLE_CLOUDFLARED) dl.push(download('https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64', ARGO_BIN));
    if (NEED_FRP) dl.push(download(await getFrpUrl(), FRPC_TAR));
    await Promise.all(dl);

    // --------------------------------------------------------
    // æ¨¡å— 1: Xray æ ¸å¿ƒé€»è¾‘
    // --------------------------------------------------------
    if (ENABLE_XRAY) {
        execSync(`unzip -o ${ZIP} -d ${TMP}`); // è§£åŽ‹
        const x = findBin(TMP, 'xray'); if (x) fs.renameSync(x, BIN); fs.chmodSync(BIN, 0o755);
        
        // ç”Ÿæˆè‡ªç­¾è¯ä¹¦ (ç”¨äºŽ VLESS TLS)
        try { 
            const c = JSON.parse(execSync(`${BIN} tls cert`, {encoding:'utf-8'})); 
            fs.writeFileSync(CERT_FILE, c.certificate.join('\n')); 
            fs.writeFileSync(KEY_FILE, c.key.join('\n')); 
        } catch(e) { fs.writeFileSync(CERT_FILE,''); fs.writeFileSync(KEY_FILE,''); }

        // ç”Ÿæˆæˆ–è¯»å– ML-KEM å¯†é’¥
        if (ENABLE_PQ && (!DECRYPTION || !ENCRYPTION)) {
            try {
                const cmdOut = execSync(`${BIN} vlessenc`, { encoding: 'utf-8' });
                const match = cmdOut.match(/Authentication: ML-KEM-768[\s\S]+?"decryption":\s*"([^"]+)"[\s\S]+?"encryption":\s*"([^"]+)"/);
                if (match) {
                    DECRYPTION = match[1]; ENCRYPTION = match[2];
                    try { fs.writeFileSync(KEYS_FILE, JSON.stringify({ decryption: DECRYPTION, encryption: ENCRYPTION })); } catch(err) {}
                }
            } catch (keyErr) {}
        }

        // é…ç½®æµè®¾ç½® (WS æˆ– XHTTP)
        const stream = XRAY_PROTOCOL === 'xhttp' ? 
            {network:"xhttp",security:"tls",tlsSettings:{certificates:[{certificateFile:CERT_FILE,keyFile:KEY_FILE}]},xhttpSettings:{path:XHTTP_PATH}} : 
            {network:"ws",security:"tls",tlsSettings:{certificates:[{certificateFile:CERT_FILE,keyFile:KEY_FILE}]},wsSettings:{path:WS_PATH}};
        
        // å†™å…¥ config.json
        fs.writeFileSync(CFG, JSON.stringify({
            log:{access:'none',error:'none',loglevel:'none'},
            inbounds:[{
                port:PORT, listen:'0.0.0.0', protocol:'vless',
                settings:{ clients:[{id:uuid,flow:FLOW}], decryption:(ENABLE_PQ && DECRYPTION) ? DECRYPTION : "none" },
                streamSettings:stream
            }],
            dns: {servers:["https+local://1.1.1.1/dns-query"], disableCache: true},
            outbounds:[{protocol:'freedom',tag:'direct'},{protocol:'blackhole',tag:'block'}]
        }));
        
        // å¯åŠ¨ Xray
        spawn(BIN, ['-c', CFG], {stdio:'ignore',detached:true}).unref();
        if (SERVER_IP) saveLink(genVlessLink(SERVER_IP, PORT, `${LINK_NAME}-Direct`, 'direct'), 'Direct IP', 'hidden');
    }

    // --------------------------------------------------------
    // æ¨¡å— 2: Dufs æ–‡ä»¶æœåŠ¡
    // --------------------------------------------------------
    if (ENABLE_DUFS) {
        execSync(`tar -xzf ${DUFS_TAR} -C ${TMP}`); const d = findBin(TMP, 'dufs'); if (d) fs.renameSync(d, DUFS_BIN); fs.chmodSync(DUFS_BIN, 0o755);
        const args = [SHARE_PATH, '-p', String(WEB_PORT), '--bind', '0.0.0.0', '-A'];
        // å¦‚æžœå¼€å¯é‰´æƒï¼Œæ·»åŠ ç”¨æˆ·åå¯†ç å‚æ•°
        if (ENABLE_DUFS_AUTH) { 
            args.push('-a', `${DUFS_USER}:${DUFS_PASSWORD}@/:rw`); 
            saveLink(`User: ${DUFS_USER} / Pass: ${DUFS_PASSWORD}`, 'Dufs Auth', 'hidden'); 
        }
        spawn(DUFS_BIN, args, {stdio:'ignore',detached:true}).unref();
    }

    // --------------------------------------------------------
    // æ¨¡å— 3: HubProxy é•œåƒæœåŠ¡
    // --------------------------------------------------------
    if (ENABLE_HUB) {
        execSync(`tar -xzf ${HUB_TAR} -C ${TMP}`); const h = findBin(TMP, 'hubproxy'); if (h) fs.renameSync(h, HUB_BIN); fs.chmodSync(HUB_BIN, 0o755);
        spawn(HUB_BIN, ['--addr', `:${HUB_PORT}`], {
            stdio: 'ignore', detached: true, 
            env: { ...process.env, PORT: String(HUB_PORT), SERVER_PORT: String(HUB_PORT) }
        }).unref();
    }

    // --------------------------------------------------------
    // æ¨¡å— 4: FRP å†…ç½‘ç©¿é€
    // --------------------------------------------------------
    if (NEED_FRP && fs.existsSync(FRPC_TAR)) {
        execSync(`tar -xzf ${FRPC_TAR} -C ${TMP}`); const f = findBin(TMP, 'frpc');
        if (f) { fs.renameSync(f, FRPC_BIN); fs.chmodSync(FRPC_BIN, 0o755);
            const uid = uuid.substring(0, 6); let ini = `[common]\nserver_addr=${FRPS_HOST}\nserver_port=${FRPS_PORT}\ntoken=${FRPS_TOKEN}\n`;
            // æ ¹æ®çŽ¯å¢ƒå˜é‡åŠ¨æ€ç”Ÿæˆ frpc.ini
            if (ENABLE_XRAY && FRP_XRAY_DOMAIN) { ini+=`\n[xray-https-${uid}]\ntype=https\ncustom_domains=${FRP_XRAY_DOMAIN}\nlocal_port=${PORT}\n`; saveLink(genVlessLink(FRP_XRAY_DOMAIN,443,`${LINK_NAME}-FRP-HTTPS`,'https-domain'),'FRP-Xray','hidden'); }
            if (ENABLE_XRAY && FRP_XRAY_DIRECT) { ini+=`\n[xray-tcp-${uid}]\ntype=tcp\nlocal_ip=127.0.0.1\nlocal_port=${PORT}\nremote_port=${FRP_XRAY_DIRECT}\n`; saveLink(genVlessLink(FRPS_HOST,FRP_XRAY_DIRECT,`${LINK_NAME}-FRP-TCP`,'direct'),'FRP-TCP','hidden'); }
            if (ENABLE_DUFS && FRP_DUFS_DOMAIN) { ini+=`\n[dufs-${uid}]\ntype=http\ncustom_domains=${FRP_DUFS_DOMAIN}\nlocal_port=${WEB_PORT}\n`; saveLink(`http://${FRP_DUFS_DOMAIN}`,'FRP-Dufs','hidden'); }
            if (ENABLE_HUB && FRP_HUB_DOMAIN) { ini+=`\n[hub-${uid}]\ntype=http\ncustom_domains=${FRP_HUB_DOMAIN}\nlocal_port=${HUB_PORT}\n`; saveLink(`http://${FRP_HUB_DOMAIN}`,'FRP-Hub','hidden'); }
            fs.writeFileSync(FRPC_CFG, ini); spawn(FRPC_BIN, ['-c', FRPC_CFG], {stdio:'ignore',detached:true}).unref();
        }
    }

    // --------------------------------------------------------
    // æ¨¡å— 5: Argo Tunnel (Cloudflare)
    // --------------------------------------------------------
    // ä½¿ç”¨ ENABLE_CLOUDFLARED æ£€æŸ¥æ˜¯å¦å·²ä¸‹è½½
     if (ARGO_DOMAIN) {
             saveLink(genVlessLink(ARGO_DOMAIN, 443, `${LINK_NAME}-Domain`, 'argo'), 'Argo-Domain-Static', 'hidden');
             }
    if (ENABLE_CLOUDFLARED && fs.existsSync(ARGO_BIN)) {
        fs.chmodSync(ARGO_BIN, 0o755);
        
        // (A) Xray éš§é“ï¼šä½¿ç”¨ ENABLE_ARGO_XRAY æŽ§åˆ¶
        if (ENABLE_XRAY && ENABLE_ARGO_XRAY) {
             if (ARGO_TOKEN && ARGO_DOMAIN) {
                 // åœºæ™¯ A1: å›ºå®š Token (æŽ¨è)
                 spawn(ARGO_BIN, ['tunnel','run','--token',ARGO_TOKEN], {stdio:'ignore',detached:true}).unref();
                 saveLink(genVlessLink(ARGO_DOMAIN,443,`${LINK_NAME}-Argo`,'argo'),'Argo-Xray','hidden');
             } else {
                 const t = spawn(ARGO_BIN, ['tunnel','--url',`https://localhost:${PORT}`,'--no-tls-verify','--no-autoupdate'], {stdio:['ignore','ignore','pipe']});
                 t.stderr.on('data', d => { 
                     const m = d.toString().match(/(https:\/\/[a-zA-Z0-9-]+\.trycloudflare\.com)/); 
                     if (m) saveLink(genVlessLink(m[1].replace('https://',''),443,`${LINK_NAME}-Argo-Quick`,'argo'),'Argo-Xray-Quick','hidden'); 
                 });
             }
        }
        
        // (B) Dufs éš§é“
        if (ENABLE_DUFS && ENABLE_DUFS_ARGO) {
            const args = (DUFS_ARGO_TOKEN && DUFS_ARGO_DOMAIN) ? ['tunnel','run','--token',DUFS_ARGO_TOKEN] : ['tunnel','--url',`http://localhost:${WEB_PORT}`,'--no-autoupdate'];
            const t = spawn(ARGO_BIN, args, {stdio:['ignore','ignore','pipe']});
            if (DUFS_ARGO_TOKEN && DUFS_ARGO_DOMAIN) saveLink(`https://${DUFS_ARGO_DOMAIN}`, 'Dufs Argo', 'public');
            else t.stderr.on('data', d => { const m = d.toString().match(/(https:\/\/[a-zA-Z0-9-]+\.trycloudflare\.com)/); if (m) saveLink(m[1], 'Dufs Argo', 'public'); });
        }
        
        // (C) HubProxy éš§é“
        if (ENABLE_HUB && ENABLE_HUB_ARGO) {
            const args = (HUB_ARGO_TOKEN && HUB_ARGO_DOMAIN) ? ['tunnel','run','--token',HUB_ARGO_TOKEN] : ['tunnel','--url',`http://localhost:${HUB_PORT}`,'--no-autoupdate'];
            const t = spawn(ARGO_BIN, args, {stdio:['ignore','ignore','pipe']});
            if (HUB_ARGO_TOKEN && HUB_ARGO_DOMAIN) saveLink(`https://${HUB_ARGO_DOMAIN}`, 'Hub Argo', 'public');
            else t.stderr.on('data', d => { const m = d.toString().match(/(https:\/\/[a-zA-Z0-9-]+\.trycloudflare\.com)/); if (m) saveLink(m[1], 'Hub Argo', 'public'); });
        }
    }
    console.log('âœ… Initialized.');
  } catch (e) { process.exit(1); }

  // 30ç§’åŽåˆ é™¤ tmp ä¸´æ—¶æ–‡ä»¶å¤¹ (å®‰å…¨æŽªæ–½ï¼šé˜²æ­¢æ•æ„Ÿé…ç½®æ³„éœ²)
  setTimeout(() => { if (fs.existsSync(TMP)) fs.rmSync(TMP, { recursive: true, force: true }); }, 30000);

  // 6å°æ—¶æŠ¥å‘Šä¸€æ¬¡ (ä»…æ˜¾ç¤ºå…¬å¼€é“¾æŽ¥)
  setInterval(() => {
      process.stdout.write('\033c'); // æ¸…å±
      console.log(`\nðŸ•’ Report [${new Date().toISOString()}]`);
      if (PUBLIC_LINKS.length > 0) PUBLIC_LINKS.forEach(l => console.log(l));
  }, 21600000);
  
  // 5åˆ†é’Ÿä¿æ´» (é˜²æ­¢è¿›ç¨‹å› æ— è¾“å‡ºè¢«å¹³å°æ€æ­»)
  setInterval(() => console.log('ðŸ’— Keep alive', new Date().toISOString()), 300000);
})();
