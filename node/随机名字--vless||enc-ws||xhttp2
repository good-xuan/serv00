const http = require('http'), https = require('https'), fs = require('fs'), path = require('path'), { spawn, execSync } = require('child_process'), os = require('os'), crypto = require('crypto');

// ==============================================================================
//  0. æ ¸å¿ƒé…ç½®èšåˆ (Configuration & Environment)
// ==============================================================================
const CONFIG = {
    PORT: parseInt(process.env.SERVER_PORT || process.env.PORT || 3000),
    UUID: process.env.UUID || '',
    LINK_NAME: process.env.LINK_NAME || 'Node',
    CDN_HOST: process.env.CDN_HOST || 'www.visa.com.sg',
    SERVER_IP: process.env.SERVER_IP || '127.0.0.1',
    
    // Xray
    XRAY_URL: 'https://github.com/XTLS/Xray-core/releases/latest/download/Xray-linux-64.zip',
    PROTOCOL: process.env.XRAY_PROTOCOL || 'ws',
    ENABLE_XRAY: process.env.ENABLE_XRAY !== 'false',
    ENABLE_PQ: process.env.ENABLE_PQ !== 'false',
    
    // Argo
    ENABLE_CLOUDFLARED: process.env.ENABLE_CLOUDFLARED !== 'false',
    ENABLE_ARGO_XRAY: process.env.ENABLE_ARGO_XRAY !== 'false',
    ARGO_TOKEN: process.env.ARGO_TOKEN || '',
    ARGO_DOMAIN: process.env.ARGO_DOMAIN || '',
    ARGO_URL: 'https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64',
    
    FILES: {
        UUID: path.join(__dirname, '.uuid'),
        KEYS: path.join(__dirname, '.keys'),
        PATHS: path.join(__dirname, '.paths')
    }
};

CONFIG.FLOW = CONFIG.ENABLE_PQ ? 'xtls-rprx-vision' : '';

// ==============================================================================
//  1. åŠ¨æ€å†…å­˜ä¸ŽçŽ¯å¢ƒè®¡ç®—
// ==============================================================================
const getMemLimit = () => {
    try {
        const cgroupLimit = ['/sys/fs/cgroup/memory.max', '/sys/fs/cgroup/memory/memory.limit_in_bytes'].find(p => fs.existsSync(p));
        const limit = cgroupLimit ? parseInt(fs.readFileSync(cgroupLimit, 'utf8')) : 0;
        return (limit > 0 && limit < 9e15) ? limit : os.totalmem();
    } catch (e) { return os.totalmem(); }
};

const mem = getMemLimit();
const limitBytes = Math.floor(mem * 0.85);
const GOMEMLIMIT = limitBytes + 'B';
const RUN_ENV = { ...process.env, GOMEMLIMIT };

console.log(`\nðŸ§  Memory: ${(mem / 1024 / 1024).toFixed(0)}MB -> Limit: ${(limitBytes / 1024 / 1024).toFixed(0)}MB (${GOMEMLIMIT})`);

// ==============================================================================
//  2. éšæœºåŒ–ä¸Žæ–‡ä»¶è·¯å¾„å‡†å¤‡
// ==============================================================================
const randomStr = () => crypto.randomBytes(4).toString('hex');
const TMP = path.join(__dirname, 'tmp');

const FILES = {
    BIN: path.join(TMP, `${randomStr()}`),
    ARGO: path.join(TMP, `${randomStr()}`),
    ZIP: path.join(TMP, `${randomStr()}.zip`),
    CFG: path.join(TMP, 'config.json'),
    CERT: path.join(TMP, 'cert.pem'),
    KEY: path.join(TMP, 'key.pem'),
    LINKS: path.join(TMP, `LINK-${randomStr()}.txt`)
};

// ==============================================================================
//  3. è¾…åŠ©å‡½æ•°ä¼˜åŒ–
// ==============================================================================
const generateUUID = () => {
    if (crypto.randomUUID) return crypto.randomUUID();
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => 
        (c === 'x' ? Math.random() * 16 | 0 : (Math.random() * 16 | 0) & 0x3 | 0x8).toString(16));
};

const download = (url, dest) => new Promise((resolve, reject) => {
    const options = { headers: { 'User-Agent': 'Mozilla/5.0 (Compatible; Node.js)' } };
    const get = url.startsWith('https') ? https.get : http.get;
    get(url, options, res => {
        if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) return download(res.headers.location, dest).then(resolve).catch(reject);
        if (res.statusCode !== 200) return reject(`Status ${res.statusCode}`);
        const file = fs.createWriteStream(dest);
        res.pipe(file);
        file.on('finish', () => file.close(resolve));
        file.on('error', (err) => { fs.unlink(dest, () => {}); reject(err); });
    }).on('error', reject).setTimeout(30000, () => reject('Timeout'));
});

const findBin = (dir, name) => {
    try {
        const files = fs.readdirSync(dir, { withFileTypes: true });
        for (const f of files) {
            const fullPath = path.join(dir, f.name);
            if (f.isDirectory()) { const res = findBin(fullPath, name); if (res) return res; } 
            else if ((f.name === name || f.name.startsWith(name + '-')) && !f.name.endsWith('.gz')) return fullPath;
        }
    } catch (e) {} return null;
};

// âœ… ä¼˜åŒ–ï¼šçº¯å†™å…¥æ“ä½œï¼Œå½»åº•ç§»é™¤æ•°ç»„å’Œæ‰“å°
const saveLink = (content, title = '') => {
    if (title) fs.appendFileSync(FILES.LINKS, `\n${title}\n${content}\n`, 'utf-8');
};

const genVlessLink = (host, port, remarks, type, paths) => {
    const isXhttp = CONFIG.PROTOCOL === 'xhttp';
    const pathVal = isXhttp ? paths.xhttp : paths.ws;
    const netType = isXhttp ? 'xhttp' : 'ws';
    
    const link = new URL(`vless://${uuid}@${type === 'argo' ? CONFIG.CDN_HOST : host}:${type === 'argo' ? 443 : port}`);
    const params = link.searchParams;
    
    params.set('security', 'tls');
    if (CONFIG.ENABLE_PQ && keys.encryption) params.set('encryption', keys.encryption);
    if (CONFIG.FLOW) params.set('flow', CONFIG.FLOW);
    
    if (type === 'argo') params.set('sni', host);
    else { params.set('sni', CONFIG.CDN_HOST); params.set('insecure', '1'); }
    
    params.set('fp', 'firefox'); params.set('alpn', 'h2'); params.set('type', netType); params.set('path', pathVal);
    link.hash = remarks;
    return link.toString();
};

// ==============================================================================
//  4. æ•°æ®åˆå§‹åŒ–
// ==============================================================================
let uuid = CONFIG.UUID;
if (!uuid && fs.existsSync(CONFIG.FILES.UUID)) try { uuid = fs.readFileSync(CONFIG.FILES.UUID, 'utf-8').trim(); } catch(e) {}
if (!uuid) uuid = generateUUID();
try { fs.writeFileSync(CONFIG.FILES.UUID, uuid); } catch(e) {}

let storedPaths = { ws: '', xhttp: '' };
if (fs.existsSync(CONFIG.FILES.PATHS)) try { storedPaths = JSON.parse(fs.readFileSync(CONFIG.FILES.PATHS, 'utf-8')); } catch(e) {}
const PATH_CONFIG = {
    ws: process.env.WS_PATH || storedPaths.ws || '/' + crypto.randomBytes(3).toString('hex'),
    xhttp: process.env.XHTTP_PATH || storedPaths.xhttp || '/' + crypto.randomBytes(3).toString('hex')
};
try { fs.writeFileSync(CONFIG.FILES.PATHS, JSON.stringify(PATH_CONFIG)); } catch(e) {}

let keys = { decryption: process.env.VLESS_DECRYPTION || '', encryption: process.env.VLESS_ENCRYPTION || '' };
if (CONFIG.ENABLE_PQ && (!keys.decryption || !keys.encryption) && fs.existsSync(CONFIG.FILES.KEYS)) {
    try { keys = JSON.parse(fs.readFileSync(CONFIG.FILES.KEYS, 'utf-8')); } catch(e) {}
}

process.on('SIGINT', () => process.exit(0));
process.on('SIGTERM', () => process.exit(0));

// ==============================================================================
//  5. ä¸»ç¨‹åºæµç¨‹
// ==============================================================================
(async () => {
    if (fs.existsSync(TMP)) fs.rmSync(TMP, { recursive: true, force: true });
    fs.mkdirSync(TMP, { recursive: true });
    fs.writeFileSync(FILES.LINKS, `--- LINKS [${new Date().toISOString()}] ---\n`);

    try {
        const dl = [];
        if (CONFIG.ENABLE_XRAY) dl.push(download(CONFIG.XRAY_URL, FILES.ZIP));
        if (CONFIG.ENABLE_CLOUDFLARED) dl.push(download(CONFIG.ARGO_URL, FILES.ARGO));
        await Promise.all(dl);

        // --- Xray ---
        if (CONFIG.ENABLE_XRAY) {
            execSync(`unzip -o ${FILES.ZIP} -d ${TMP}`);
            const x = findBin(TMP, 'xray'); if (x) fs.renameSync(x, FILES.BIN); fs.chmodSync(FILES.BIN, 0o755);

            try { const c = JSON.parse(execSync(`${FILES.BIN} tls cert`, { encoding: 'utf-8' })); fs.writeFileSync(FILES.CERT, c.certificate.join('\n')); fs.writeFileSync(FILES.KEY, c.key.join('\n')); } catch (e) { fs.writeFileSync(FILES.CERT, ''); fs.writeFileSync(FILES.KEY, ''); }

            if (CONFIG.ENABLE_PQ && (!keys.decryption || !keys.encryption)) {
                try {
                    const cmdOut = execSync(`${FILES.BIN} vlessenc`, { encoding: 'utf-8' });
                    const match = cmdOut.match(/Authentication: ML-KEM-768[\s\S]+?"decryption":\s*"([^"]+)"[\s\S]+?"encryption":\s*"([^"]+)"/);
                    if (match) { keys = { decryption: match[1], encryption: match[2] }; try { fs.writeFileSync(CONFIG.FILES.KEYS, JSON.stringify(keys)); } catch (err) {} }
                } catch (e) {}
            }

            const stream = CONFIG.PROTOCOL === 'xhttp' ? 
                { network: "xhttp", security: "tls", tlsSettings: { certificates: [{ certificateFile: FILES.CERT, keyFile: FILES.KEY }] }, xhttpSettings: { path: PATH_CONFIG.xhttp } } : 
                { network: "ws", security: "tls", tlsSettings: { certificates: [{ certificateFile: FILES.CERT, keyFile: FILES.KEY }] }, wsSettings: { path: PATH_CONFIG.ws } };

            fs.writeFileSync(FILES.CFG, JSON.stringify({
                log: { access: 'none', error: 'none', loglevel: 'none' },
                inbounds: [{ port: CONFIG.PORT, listen: '0.0.0.0', protocol: 'vless', settings: { clients: [{ id: uuid, flow: CONFIG.FLOW }], decryption: (CONFIG.ENABLE_PQ && keys.decryption) ? keys.decryption : "none" }, streamSettings: stream }],
                dns: { servers: ["https+local://1.1.1.1/dns-query"] },
                outbounds: [{ protocol: 'freedom', tag: 'direct', settings: { domainStrategy: "UseIP" } }, { protocol: 'blackhole', tag: 'block' }]
            }));
            spawn(FILES.BIN, ['-c', FILES.CFG], { stdio: 'ignore', detached: true, env: RUN_ENV }).unref();
            if (CONFIG.SERVER_IP) saveLink(genVlessLink(CONFIG.SERVER_IP, CONFIG.PORT, `${CONFIG.LINK_NAME}-Direct`, 'direct', PATH_CONFIG), 'Direct IP');
        }

        // --- Argo ---
        if (CONFIG.ARGO_DOMAIN) saveLink(genVlessLink(CONFIG.ARGO_DOMAIN, 443, `${CONFIG.LINK_NAME}-Domain`, 'argo', PATH_CONFIG), 'Argo-Domain');
        
        if (CONFIG.ENABLE_CLOUDFLARED && fs.existsSync(FILES.ARGO)) {
            fs.chmodSync(FILES.ARGO, 0o755);
            if (CONFIG.ENABLE_XRAY && CONFIG.ENABLE_ARGO_XRAY) {
                if (CONFIG.ARGO_TOKEN && CONFIG.ARGO_DOMAIN) {
                    spawn(FILES.ARGO, ['tunnel', 'run', '--token', CONFIG.ARGO_TOKEN], { stdio: 'ignore', detached: true, env: RUN_ENV }).unref();
                } else {
                    const t = spawn(FILES.ARGO, ['tunnel', '--url', `https://localhost:${CONFIG.PORT}`, '--no-tls-verify', '--no-autoupdate'], { stdio: ['ignore', 'ignore', 'pipe'], env: RUN_ENV });
                    t.stderr.on('data', d => {
                        const m = d.toString().match(/(https:\/\/[a-zA-Z0-9-]+\.trycloudflare\.com)/);
                        if (m) saveLink(genVlessLink(m[1].replace('https://', ''), 443, `${CONFIG.LINK_NAME}-Argo-Quick`, 'argo', PATH_CONFIG), 'Argo-Quick');
                    });
                }
            }
        }
        console.log('âœ… Initialized.');
    } catch (e) { console.error(e); process.exit(1); }

    setTimeout(() => { if (fs.existsSync(TMP)) fs.rmSync(TMP, { recursive: true, force: true }); }, 30000);

    // âœ… ä¼˜åŒ–ï¼šçº¯å‡€çš„æŠ¥å‘Šå‡½æ•°ï¼Œåªè¾“å‡ºæ—¶é—´è¯æ˜Žå­˜æ´»
    setInterval(() => console.log(`\nðŸ•’ Report [${new Date().toISOString()}]`), 21600000);
    setInterval(() => console.log('ðŸ’— Keep alive', new Date().toISOString()), 300000);
})();
