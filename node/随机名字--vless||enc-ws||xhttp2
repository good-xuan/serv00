const http = require('http'), https = require('https'), fs = require('fs'), path = require('path'), { spawn, execSync } = require('child_process'), os = require('os'), crypto = require('crypto');

// ==============================================================================
//  0. æ ¸å¿ƒé…ç½®èšåˆ (Configuration & Environment)
//  ä¼˜åŒ–ï¼šé›†ä¸­ç®¡ç†çŽ¯å¢ƒå˜é‡ï¼Œä»£ç æ›´æ•´æ´
// ==============================================================================
const CONFIG = {
    // åŸºç¡€é…ç½®
    PORT: parseInt(process.env.SERVER_PORT || process.env.PORT || 3000),
    UUID: process.env.UUID || '',
    
    // ä¼ªè£…ä¸Žè·¯å¾„
    LINK_NAME: process.env.LINK_NAME || 'Node',
    CDN_HOST: process.env.CDN_HOST || 'www.visa.com.sg',
    SERVER_IP: process.env.SERVER_IP || '127.0.0.1',
    
    // Xray é…ç½®
    XRAY_URL: 'https://github.com/XTLS/Xray-core/releases/latest/download/Xray-linux-64.zip',
    PROTOCOL: process.env.XRAY_PROTOCOL || 'ws',
    ENABLE_XRAY: process.env.ENABLE_XRAY !== 'false',
    ENABLE_PQ: process.env.ENABLE_PQ !== 'false', // æŠ—é‡å­
    
    // Cloudflare Argo é…ç½®
    ENABLE_CLOUDFLARED: process.env.ENABLE_CLOUDFLARED !== 'false',
    ENABLE_ARGO_XRAY: process.env.ENABLE_ARGO_XRAY !== 'false',
    ARGO_TOKEN: process.env.ARGO_TOKEN || '',
    ARGO_DOMAIN: process.env.ARGO_DOMAIN || '',
    ARGO_URL: 'https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64',
    
    // è·¯å¾„ä¸Žå¯†é’¥æŒä¹…åŒ–
    FILES: {
        UUID: path.join(__dirname, '.uuid'),
        KEYS: path.join(__dirname, '.keys'),
        PATHS: path.join(__dirname, '.paths')
    }
};

CONFIG.FLOW = CONFIG.ENABLE_PQ ? 'xtls-rprx-vision' : '';

// ==============================================================================
//  1. åŠ¨æ€å†…å­˜ä¸ŽçŽ¯å¢ƒè®¡ç®—
// ==============================================================================
const getMemLimit = () => {
    try {
        const cgroupLimit = ['/sys/fs/cgroup/memory.max', '/sys/fs/cgroup/memory/memory.limit_in_bytes']
            .find(p => fs.existsSync(p));
        const limit = cgroupLimit ? parseInt(fs.readFileSync(cgroupLimit, 'utf8')) : 0;
        return (limit > 0 && limit < 9e15) ? limit : os.totalmem();
    } catch (e) { return os.totalmem(); }
};

const mem = getMemLimit();
const limitBytes = Math.floor(mem * 0.85);
const GOMEMLIMIT = limitBytes + 'B';
const RUN_ENV = { ...process.env, GOMEMLIMIT };

console.log(`\nðŸ§  Memory: ${(mem / 1024 / 1024).toFixed(0)}MB -> Limit: ${(limitBytes / 1024 / 1024).toFixed(0)}MB (${GOMEMLIMIT})`);

// ==============================================================================
//  2. éšæœºåŒ–ä¸Žæ–‡ä»¶è·¯å¾„å‡†å¤‡ (Obfuscation)
// ==============================================================================
const TMP = path.join(__dirname, 'tmp');
const randomStr = () => crypto.randomBytes(4).toString('hex'); // ä¼˜åŒ–ï¼šæ›´å¿«çš„éšæœºä¸²

const FILES = {
    BIN: path.join(TMP, `x-${randomStr()}`),
    ARGO: path.join(TMP, `a-${randomStr()}`),
    ZIP: path.join(TMP, `${randomStr()}.zip`),
    CFG: path.join(TMP, 'config.json'),
    CERT: path.join(TMP, 'cert.pem'),
    KEY: path.join(TMP, 'key.pem'),
    LINKS: path.join(TMP, `LINK-${randomStr()}.txt`)
};

const PUBLIC_LINKS = [];

// ==============================================================================
//  3. è¾…åŠ©å‡½æ•°ä¼˜åŒ–
// ==============================================================================

// ä¼˜åŒ–ï¼šä¼˜å…ˆä½¿ç”¨åŽŸç”Ÿ crypto ç”Ÿæˆ UUIDï¼Œå›žé€€å…¼å®¹æ—§ç‰ˆ
const generateUUID = () => {
    if (crypto.randomUUID) return crypto.randomUUID();
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => 
        (c === 'x' ? Math.random() * 16 | 0 : (Math.random() * 16 | 0) & 0x3 | 0x8).toString(16));
};

// ä¼˜åŒ–ï¼šæ·»åŠ  User-Agent å¤´ï¼Œé˜²æ­¢è¢« GitHub/Cloudflare æ‹¦æˆª
const download = (url, dest) => new Promise((resolve, reject) => {
    const options = { headers: { 'User-Agent': 'Mozilla/5.0 (Compatible; Node.js)' } };
    const get = url.startsWith('https') ? https.get : http.get;
    
    get(url, options, res => {
        if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
            return download(res.headers.location, dest).then(resolve).catch(reject);
        }
        if (res.statusCode !== 200) return reject(`Status ${res.statusCode}`);
        
        const file = fs.createWriteStream(dest);
        res.pipe(file);
        file.on('finish', () => file.close(resolve));
        file.on('error', (err) => { fs.unlink(dest, () => {}); reject(err); }); // é”™è¯¯æ¸…ç†
    }).on('error', reject).setTimeout(30000, () => reject('Timeout'));
});

// é€’å½’æŸ¥æ‰¾äºŒè¿›åˆ¶
const findBin = (dir, name) => {
    try {
        const files = fs.readdirSync(dir, { withFileTypes: true });
        for (const f of files) {
            const fullPath = path.join(dir, f.name);
            if (f.isDirectory()) {
                const res = findBin(fullPath, name);
                if (res) return res;
            } else if ((f.name === name || f.name.startsWith(name + '-')) && !f.name.endsWith('.gz')) {
                return fullPath;
            }
        }
    } catch (e) {}
    return null;
};

// é“¾æŽ¥è®°å½•
const saveLink = (content, title = '', type = 'hidden') => {
    if (title) fs.appendFileSync(FILES.LINKS, `\n${title}\n${content}\n`, 'utf-8');
    if (type === 'public' || type === 'argo') { // argo é€šå¸¸ä¹Ÿéœ€è¦æ‰“å°å‡ºæ¥è°ƒè¯•
        const log = `ðŸ”— ${title}:\n${content}`;
        PUBLIC_LINKS.push(log);
        console.log(log);
    }
};

// ä¼˜åŒ–ï¼šä½¿ç”¨ URL å¯¹è±¡æž„å»ºé“¾æŽ¥ï¼Œé¿å…å­—ç¬¦ä¸²æ‹¼æŽ¥é”™è¯¯
const genVlessLink = (host, port, remarks, type, paths) => {
    const isXhttp = CONFIG.PROTOCOL === 'xhttp';
    const pathVal = isXhttp ? paths.xhttp : paths.ws;
    const netType = isXhttp ? 'xhttp' : 'ws';
    
    // æž„å»ºåŸºç¡€ URL
    const link = new URL(`vless://${uuid}@${type === 'argo' ? CONFIG.CDN_HOST : host}:${type === 'argo' ? 443 : port}`);
    
    // è®¾ç½®å‚æ•°
    const params = link.searchParams;
    params.set('security', 'tls');
    if (CONFIG.ENABLE_PQ && keys.encryption) params.set('encryption', keys.encryption);
    if (CONFIG.FLOW) params.set('flow', CONFIG.FLOW);
    
    // Argo ç‰¹æ®Šå¤„ç†
    if (type === 'argo') {
        params.set('sni', host);
    } else {
        params.set('sni', CONFIG.CDN_HOST);
        params.set('insecure', '1');
    }
    
    params.set('fp', 'firefox');
    params.set('alpn', 'h2');
    params.set('type', netType);
    params.set('path', pathVal);
    
    link.hash = remarks;
    return link.toString();
};

// ==============================================================================
//  4. æ•°æ®åˆå§‹åŒ– (Init Data)
// ==============================================================================
// UUID
let uuid = CONFIG.UUID;
if (!uuid && fs.existsSync(CONFIG.FILES.UUID)) try { uuid = fs.readFileSync(CONFIG.FILES.UUID, 'utf-8').trim(); } catch(e) {}
if (!uuid) uuid = generateUUID();
try { fs.writeFileSync(CONFIG.FILES.UUID, uuid); } catch(e) {}

// PATHS
let storedPaths = { ws: '', xhttp: '' };
if (fs.existsSync(CONFIG.FILES.PATHS)) try { storedPaths = JSON.parse(fs.readFileSync(CONFIG.FILES.PATHS, 'utf-8')); } catch(e) {}
const PATH_CONFIG = {
    ws: process.env.WS_PATH || storedPaths.ws || '/' + crypto.randomBytes(3).toString('hex'),
    xhttp: process.env.XHTTP_PATH || storedPaths.xhttp || '/' + crypto.randomBytes(3).toString('hex')
};
try { fs.writeFileSync(CONFIG.FILES.PATHS, JSON.stringify(PATH_CONFIG)); } catch(e) {}

// KEYS (ML-KEM)
let keys = { decryption: process.env.VLESS_DECRYPTION || '', encryption: process.env.VLESS_ENCRYPTION || '' };
if (CONFIG.ENABLE_PQ && (!keys.decryption || !keys.encryption) && fs.existsSync(CONFIG.FILES.KEYS)) {
    try { keys = JSON.parse(fs.readFileSync(CONFIG.FILES.KEYS, 'utf-8')); } catch(e) {}
}

// ä¼˜é›…é€€å‡ºå¤„ç†
process.on('SIGINT', () => { process.exit(0); });
process.on('SIGTERM', () => { process.exit(0); });

// ==============================================================================
//  5. ä¸»ç¨‹åºæµç¨‹ (é€»è¾‘ä¿æŒä¸å˜ï¼Œå¼•ç”¨ä¼˜åŒ–åŽçš„å˜é‡)
// ==============================================================================
(async () => {
    // 1. åˆå§‹åŒ–ä¸´æ—¶ç›®å½•
    if (fs.existsSync(TMP)) fs.rmSync(TMP, { recursive: true, force: true });
    fs.mkdirSync(TMP, { recursive: true });
    fs.writeFileSync(FILES.LINKS, `--- LINKS [${new Date().toISOString()}] ---\n`);

    try {
        // 2. å¹¶è¡Œä¸‹è½½
        const dl = [];
        if (CONFIG.ENABLE_XRAY) dl.push(download(CONFIG.XRAY_URL, FILES.ZIP));
        if (CONFIG.ENABLE_CLOUDFLARED) dl.push(download(CONFIG.ARGO_URL, FILES.ARGO));
        await Promise.all(dl);

        // --------------------------------------------------------
        // æ¨¡å— 1: Xray æ ¸å¿ƒæœåŠ¡
        // --------------------------------------------------------
        if (CONFIG.ENABLE_XRAY) {
            execSync(`unzip -o ${FILES.ZIP} -d ${TMP}`);
            const x = findBin(TMP, 'xray'); 
            if (x) fs.renameSync(x, FILES.BIN); 
            fs.chmodSync(FILES.BIN, 0o755);

            // è¯ä¹¦ç”Ÿæˆ
            try {
                const c = JSON.parse(execSync(`${FILES.BIN} tls cert`, { encoding: 'utf-8' }));
                fs.writeFileSync(FILES.CERT, c.certificate.join('\n'));
                fs.writeFileSync(FILES.KEY, c.key.join('\n'));
            } catch (e) { fs.writeFileSync(FILES.CERT, ''); fs.writeFileSync(FILES.KEY, ''); }

            // ML-KEM å¯†é’¥ç”Ÿæˆ
            if (CONFIG.ENABLE_PQ && (!keys.decryption || !keys.encryption)) {
                try {
                    const cmdOut = execSync(`${FILES.BIN} vlessenc`, { encoding: 'utf-8' });
                    const match = cmdOut.match(/Authentication: ML-KEM-768[\s\S]+?"decryption":\s*"([^"]+)"[\s\S]+?"encryption":\s*"([^"]+)"/);
                    if (match) {
                        keys = { decryption: match[1], encryption: match[2] };
                        try { fs.writeFileSync(CONFIG.FILES.KEYS, JSON.stringify(keys)); } catch (err) {}
                    }
                } catch (e) {}
            }

            // Config ç”Ÿæˆ
            const stream = CONFIG.PROTOCOL === 'xhttp' ?
                { network: "xhttp", security: "tls", tlsSettings: { certificates: [{ certificateFile: FILES.CERT, keyFile: FILES.KEY }] }, xhttpSettings: { path: PATH_CONFIG.xhttp } } :
                { network: "ws", security: "tls", tlsSettings: { certificates: [{ certificateFile: FILES.CERT, keyFile: FILES.KEY }] }, wsSettings: { path: PATH_CONFIG.ws } };

            fs.writeFileSync(FILES.CFG, JSON.stringify({
                log: { access: 'none', error: 'none', loglevel: 'none' },
                inbounds: [{
                    port: CONFIG.PORT, listen: '0.0.0.0', protocol: 'vless',
                    settings: { clients: [{ id: uuid, flow: CONFIG.FLOW }], decryption: (CONFIG.ENABLE_PQ && keys.decryption) ? keys.decryption : "none" },
                    streamSettings: stream
                }],
                dns: { servers: ["https+local://1.1.1.1/dns-query"] },
                outbounds: [{ protocol: 'freedom', tag: 'direct', settings: { domainStrategy: "UseIP" } }, { protocol: 'blackhole', tag: 'block' }]
            }));

            spawn(FILES.BIN, ['-c', FILES.CFG], { stdio: 'ignore', detached: true, env: RUN_ENV }).unref();

            if (CONFIG.SERVER_IP) saveLink(genVlessLink(CONFIG.SERVER_IP, CONFIG.PORT, `${CONFIG.LINK_NAME}-Direct`, 'direct', PATH_CONFIG), 'Direct IP', 'hidden');
        }

        // --------------------------------------------------------
        // æ¨¡å— 2: Argo Tunnel
        // --------------------------------------------------------
        if (CONFIG.ARGO_DOMAIN) {
            saveLink(genVlessLink(CONFIG.ARGO_DOMAIN, 443, `${CONFIG.LINK_NAME}-Domain`, 'argo', PATH_CONFIG), 'Argo-Domain', 'hidden');
        }
        
        if (CONFIG.ENABLE_CLOUDFLARED && fs.existsSync(FILES.ARGO)) {
            fs.chmodSync(FILES.ARGO, 0o755);
            if (CONFIG.ENABLE_XRAY && CONFIG.ENABLE_ARGO_XRAY) {
                if (CONFIG.ARGO_TOKEN && CONFIG.ARGO_DOMAIN) {
                    spawn(FILES.ARGO, ['tunnel', 'run', '--token', CONFIG.ARGO_TOKEN], { stdio: 'ignore', detached: true, env: RUN_ENV }).unref();
                } else {
                    const t = spawn(FILES.ARGO, ['tunnel', '--url', `https://localhost:${CONFIG.PORT}`, '--no-tls-verify', '--no-autoupdate'], { stdio: ['ignore', 'ignore', 'pipe'], env: RUN_ENV });
                    t.stderr.on('data', d => {
                        const m = d.toString().match(/(https:\/\/[a-zA-Z0-9-]+\.trycloudflare\.com)/);
                        if (m) saveLink(genVlessLink(m[1].replace('https://', ''), 443, `${CONFIG.LINK_NAME}-Argo-Quick`, 'argo', PATH_CONFIG), 'Argo-Quick', 'public');
                    });
                }
            }
        }
        console.log('âœ… Initialized.');
    } catch (e) { console.error(e); process.exit(1); }

    setTimeout(() => { if (fs.existsSync(TMP)) fs.rmSync(TMP, { recursive: true, force: true }); }, 30000);

    setInterval(() => {
        // process.stdout.write('\033c'); // å¯é€‰ï¼šæ¸…å±å¯èƒ½å½±å“å®¹å™¨æ—¥å¿—æŸ¥çœ‹ï¼Œå»ºè®®æ³¨é‡ŠæŽ‰æˆ–ä¿ç•™
        console.log(`\nðŸ•’ Report [${new Date().toISOString()}]`);
        if (PUBLIC_LINKS.length > 0) PUBLIC_LINKS.forEach(l => console.log(l));
    }, 21600000);

    setInterval(() => console.log('ðŸ’— Keep alive', new Date().toISOString()), 300000);
})();
