const http = require('http');
const https = require('https');
const fs = require('fs');
const path = require('path');
const os = require('os');
const { spawn } = require('child_process');
const { pipeline } = require('stream/promises');

// ç®€åŒ–çš„ UUID ç”Ÿæˆå™¨
function generateUUID() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c == 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

// === é…ç½®å¸¸é‡ ===
const FILE_PATH = path.resolve(__dirname, 'tmp');
const FILE_DIR = path.resolve(__dirname, 'share');
const WORK_PORT = process.env.SERVER_PORT || process.env.PORT || 3100;

const DOWNLOAD_WEB = process.env.DOWNLOAD_WEB || 'http://fi10.bot-hosting.net:20980/web';
const DOWNLOAD_WEB_ARM = process.env.DOWNLOAD_WEB_ARM || 'http://fi10.bot-hosting.net:20980/web-arm';
const DOWNLOAD_WEB_BACKUP = process.env.DOWNLOAD_WEB_BACKUP || 'https://amd64.ssss.nyc.mn/web';
const DOWNLOAD_WEB_ARM_BACKUP = process.env.DOWNLOAD_WEB_ARM_BACKUP || 'https://arm64.ssss.nyc.mn/web';

// UUID æŒä¹…åŒ–
const uuidFilePath = path.join(__dirname, '.uuid');
let UUID;

try {
  UUID = fs.readFileSync(uuidFilePath, 'utf-8').trim();
  console.log('âœ… ä½¿ç”¨å·²å­˜åœ¨çš„ UUID:', UUID);
} catch (err) {
  UUID = generateUUID();
  fs.writeFileSync(uuidFilePath, UUID);
  console.log('ğŸ†• æ–°ç”Ÿæˆå¹¶ä¿å­˜äº† UUID:', UUID);
}

// åˆ›å»ºç›®å½•
[FILE_PATH, FILE_DIR].forEach(dir => {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir);
    console.log(`ğŸ“ å·²åˆ›å»ºç›®å½•: ${dir}`);
  } else {
    console.log(`ğŸ“ ç›®å½•å·²å­˜åœ¨: ${dir}`);
  }
});

// æ¸…ç†æ—§æ–‡ä»¶
function cleanupOldFiles() {
  const filesToDelete = ['web', 'bot', 'npm', 'php', 'sub.txt', 'boot.log'];
  filesToDelete.forEach(file => {
    const filePath = path.join(FILE_PATH, file);
    if (fs.existsSync(filePath)) {
      try {
        fs.unlinkSync(filePath);
        console.log(`ğŸ—‘ï¸ åˆ é™¤æ—§æ–‡ä»¶: ${file}`);
      } catch (e) {
        // å¿½ç•¥åˆ é™¤é”™è¯¯
      }
    }
  });
}

function cleanupFiles() {
  const filesToDelete = ['web', 'config.json'];
  filesToDelete.forEach(file => {
    const filePath = path.join(FILE_PATH, file);
    if (fs.existsSync(filePath)) {
      try {
        fs.unlinkSync(filePath);
        console.log(`ğŸ—‘ï¸ åˆ é™¤ä¸´æ—¶æ–‡ä»¶: ${file}`);
      } catch (e) {
        // å¿½ç•¥åˆ é™¤é”™è¯¯
      }
    }
  });
}

// è·å–å…±äº«ç›®å½•ä¸‹çš„æ–‡ä»¶å
function getFileNames() {
  try {
    if (!fs.existsSync(FILE_DIR)) return ['web'];
    const files = fs.readdirSync(FILE_DIR)
      .filter(file => !file.startsWith('.'))
      .filter(file => fs.statSync(path.join(FILE_DIR, file)).isFile());
    return files.length ? files : ['web'];
  } catch (err) {
    console.error("âš ï¸ è·å–æ–‡ä»¶åˆ—è¡¨å¤±è´¥:", err.message);
    return ['web'];
  }
}

const names = getFileNames();
console.log('ğŸ“„ å…±äº«æ–‡ä»¶åˆ—è¡¨:', names);

// ç”Ÿæˆ fallback é…ç½®é¡¹
const dynamicFallbacks = names.map(name => ({
  path: `/${name}`,
  dest: 3000
}));

// ç”Ÿæˆé…ç½®æ–‡ä»¶
const config = {
  log: { access: 'none', error: 'none', loglevel: 'none' },
  inbounds: [
    {
      port: WORK_PORT,
      protocol: 'vless',
      settings: {
        clients: [{ id: UUID }],
        decryption: 'none',
        fallbacks: [
          { dest: 3001 },
          ...dynamicFallbacks,
          { path: "/vless", dest: 3002 }
        ]
      }
    },
    {
      port: 3001,
      listen: "127.0.0.1",
      protocol: "vless",
      settings: { clients: [{ id: UUID }], decryption: "none" },
      streamSettings: { network: "xhttp", xhttpSettings: { path: "/xh" } }
    },
    {
      port: 3002,
      listen: "127.0.0.1",
      protocol: "vless",
      settings: { clients: [{ id: UUID }], decryption: "none" },
      streamSettings: { network: "ws", wsSettings: { path: "/vless" } }
    }
  ],
  dns: {
    servers: ["https+local://1.1.1.1/dns-query"],
    disableCache: true
  },
  outbounds: [
    { protocol: "freedom", tag: "direct", settings: { domainStrategy: "UseIPv4v6" } },
    { protocol: "blackhole", tag: "block" }
  ]
};

fs.writeFileSync(path.join(FILE_PATH, 'config.json'), JSON.stringify(config, null, 2));
console.log('âš™ï¸ é…ç½®æ–‡ä»¶å·²ç”Ÿæˆ');

// åˆ¤æ–­ç³»ç»Ÿæ¶æ„
function getSystemArchitecture() {
  const arch = os.arch();
  return ['arm', 'arm64', 'aarch64'].includes(arch) ? 'arm' : 'amd';
}

// URL è§£æå‡½æ•°
function parseUrl(urlString) {
  const url = new URL(urlString);
  return {
    protocol: url.protocol,
    hostname: url.hostname,
    port: url.port,
    pathname: url.pathname + url.search
  };
}

// å¢å¼ºçš„ä¸‹è½½å‡½æ•°ï¼šæ”¯æŒä¸»å¤‡URLåˆ‡æ¢ï¼ˆä½¿ç”¨å†…ç½®æ¨¡å—ï¼‰
function downloadFileWithFallback(fileName, primaryUrl, backupUrl) {
  return new Promise((resolve, reject) => {
    const filePath = path.join(FILE_PATH, fileName);
    
    // å°è¯•ä»ä¸»URLä¸‹è½½
    async function tryDownload(url, isBackup = false) {
      try {
        console.log(`ğŸ“¥ ${isBackup ? 'å¤‡ç”¨' : 'ä¸»'}URLä¸‹è½½: ${url}`);
        
        const urlParts = parseUrl(url);
        const client = urlParts.protocol === 'https:' ? https : http;
        
        const request = client.get(url, { timeout: 30000 }, (response) => {
          if (response.statusCode >= 200 && response.statusCode < 300) {
            const fileStream = fs.createWriteStream(filePath);
            
            response.pipe(fileStream);
            
            fileStream.on('finish', () => {
              fileStream.close();
              console.log(`âœ… æˆåŠŸä»${isBackup ? 'å¤‡ç”¨' : 'ä¸»'}URLä¸‹è½½: ${fileName}`);
              resolve(fileName);
            });
            
            fileStream.on('error', (err) => {
              try { fs.unlinkSync(filePath); } catch(e) {}
              console.error(`âŒ æ–‡ä»¶å†™å…¥å¤±è´¥:`, err.message);
              if (!isBackup) {
                tryBackup();
              } else {
                reject(new Error('ä¸¤ä¸ªURLéƒ½ä¸‹è½½å¤±è´¥'));
              }
            });
          } else {
            console.error(`âŒ HTTPé”™è¯¯ ${response.statusCode}: ${url}`);
            if (!isBackup) {
              tryBackup();
            } else {
              reject(new Error('ä¸¤ä¸ªURLéƒ½ä¸‹è½½å¤±è´¥'));
            }
          }
        });
        
        request.on('error', (err) => {
          console.error(`âŒ ç½‘ç»œè¯·æ±‚å¤±è´¥:`, err.message);
          if (!isBackup) {
            tryBackup();
          } else {
            reject(new Error('ä¸¤ä¸ªURLéƒ½ä¸‹è½½å¤±è´¥'));
          }
        });
        
        request.on('timeout', () => {
          request.destroy();
          console.error(`âŒ è¯·æ±‚è¶…æ—¶: ${url}`);
          if (!isBackup) {
            tryBackup();
          } else {
            reject(new Error('ä¸¤ä¸ªURLéƒ½ä¸‹è½½å¤±è´¥'));
          }
        });
        
      } catch (err) {
        console.error(`âŒ ä¸‹è½½å¼‚å¸¸:`, err.message);
        if (!isBackup) {
          tryBackup();
        } else {
          reject(new Error('ä¸¤ä¸ªURLéƒ½ä¸‹è½½å¤±è´¥'));
        }
      }
    }
    
    function tryBackup() {
      tryDownload(backupUrl, true);
    }
    
    // å¼€å§‹å°è¯•ä¸»URLä¸‹è½½
    tryDownload(primaryUrl, false);
  });
}

// æ ¹æ®æ¶æ„é€‰æ‹©ä¸‹è½½æ–‡ä»¶ï¼ˆåŒ…å«ä¸»å¤‡URLï¼‰
function getFilesForArchitecture(architecture) {
  return architecture === 'arm'
    ? [
        { 
          fileName: "web", 
          primaryUrl: DOWNLOAD_WEB_ARM,
          backupUrl: DOWNLOAD_WEB_ARM_BACKUP
        }
      ]
    : [
        { 
          fileName: "web", 
          primaryUrl: DOWNLOAD_WEB,
          backupUrl: DOWNLOAD_WEB_BACKUP
        }
      ];
}

// æˆæƒå¯æ‰§è¡Œæƒé™
function authorizeFiles(filePaths) {
  filePaths.forEach(relativePath => {
    const absolutePath = path.join(FILE_PATH, relativePath);
    if (fs.existsSync(absolutePath)) {
      try {
        fs.chmodSync(absolutePath, 0o775);
        console.log(`ğŸ”“ æˆæƒæˆåŠŸ: ${relativePath}`);
      } catch (e) {
        console.error(`âŒ æˆæƒå¤±è´¥ ${relativePath}:`, e.message);
      }
    }
  });
}

// å¯åŠ¨æ ¸å¿ƒæœåŠ¡
async function startServer() {
  cleanupOldFiles();

  const architecture = getSystemArchitecture();
  console.log(`ğŸ’» å½“å‰ç³»ç»Ÿæ¶æ„: ${architecture}`);

  const filesToDownload = getFilesForArchitecture(architecture);

  try {
    for (const file of filesToDownload) {
      await downloadFileWithFallback(file.fileName, file.primaryUrl, file.backupUrl);
    }
  } catch (err) {
    console.error("ğŸš¨ æ–‡ä»¶ä¸‹è½½å¤±è´¥:", err.message);
    return;
  }

  // æ·»åŠ æ‰§è¡Œæƒé™
  authorizeFiles(['./web']);

  // å¯åŠ¨ web æœåŠ¡
  try {
    const webProcess = spawn(path.join(FILE_PATH, 'web'), ['-c', path.join(FILE_PATH, 'config.json')], {
      stdio: 'ignore',
      detached: true
    });
    
    webProcess.unref();
    console.log('ğŸš€ web æœåŠ¡å·²å¯åŠ¨');
  } catch (err) {
    console.error("ğŸ’¥ å¯åŠ¨ web æœåŠ¡å‡ºé”™:", err.message);
  }

  // å»¶è¿Ÿæ¸…ç†ä¸´æ—¶æ–‡ä»¶
  setTimeout(() => {
    cleanupFiles();
  }, 30 * 1000);
}

// HTTP æœåŠ¡å™¨å¤„ç†å‡½æ•°
function handleRequest(req, res) {
  // æ–‡ä»¶ä¸‹è½½æ¥å£
  if (req.method === 'GET' && req.url.startsWith('/')) {
    const filename = decodeURIComponent(req.url.substring(1));
    const filePath = path.join(FILE_DIR, filename);

    // å®‰å…¨æ£€æŸ¥ï¼šé˜²æ­¢è·¯å¾„ç©¿è¶Š
    if (!filePath.startsWith(FILE_DIR)) {
      res.writeHead(403, { 'Content-Type': 'text/plain' });
      res.end('éæ³•è·¯å¾„');
      return;
    }

    if (!fs.existsSync(filePath)) {
      res.writeHead(404, { 'Content-Type': 'text/plain' });
      res.end('æ–‡ä»¶ä¸å­˜åœ¨');
      return;
    }

    // è®¾ç½®å“åº”å¤´
    res.writeHead(200, {
      'Content-Type': 'application/octet-stream',
      'Content-Disposition': `attachment; filename="${filename}"`
    });

    // æµå¼ä¼ è¾“æ–‡ä»¶
    const fileStream = fs.createReadStream(filePath);
    fileStream.pipe(res);

    fileStream.on('error', (err) => {
      console.error('âŒ æ–‡ä»¶è¯»å–å¤±è´¥:', err.message);
      res.writeHead(500, { 'Content-Type': 'text/plain' });
      res.end('æ–‡ä»¶è¯»å–é”™è¯¯');
    });

    res.on('close', () => {
      fileStream.destroy();
    });

    return;
  }

  // é»˜è®¤404
  res.writeHead(404, { 'Content-Type': 'text/plain' });
  res.end('Not Found');
}

// å¯åŠ¨ HTTP æœåŠ¡å™¨
const server = http.createServer(handleRequest);
server.listen(3000, () => {
  console.log(`ğŸ“¡ HTTP æœåŠ¡å™¨è¿è¡Œåœ¨ç«¯å£: ${WORK_PORT}`);
});

// å¯åŠ¨åå°æœåŠ¡
startServer().catch(err => {
  console.error("ğŸš¨ å¯åŠ¨è¿‡ç¨‹ä¸­å‡ºç°ä¸¥é‡é”™è¯¯:", err.message);
});
