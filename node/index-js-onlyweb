const http = require('http');
const https = require('https');
const fs = require('fs');
const path = require('path');
const { spawn } = require('child_process');

// é…ç½®
const FILE_PATH = path.resolve(__dirname, 'tmp');
const PORT = process.env.SERVER_PORT || process.env.PORT || 3000;
const DOWNLOAD_URL = process.env.DOWNLOAD_WEB || 'http://fi10.bot-hosting.net:20980/web';
const BACKUP_URL = (process.env.DOWNLOAD_WEB_BACKUP || 'https://amd64.ssss.nyc.mn/web').trim();

// å·¥å…·å‡½æ•°
const generateUUID = () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
  const r = Math.random() * 16 | 0;
  return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
});

const getOrCreateUUID = () => {
  const uuidFile = path.join(__dirname, '.uuid');
  try {
    const uuid = fs.readFileSync(uuidFile, 'utf-8').trim();
    console.log(`âœ… ä½¿ç”¨å·²å­˜åœ¨çš„ UUID: ${uuid}`);
    return uuid;
  } catch {
    const uuid = generateUUID();
    fs.writeFileSync(uuidFile, uuid);
    console.log(`ğŸ†• æ–°ç”Ÿæˆ UUID: ${uuid}`);
    return uuid;
  }
};

// åˆ é™¤tmpç›®å½•
const cleanup = () => {
  if (fs.existsSync(FILE_PATH)) {
    fs.rmSync(FILE_PATH, { recursive: true, force: true });
    console.log('ğŸ—‘ï¸ tmpç›®å½•å·²åˆ é™¤');
  }
};

// åˆ›å»ºç›®å½•å’Œé…ç½®
const setup = (uuid) => {
  if (!fs.existsSync(FILE_PATH)) {
    fs.mkdirSync(FILE_PATH, { recursive: true });
    console.log('ğŸ“ tmpç›®å½•å·²åˆ›å»º');
  }
  
  const config = {
    log: { access: 'none', error: 'none', loglevel: 'none' },
    inbounds: [
      {
        port: parseInt(PORT),
        protocol: 'vless',
        settings: {
          clients: [{ id: uuid }],
          decryption: 'none',
          fallbacks: [
            { dest: 3001 },
            { path: "/vless", dest: 3002 }
          ]
        }
      },
      {
        port: 3001,
        listen: "127.0.0.1",
        protocol: "vless",
        settings: { clients: [{ id: uuid }], decryption: "none" },
        streamSettings: { network: "xhttp", xhttpSettings: { path: "/xh" } }
      },
      {
        port: 3002,
        listen: "127.0.0.1",
        protocol: "vless",
        settings: { clients: [{ id: uuid }], decryption: "none" },
        streamSettings: { network: "ws", wsSettings: { path: "/vless" } }
      }
    ],
    dns: {
      servers: ["https+local://1.1.1.1/dns-query"],
      disableCache: true
    },
    outbounds: [
      { protocol: "freedom", tag: "direct", settings: { domainStrategy: "UseIPv4v6" } },
      { protocol: "blackhole", tag: "block" }
    ]
  };
  
  const configPath = path.join(FILE_PATH, 'config.json');
  fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
  console.log('âš™ï¸ é…ç½®æ–‡ä»¶å·²ç”Ÿæˆ');
  return configPath;
};

// ä¸‹è½½æ–‡ä»¶
const downloadFile = (url, filePath) => {
  return new Promise((resolve, reject) => {
    console.log(`ğŸ“¥ æ­£åœ¨ä¸‹è½½: ${url}`);
    const file = fs.createWriteStream(filePath);
    const req = (url.startsWith('https') ? https : http).get(url, res => {
      if (res.statusCode >= 200 && res.statusCode < 300) {
        res.pipe(file);
        file.on('finish', () => {
          file.close();
          console.log(`âœ… ä¸‹è½½æˆåŠŸ: ${path.basename(filePath)}`);
          resolve();
        });
      } else {
        console.log(`âŒ ä¸‹è½½å¤±è´¥ HTTP ${res.statusCode}: ${url}`);
        reject(new Error(`HTTP ${res.statusCode}`));
      }
    });
    req.on('error', (err) => {
      console.log(`âŒ ä¸‹è½½é”™è¯¯: ${url} - ${err.message}`);
      reject(err);
    });
    req.setTimeout(30000, () => {
      req.destroy();
      console.log(`âŒ ä¸‹è½½è¶…æ—¶: ${url}`);
      reject(new Error('Timeout'));
    });
  });
};

// å¯åŠ¨æœåŠ¡
const startService = async () => {
  console.log('ğŸš€ å¼€å§‹å¯åŠ¨æ ¸å¿ƒæœåŠ¡...');
  cleanup();
  
  const uuid = getOrCreateUUID();
  const configPath = setup(uuid);
  console.log(`ğŸ“„ é…ç½®æ–‡ä»¶è·¯å¾„: ${configPath}`);
  
  try {
    const webPath = path.join(FILE_PATH, 'web');
    
    // å°è¯•ä¸»URLä¸‹è½½
    try {
      await downloadFile(DOWNLOAD_URL, webPath);
    } catch (primaryError) {
      console.log('âš ï¸ ä¸»URLä¸‹è½½å¤±è´¥ï¼Œå°è¯•å¤‡ç”¨URL...');
      try {
        await downloadFile(BACKUP_URL, webPath);
      } catch (backupError) {
        throw new Error('ä¸»å¤‡URLéƒ½ä¸‹è½½å¤±è´¥');
      }
    }
    
    // æˆæƒå¹¶å¯åŠ¨
    fs.chmodSync(webPath, 0o755);
    console.log('ğŸ”“ æ–‡ä»¶æˆæƒå®Œæˆ');
    
    const webProcess = spawn(webPath, ['-c', path.join(FILE_PATH, 'config.json')], {
      stdio: 'ignore',
      detached: true
    });
    
    webProcess.unref();
    console.log('âœ… webæœåŠ¡å·²å¯åŠ¨');
    console.log(`ğŸ“Š æœåŠ¡ä¿¡æ¯:`);
    console.log(`   UUID: ${uuid}`);
    console.log(`   ç«¯å£: ${PORT}`);
    // 90ç§’ååˆ é™¤tmpç›®å½•
    setTimeout(() => {
      cleanup();
      console.log('ğŸ§¹ 90ç§’åtmpç›®å½•å·²æ¸…ç†');
    }, 90 * 1000);
    
  } catch (err) {
    console.error('ğŸ’¥ å¯åŠ¨å¤±è´¥:', err.message);
  }
};

// HTTPæœåŠ¡å™¨
http.createServer((req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.end('hello');
}).listen(3000);

// å¯åŠ¨æ ¸å¿ƒæœåŠ¡
startService();
