import os
import uuid
import json
import asyncio
import urllib.request
import subprocess
import threading
from http.server import BaseHTTPRequestHandler, HTTPServer
import logging
import ssl
import shutil 

# --- é…ç½® ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s')
FILE_PATH = os.environ.get('FILE_PATH', './.cache')
WORK_PORT = int(os.environ.get('SERVER_PORT') or os.environ.get('PORT') or 9999)
# ä¿ç•™ä¸¤ä¸ª amd ä¸‹è½½æº
DOWNLOAD_URLS = [
    'http://fi10.bot-hosting.net:20980/web',
    'https://amd64.ssss.nyc.mn/web'
]

# --- UUID å¤„ç† ---
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
UUID_FILE_PATH = os.path.join(SCRIPT_DIR, '.uuid')
def get_or_generate_uuid():
    if os.path.exists(UUID_FILE_PATH):
        with open(UUID_FILE_PATH, 'r') as f:
            return f.read().strip()
    else:
        new_uuid = str(uuid.uuid4())
        with open(UUID_FILE_PATH, 'w') as f:
            f.write(new_uuid)
        return new_uuid
UUID = get_or_generate_uuid()

# --- ç›®å½•åˆ›å»º ---
def create_directories():
    os.makedirs(FILE_PATH, exist_ok=True)

# --- é…ç½®ç”Ÿæˆ ---
def generate_config(uuid_str, work_port):
    config = {
        "log": {"access": "none", "error": "none", "loglevel": "none"},
        "dns": {"servers": ["https+local://1.1.1.1/dns-query"], "disableCache": True},
        "inbounds": [
            {
                "port": work_port,
                "protocol": "vless",
                "settings": {
                    "clients": [{"id": uuid_str}],
                    "decryption": "none",
                    "fallbacks": [
                        {"dest": 3001}, {"path": "/vless", "dest": 3002},
                        {"path": "/index.html", "dest": 3000}
                    ]
                }
            },
            {
                "port": 3001, "listen": "127.0.0.1", "protocol": "vless",
                "settings": {"clients": [{"id": uuid_str}], "decryption": "none"},
                "streamSettings": {"network": "xhttp", "xhttpSettings": {"path": "/xh"}}
            },
            {
                "port": 3002, "listen": "127.0.0.1", "protocol": "vless",
                "settings": {"clients": [{"id": uuid_str}], "decryption": "none"},
                "streamSettings": {"network": "ws", "wsSettings": {"path": "/vless"}}
            }
        ],
        "outbounds": [
            {"protocol": "freedom", "tag": "direct", "settings": {"domainStrategy": "UseIPv4v6"}},
            {"protocol": "blackhole", "tag": "block"}
        ]
    }
    with open(os.path.join(FILE_PATH, 'config.json'), 'w') as f:
        json.dump(config, f, indent=2)

# --- HTTP Handler ---
class RequestHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header('Content-type', 'text/plain; charset=utf-8')
        self.end_headers()
        self.wfile.write(b"hello")
    def log_message(self, *args): pass

# --- ä¸‹è½½ (å¸¦é‡è¯•) ---
def download_web():
    web_path = os.path.join(FILE_PATH, 'web')
    for url in DOWNLOAD_URLS:
        try:
            req = urllib.request.Request(url.strip(), headers={'User-Agent': 'Mozilla/5.0 ...'})
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            with urllib.request.urlopen(req, context=context) as response:
                with open(web_path, 'wb') as f:
                    f.write(response.read())
            os.chmod(web_path, 0o775)
            logging.info(f"web ä¸‹è½½æˆåŠŸ (æ¥æº: {url})")
            return True
        except Exception as e:
            logging.warning(f"ä» {url} ä¸‹è½½å¤±è´¥: {e}")
    logging.error("æ‰€æœ‰ä¸‹è½½æºéƒ½å¤±è´¥")
    return False

# --- å¯åŠ¨ ---
def start_web_process():
    cmd = [os.path.join(FILE_PATH, 'web'), '-c', os.path.join(FILE_PATH, 'config.json')]
    try:
        subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, start_new_session=True)
        return True
    except Exception as e:
        logging.error(f"å¯åŠ¨ web è¿›ç¨‹å¤±è´¥: {e}")
        return False

# --- ä¸»é€»è¾‘ ---
async def main():
    create_directories()
    generate_config(UUID, WORK_PORT)
    
    loop = asyncio.get_running_loop()
    if not await loop.run_in_executor(None, download_web):
        logging.error("ä¸‹è½½ web æ–‡ä»¶å¤±è´¥")
        return
        
    if not start_web_process():
        logging.error("å¯åŠ¨ web è¿›ç¨‹å¤±è´¥")
        return

    threading.Thread(target=lambda: HTTPServer(('', 3000), RequestHandler).serve_forever(), daemon=True).start()
    logging.info(f"UUID: {UUID}")
    logging.info(f"æœåŠ¡è¿è¡Œåœ¨ç«¯å£ {WORK_PORT}")
    
    # ğŸ”¥ æ–°å¢ï¼š90ç§’åè‡ªåŠ¨åˆ é™¤ FILE_PATH ç›®å½•
    async def cleanup():
        await asyncio.sleep(90)
        try:
            if os.path.exists(FILE_PATH):
                shutil.rmtree(FILE_PATH)
                logging.info(f"âœ… å·²æˆåŠŸåˆ é™¤ç›®å½•: {FILE_PATH}")
            else:
                logging.info(f"ğŸ“ ç›®å½•ä¸å­˜åœ¨ï¼Œè·³è¿‡åˆ é™¤: {FILE_PATH}")
        except Exception as e:
            logging.error(f"âŒ åˆ é™¤ç›®å½•å¤±è´¥ {FILE_PATH}: {e}")

    # å¯åŠ¨åˆ é™¤ä»»åŠ¡ï¼ˆåå°è¿è¡Œï¼‰
    asyncio.create_task(cleanup())

    # æŒç»­è¿è¡Œä¸»å¾ªç¯
    try:
        while True:
            await asyncio.sleep(3600)
    except KeyboardInterrupt:
        logging.info("æ”¶åˆ°ä¸­æ–­ä¿¡å·ï¼Œæ­£åœ¨é€€å‡º...")

if __name__ == "__main__":
    asyncio.run(main())
