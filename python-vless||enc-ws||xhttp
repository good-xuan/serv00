import os
import sys
import json
import time
import uuid
import shutil
import random
import socket
import struct
import subprocess
import threading
import urllib.request
import urllib.error
import zipfile
import tarfile
from urllib.parse import quote

# ==============================================================================
#   1. åŸºç¡€é…ç½®ä¸ç«¯å£
# ==============================================================================
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
TMP = os.path.join(BASE_DIR, 'tmp')
BIN = os.path.join(TMP, 'web')              # Xray Binary
ARGO_BIN = os.path.join(TMP, 'cloudflared') # Argo Binary
FRPC_BIN = os.path.join(TMP, 'frpc')        # FRP Binary

# æ ¸å¿ƒç«¯å£
PORT = int(os.environ.get('SERVER_PORT', os.environ.get('PORT', 3000)))

# æ–‡ä»¶è·¯å¾„
CFG = os.path.join(TMP, 'config.json')
ZIP = os.path.join(TMP, 'xray.zip')
FRPC_TAR = os.path.join(TMP, 'frp.tar.gz')
FRPC_CFG = os.path.join(TMP, 'frpc.ini')

# è¯ä¹¦ä¸å¯†é’¥
CERT_FILE = os.path.join(TMP, 'cert.pem')
KEY_FILE = os.path.join(TMP, 'key.pem')
UUID_FILE = os.path.join(BASE_DIR, '.uuid')
KEYS_FILE = os.path.join(BASE_DIR, '.keys')
PATHS_FILE = os.path.join(BASE_DIR, '.paths')

# å†…å­˜ä¸­å­˜å‚¨ç”Ÿæˆçš„é“¾æ¥
SAVED_LINKS = []

# ==============================================================================
#   2. å¤–éƒ¨å˜é‡ä¸ç¯å¢ƒé…ç½®
# ==============================================================================
XRAY_URL = 'https://github.com/XTLS/Xray-core/releases/latest/download/Xray-linux-64.zip'
CDN_HOST = 'www.visa.com.sg'

# --- èŠ‚ç‚¹åç§°å‰ç¼€ ---
LINK_NAME = os.environ.get('LINK_NAME', 'Node')

# --- æ ¸å¿ƒåè®®é€‰æ‹© ---
XRAY_PROTOCOL = os.environ.get('XRAY_PROTOCOL', 'ws') # 'ws' or 'xhttp'

# --- åé‡å­å¯†ç æ§åˆ¶ ---
# é»˜è®¤ä¸º trueï¼Œè‹¥è¦å…³é—­è¯·è®¾ç½® ENABLE_PQ=false
ENABLE_PQ = os.environ.get('ENABLE_PQ', 'true').lower() != 'false'

# --- Flow ä¸ Decryption é€»è¾‘ ---
# å¼€å¯ PQ æ—¶ä½¿ç”¨ xtls-rprx-visionï¼Œå…³é—­æ—¶ä¸ºç©º
FLOW = 'xtls-rprx-vision' if ENABLE_PQ else ''

# --- ç›´è¿ Host ---
SERVER_HOST = os.environ.get('SERVER_IP', '127.0.0.1')

# --- Argo é…ç½® ---
ENABLE_ARGO = os.environ.get('ENABLE_ARGO', 'true').lower() != 'false'
ARGO_TOKEN = os.environ.get('ARGO_TOKEN', '')
ARGO_DOMAIN = os.environ.get('ARGO_DOMAIN', '')

# --- FRP é…ç½® ---
FRPS_HOST = os.environ.get('FRPS_HOST', 'uss.afrp.net')
FRPS_PORT = os.environ.get('FRPS_PORT', '7000')
FRPC_TOKEN = os.environ.get('FRPC_TOKEN', 'afrp.net')

FRPC_TCP_PORT = os.environ.get('FRPC_TCP_PORT', '')
FRPC_DOMAIN = os.environ.get('FRPC_DOMAIN', '')

NEED_FRP = bool(FRPS_HOST and FRPC_TOKEN and (FRPC_TCP_PORT or FRPC_DOMAIN))
SHOW_LINKS = os.environ.get('SHOW_LINKS', 'false').lower() == 'true'

# ==============================================================================
#   3. åˆå§‹åŒ– (UUID/è·¯å¾„/å¯†é’¥)
# ==============================================================================

# 1. UUID
user_uuid = os.environ.get('UUID', '')
if not user_uuid and os.path.exists(UUID_FILE):
    try:
        with open(UUID_FILE, 'r') as f:
            user_uuid = f.read().strip()
    except: pass

if not user_uuid:
    user_uuid = str(uuid.uuid4())

try:
    with open(UUID_FILE, 'w') as f:
        f.write(user_uuid)
except: pass

# 2. Path
WS_PATH = os.environ.get('WS_PATH', '')
XHTTP_PATH = os.environ.get('XHTTP_PATH', '')

if (not WS_PATH or not XHTTP_PATH) and os.path.exists(PATHS_FILE):
    try:
        with open(PATHS_FILE, 'r') as f:
            stored_paths = json.load(f)
            if not WS_PATH: WS_PATH = stored_paths.get('ws', '')
            if not XHTTP_PATH: XHTTP_PATH = stored_paths.get('xhttp', '')
    except: pass

def gen_path():
    return '/' + ''.join(random.choices('abcdefghijklmnopqrstuvwxyz0123456789', k=6))

if not WS_PATH: WS_PATH = gen_path()
if not XHTTP_PATH: XHTTP_PATH = gen_path()

try:
    with open(PATHS_FILE, 'w') as f:
        json.dump({"ws": WS_PATH, "xhttp": XHTTP_PATH}, f)
except: pass

# 3. Keys (ä»…åœ¨ ENABLE_PQ ä¸º True æ—¶å¤„ç†)
DECRYPTION = ''
ENCRYPTION = ''

if ENABLE_PQ:
    DECRYPTION = os.environ.get('VLESS_DECRYPTION', '')
    ENCRYPTION = os.environ.get('VLESS_ENCRYPTION', '')

    if (not DECRYPTION or not ENCRYPTION) and os.path.exists(KEYS_FILE):
        try:
            with open(KEYS_FILE, 'r') as f:
                stored_keys = json.load(f)
                if not DECRYPTION: DECRYPTION = stored_keys.get('decryption', '')
                if not ENCRYPTION: ENCRYPTION = stored_keys.get('encryption', '')
        except: pass

# ==============================================================================
#   4. è¾…åŠ©å‡½æ•°
# ==============================================================================

def download_file(url, dest):
    """Downloads a file using urllib."""
    try:
        # Handling redirects automatically is standard in urllib.request
        with urllib.request.urlopen(url, timeout=30) as response, open(dest, 'wb') as out_file:
            shutil.copyfileobj(response, out_file)
    except Exception as e:
        print(f"Failed to download {url}: {e}")
        raise

def get_frp_url():
    """Fetches the latest FRP release URL."""
    print('ğŸ” Checking latest FRP version...')
    fallback = 'https://github.com/fatedier/frp/releases/download/v0.61.0/frp_0.61.0_linux_amd64.tar.gz'
    try:
        # Check redirects to find version
        req = urllib.request.Request('https://github.com/fatedier/frp/releases/latest', method='HEAD')
        with urllib.request.urlopen(req, timeout=5) as res:
            final_url = res.geturl()
            # GitHub usually redirects .../latest to .../tag/vX.Y.Z
            if '/tag/' in final_url:
                tag = final_url.split('/')[-1]
                if not tag.startswith('v'): tag = 'v' + tag
                ver_num = tag.lstrip('v')
                return f'https://github.com/fatedier/frp/releases/download/{tag}/frp_{ver_num}_linux_amd64.tar.gz'
            return fallback
    except:
        return fallback

def find_bin(directory, name):
    """Recursively finds a binary file."""
    for root, dirs, files in os.walk(directory):
        for file in files:
            if (file == name or file.startswith(name + '-')) and not file.endswith('.gz'):
                return os.path.join(root, file)
    return None

def print_link(host, port, remarks, link_type):
    """Generates and prints the VLESS link."""
    link = ''
    current_path = XHTTP_PATH if XRAY_PROTOCOL == 'xhttp' else WS_PATH
    current_type = 'xhttp' if XRAY_PROTOCOL == 'xhttp' else 'ws'
    
    # æ„é€  encryption å‚æ•° (ä»…åœ¨ PQ å¼€å¯ä¸”æœ‰ Key æ—¶)
    enc_param = f"encryption={ENCRYPTION}&" if (ENABLE_PQ and ENCRYPTION) else ""
    
    # 1. Argo
    if link_type == 'argo':
        link = (f"vless://{user_uuid}@{CDN_HOST}:443?{enc_param}security=tls&flow={FLOW}"
                f"&sni={host}&fp=firefox&alpn=h2&type={current_type}"
                f"&path={quote(current_path)}#{remarks}")
    
    # 2. HTTPS (FRP)
    elif link_type == 'https':
        link = (f"vless://{user_uuid}@{host}:443?{enc_param}security=tls&sni={host}"
                f"&flow={FLOW}&fp=firefox&alpn=h2&type={current_type}"
                f"&path={quote(current_path)}&insecure=1#{remarks}")
    
    # 3. Direct/TCP
    else:
        link = (f"vless://{user_uuid}@{host}:{port}?{enc_param}security=tls&sni={CDN_HOST}"
                f"&flow={FLOW}&fp=firefox&alpn=h2&type={current_type}"
                f"&path={quote(current_path)}&insecure=1#{remarks}")

    output = f"ğŸ”— {remarks} Link:\n{link}"
    print(f"\n{output}\n")
    SAVED_LINKS.append(output)

def start_frp():
    """Configures and starts FRP."""
    print(f"â˜ï¸  Starting FRP -> {FRPS_HOST}...")
    ini_content = f"""[common]
server_addr = {FRPS_HOST}
server_port = {FRPS_PORT}
token = {FRPC_TOKEN}
"""
    if FRPC_TCP_PORT:
        ini_content += f"""
[tcp-{user_uuid[:5]}]
type = tcp
local_ip = 127.0.0.1
local_port = {PORT}
remote_port = {FRPC_TCP_PORT}
"""
    if FRPC_DOMAIN:
        ini_content += f"""
[https-{user_uuid[:5]}]
type = https
custom_domains = {FRPC_DOMAIN}
local_port = {PORT}
"""
    with open(FRPC_CFG, 'w') as f:
        f.write(ini_content)
    
    subprocess.Popen([FRPC_BIN, '-c', FRPC_CFG], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    
    if FRPC_TCP_PORT:
        print_link(FRPS_HOST, FRPC_TCP_PORT, f"{LINK_NAME}-FRP-TCP", 'tcp')
    if FRPC_DOMAIN:
        print_link(FRPC_DOMAIN, 443, f"{LINK_NAME}-FRP-HTTPS", 'https')

# ==============================================================================
#   5. ä¸»ç¨‹åºé€»è¾‘
# ==============================================================================

def main():
    # æ¸…ç†æ—§ç¯å¢ƒ
    if os.path.exists(TMP):
        shutil.rmtree(TMP, ignore_errors=True)
    os.makedirs(TMP, exist_ok=True)

    try:
        print('â³ Downloading binaries...')
        
        # å¤šçº¿ç¨‹ä¸‹è½½ä»¥åŠ å¿«é€Ÿåº¦
        threads = []
        threads.append(threading.Thread(target=download_file, args=(XRAY_URL, ZIP)))
        
        if ENABLE_ARGO:
            argo_url = 'https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64'
            threads.append(threading.Thread(target=download_file, args=(argo_url, ARGO_BIN)))
            
        frp_url = ""
        if NEED_FRP:
            frp_url = get_frp_url()
            print(f"â¬ Downloading FRP from {frp_url}")
            threads.append(threading.Thread(target=download_file, args=(frp_url, FRPC_TAR)))

        for t in threads:
            t.start()
        for t in threads:
            t.join()

        # --- å®‰è£…ä¸é…ç½® Xray ---
        print('ğŸ“¦ Unzipping Xray...')
        with zipfile.ZipFile(ZIP, 'r') as zip_ref:
            zip_ref.extractall(TMP)
        
        xray_found = find_bin(TMP, 'xray')
        if xray_found:
            shutil.move(xray_found, BIN)
        
        os.chmod(BIN, 0o755)

        print('ğŸ” Generating certs...')
        # ç”Ÿæˆè‡ªç­¾åè¯ä¹¦
        try:
            cmd_out = subprocess.check_output([BIN, 'tls', 'cert'], text=True)
            cert_data = json.loads(cmd_out)
            with open(CERT_FILE, 'w') as f: f.write('\n'.join(cert_data['certificate']))
            with open(KEY_FILE, 'w') as f: f.write('\n'.join(cert_data['key']))
        except Exception as e:
            # Fallback creation
            open(CERT_FILE, 'w').close()
            open(KEY_FILE, 'w').close()

        # ç”Ÿæˆ/æ£€æŸ¥ ML-KEM å¯†é’¥
        global DECRYPTION, ENCRYPTION
        if ENABLE_PQ and (not DECRYPTION or not ENCRYPTION):
            try:
                print('ğŸ” Generating ML-KEM Keys...')
                cmd_out = subprocess.check_output([BIN, 'vlessenc'], text=True)
                # ç®€å•è§£æè¾“å‡º
                import re
                d_match = re.search(r'"decryption":\s*"([^"]+)"', cmd_out)
                e_match = re.search(r'"encryption":\s*"([^"]+)"', cmd_out)
                if d_match and e_match:
                    DECRYPTION = d_match.group(1)
                    ENCRYPTION = e_match.group(1)
                    with open(KEYS_FILE, 'w') as f:
                        json.dump({"decryption": DECRYPTION, "encryption": ENCRYPTION}, f)
            except Exception as e:
                print('âš ï¸ Failed to generate ML-KEM keys, falling back to standard VLESS.')

        # å¯åŠ¨ Xray
        print(f"âš™ï¸  Configuring Xray ({XRAY_PROTOCOL.upper()}) | PQ: {ENABLE_PQ} | Flow: {FLOW or 'none'}...")
        
        stream_settings = {}
        if XRAY_PROTOCOL == 'xhttp':
            stream_settings = {
                "network": "xhttp",
                "security": "tls",
                "tlsSettings": {"certificates": [{"certificateFile": CERT_FILE, "keyFile": KEY_FILE}]},
                "xhttpSettings": {"path": XHTTP_PATH}
            }
        else:
            stream_settings = {
                "network": "ws",
                "security": "tls",
                "tlsSettings": {"certificates": [{"certificateFile": CERT_FILE, "keyFile": KEY_FILE}]},
                "wsSettings": {"path": WS_PATH}
            }

        # æ ¸å¿ƒé€»è¾‘ï¼šdecryption å­—æ®µ
        # å¦‚æœå¼€å¯ PQ ä¸”æœ‰ Keyï¼Œåˆ™ç”¨ Keyï¼›å¦åˆ™å¿…é¡»æ˜¯ "none"
        decryption_value = DECRYPTION if (ENABLE_PQ and DECRYPTION) else "none"

        vless_settings = {
            "clients": [{"id": user_uuid, "flow": FLOW}],
            "decryption": decryption_value
        }

        config = {
            "log": {"access": "none", "error": "none", "loglevel": "none"},
            "inbounds": [{
                "port": PORT,
                "listen": "0.0.0.0",
                "protocol": "vless",
                "settings": vless_settings,
                "streamSettings": stream_settings
            }],
            "outbounds": [{"protocol": "freedom", "tag": "direct"}, {"protocol": "blackhole", "tag": "block"}]
        }

        with open(CFG, 'w') as f:
            json.dump(config, f)

        # å¯åŠ¨ Xray è¿›ç¨‹
        subprocess.Popen([BIN, '-c', CFG], start_new_session=True)
        print(f"ğŸš€ Xray Running on {PORT}")

        print_link(SERVER_HOST, PORT, f"{LINK_NAME}-Direct", 'direct')

        # --- å¯åŠ¨ FRP ---
        if NEED_FRP and os.path.exists(FRPC_TAR):
            print('ğŸ“¦ Unzipping FRP...')
            with tarfile.open(FRPC_TAR, "r:gz") as tar:
                tar.extractall(TMP)
            
            frp_found = find_bin(TMP, 'frpc')
            if frp_found:
                shutil.move(frp_found, FRPC_BIN)
                os.chmod(FRPC_BIN, 0o755)
                start_frp()

        # --- å¯åŠ¨ Argo ---
        if ENABLE_ARGO and os.path.exists(ARGO_BIN):
            os.chmod(ARGO_BIN, 0o755)

            if ARGO_TOKEN and ARGO_DOMAIN:
                print('â˜ï¸  Starting Argo (Token)...')
                subprocess.Popen([ARGO_BIN, 'tunnel', 'run', '--token', ARGO_TOKEN], 
                                 stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                print_link(ARGO_DOMAIN, 443, f"{LINK_NAME}-Argo", 'argo')
            else:
                print('â˜ï¸  Starting Argo (Quick)...')
                # éœ€è¦è¯»å– stderr æ¥è·å– trycloudflare é“¾æ¥
                def watch_argo_output(proc):
                    for line in iter(proc.stderr.readline, b''):
                        line_str = line.decode('utf-8', errors='ignore')
                        import re
                        m = re.search(r'(https://[a-zA-Z0-9-]+\.trycloudflare\.com)', line_str)
                        if m:
                            domain = m.group(1).replace('https://', '')
                            print_link(domain, 443, f"{LINK_NAME}-Argo", 'argo')
                
                argo_proc = subprocess.Popen(
                    [ARGO_BIN, 'tunnel', '--url', f'https://localhost:{PORT}', '--no-tls-verify', '--no-autoupdate'],
                    stdout=subprocess.DEVNULL, 
                    stderr=subprocess.PIPE
                )
                threading.Thread(target=watch_argo_output, args=(argo_proc,), daemon=True).start()

    except Exception as e:
        print(f"âŒ Fail: {e}")
        sys.exit(1)

    # --- è¾…åŠ©åŠŸèƒ½ï¼šæ¸…ç†ä¸æŠ¥å‘Š ---
    
    def show_details():
        if SHOW_LINKS and SAVED_LINKS:
            print('\n--- Saved Links ---')
            for link in SAVED_LINKS:
                print(link.strip())
            print('-------------------\n')

    # 30ç§’åæ¸…ç† TMP
    def cleanup_task():
        time.sleep(30)
        # æ¸…å± (ANSI escape)
        print('\033c', end='')
        if os.path.exists(TMP):
            try:
                shutil.rmtree(TMP, ignore_errors=True)
                print('ğŸ§¹ Cleaned up')
            except: pass
        show_details()

    threading.Thread(target=cleanup_task, daemon=True).start()

    # ä¸»å¾ªç¯ (Keep Alive)
    last_report_time = time.time()
    
    while True:
        current_time = time.time()
        
        # æ¯6å°æ—¶ (21600ç§’) æŠ¥å‘Šä¸€æ¬¡
        if current_time - last_report_time > 21600:
            print('\033c', end='')
            print(f"\nğŸ•’ Report: {time.strftime('%Y-%m-%d %H:%M:%S')}")
            show_details()
            last_report_time = current_time
            
        # ç®€å•çš„ Keep Alive æ‰“å°
        print(f'ğŸ’— Keep alive {time.strftime("%Y-%m-%d %H:%M:%S")}')
        sys.stdout.flush()
        time.sleep(300)

if __name__ == '__main__':
    main()
